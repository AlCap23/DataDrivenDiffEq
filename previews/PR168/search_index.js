var documenterSearchIndex = {"docs":
[{"location":"koopman/dmdc/#Dynamic-Mode-Decomposition-with-control-1","page":"Dynamic Mode Decomposition with control","title":"Dynamic Mode Decomposition with control","text":"","category":"section"},{"location":"koopman/dmdc/#","page":"Dynamic Mode Decomposition with control","title":"Dynamic Mode Decomposition with control","text":"Dynamic Mode Decomposition with Control is a method for generating an approximating linear differential equation in a chosen basis of observables. If X and Y are data matrices containing points of the same trajectory and U containing the exogenous inputs acting on that trajectory, then DMDc approximates","category":"page"},{"location":"koopman/dmdc/#","page":"Dynamic Mode Decomposition with control","title":"Dynamic Mode Decomposition with control","text":"G = Yleft beginarrayc X  U endarray right^dagger = leftK B right","category":"page"},{"location":"koopman/dmdc/#","page":"Dynamic Mode Decomposition with control","title":"Dynamic Mode Decomposition with control","text":"where dagger denotes the Moore-Penrose pseudoinverse and K is the approximation of the Koopman Operator and B the linear input map.","category":"page"},{"location":"koopman/dmdc/#","page":"Dynamic Mode Decomposition with control","title":"Dynamic Mode Decomposition with control","text":"DMDc approximates discrete time systems with inputs z of the form","category":"page"},{"location":"koopman/dmdc/#","page":"Dynamic Mode Decomposition with control","title":"Dynamic Mode Decomposition with control","text":"u_i+1 = K  u_i + B  z_i","category":"page"},{"location":"koopman/dmdc/#","page":"Dynamic Mode Decomposition with control","title":"Dynamic Mode Decomposition with control","text":"gDMDc approximates continuous time systems with inputs z of the form","category":"page"},{"location":"koopman/dmdc/#","page":"Dynamic Mode Decomposition with control","title":"Dynamic Mode Decomposition with control","text":"fracddtu =  K_G  u + B  z","category":"page"},{"location":"koopman/dmdc/#","page":"Dynamic Mode Decomposition with control","title":"Dynamic Mode Decomposition with control","text":"where K_G is the generator of the Koopman Operator.","category":"page"},{"location":"koopman/dmdc/#Functions-1","page":"Dynamic Mode Decomposition with control","title":"Functions","text":"","category":"section"},{"location":"koopman/dmdc/#","page":"Dynamic Mode Decomposition with control","title":"Dynamic Mode Decomposition with control","text":"DMDc\ngDMDc","category":"page"},{"location":"contributions/#Contributions-1","page":"Contributing","title":"Contributions","text":"","category":"section"},{"location":"contributions/#","page":"Contributing","title":"Contributing","text":"Contributions are welcome! To help, please:","category":"page"},{"location":"contributions/#","page":"Contributing","title":"Contributing","text":"Open (or solve) an issue\nReview pull requests\nAdapt code to be more efficient\nWrite new optimizers or algorithms\nWrite tutorials or adapt the docs","category":"page"},{"location":"contributions/#","page":"Contributing","title":"Contributing","text":"Feel free to write a private message to @AlCap23 for further discussion.","category":"page"},{"location":"koopman/dmd/#Dynamic-Mode-Decomposition-1","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"","category":"section"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"The (Exact) Dynamic Mode Decomposition is a method for generating an approximating linear differential equation directly from the observed data. If X and Y are data matrices containing points of the same trajectory, than DMD approximates","category":"page"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"K = YX^dagger","category":"page"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"where dagger denotes the Moore-Penrose pseudoinverse and K is the approximation of the Koopman Operator.","category":"page"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"DMD approximates discrete time systems of the form","category":"page"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"u_i+1 = K  u_i","category":"page"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"gDMD approximates continuous time systems of the form","category":"page"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"fracddtu =  K_G  u","category":"page"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"where K_G is the generator of the Koopman Operator.","category":"page"},{"location":"koopman/dmd/#Functions-1","page":"Dynamic Mode Decomposition","title":"Functions","text":"","category":"section"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"DMD\ngDMD","category":"page"},{"location":"koopman/dmd/#Examples-1","page":"Dynamic Mode Decomposition","title":"Examples","text":"","category":"section"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"using DataDrivenDiffEq\nusing OrdinaryDiffEq\nusing LinearAlgebra\nusing Plots\ngr()\n\nfunction linear_discrete(du, u, p, t)\n    du[1] = 0.9u[1]\n    du[2] = 0.05u[2] + 0.1u[1]\nend\n\nu0 = [10.0; -2.0]\ntspan = (0.0, 20.0)\nproblem = DiscreteProblem(linear_discrete, u0, tspan)\nsolution = solve(problem, FunctionMap())","category":"page"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"X = Array(solution)\n\napprox = DMD(X[:,1:3])\n\nprob_approx = DiscreteProblem(approx, u0, tspan)\napprox_sol = solve(prob_approx, FunctionMap())\n\nplot(approx_sol, label = [\"u[1]\" \"u[2]\"]) #hide\nplot!(solution, label = [\"True u[1]\" \"True u[2]\"]) #hide\nsavefig(\"dmd_example_1.png\") #hide","category":"page"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"(Image: )","category":"page"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"\nfunction linear_discrete_2(du, u, p, t)\n    du[1] = 0.9u[1] + 0.05u[2]\n    du[2] = 0.1u[1]\nend\n\nproblem = DiscreteProblem(linear_discrete_2, u0, tspan)\nsolution = solve(problem, FunctionMap())\n\nX = Array(solution)\n\nupdate!(approx, X[:, 4:end-1], X[:, 5:end])\n\nprob_approx = DiscreteProblem(approx, u0, tspan)\napprox_sol = solve(prob_approx, FunctionMap())\n\n# Show solutions\nplot(approx_sol, label = [\"u[1]\" \"u[2]\"]) #hide\nplot!(solution, label = [\"True u[1]\" \"True u[2]\"]) #hide\nsavefig(\"dmd_example_2.png\") #hide","category":"page"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"(Image: )","category":"page"},{"location":"koopman/algorithms/#Algorithms-for-Estimation-1","page":"Algorithms for Estimation","title":"Algorithms for Estimation","text":"","category":"section"},{"location":"koopman/algorithms/#","page":"Algorithms for Estimation","title":"Algorithms for Estimation","text":"There are different variants of estimation of the Koopman Operator, see e.g., here, here or here.","category":"page"},{"location":"koopman/algorithms/#","page":"Algorithms for Estimation","title":"Algorithms for Estimation","text":"Currently, DataDrivenDiffEq implements the following AbstractKoopmanAlgorithms to use with DMD, EDMD, and DMDc.","category":"page"},{"location":"koopman/algorithms/#Functions-1","page":"Algorithms for Estimation","title":"Functions","text":"","category":"section"},{"location":"koopman/algorithms/#","page":"Algorithms for Estimation","title":"Algorithms for Estimation","text":"DMDPINV\nDMDSVD\nTOTALDMD","category":"page"},{"location":"koopman/algorithms/#Implementing-New-Algorithms-1","page":"Algorithms for Estimation","title":"Implementing New Algorithms","text":"","category":"section"},{"location":"koopman/algorithms/#","page":"Algorithms for Estimation","title":"Algorithms for Estimation","text":"Is pretty straightforward. The implementation of DMDPINV looks like:","category":"page"},{"location":"koopman/algorithms/#","page":"Algorithms for Estimation","title":"Algorithms for Estimation","text":"\nmutable struct DMDPINV <: AbstractKoopmanAlgorithm end;\n\n(x::DMDPINV)(X::AbstractArray, Y::AbstractArray) = Y / X\n","category":"page"},{"location":"koopman/algorithms/#","page":"Algorithms for Estimation","title":"Algorithms for Estimation","text":"So, right now, all you have to do is to implement a struct which is callable with the data matrices X and Y. Possible Parameters should be stored in the fields of the algorithm.","category":"page"},{"location":"basis/#Basis-1","page":"Basis","title":"Basis","text":"","category":"section"},{"location":"basis/#","page":"Basis","title":"Basis","text":"Many of the methods require the definition of a Basis on observables or functional forms. A Basis is generated via:","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"Basis(h, u, parameters = [], iv = nothing)","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"where h is either a vector of ModelingToolkit Operations for the valid functional forms or a general function with the typical DiffEq signature h(u,p,t), which can be used with an  Operation or vector of Operation. u are the ModelingToolkit Variables used to describe the Basis, and parameters are the optional ModelingToolkit Variables used to describe the parameters in the basis elements. iv represents the independent variable of the system - the time.","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"Basis","category":"page"},{"location":"basis/#DataDrivenDiffEq.Basis","page":"Basis","title":"DataDrivenDiffEq.Basis","text":"Basis(f, u; p, iv, linear_independent = false, simplify_eqs = true, eval_expression = false)\n\nA basis over the variables u with parameters p and independent variable iv. f can either be a Julia function which is able to use ModelingToolkit variables or a vector of Operation. It can be called with the typical DiffEq signature, meaning out of place with f(u,p,t) or in place with f(du, u, p, t). If linear_independent is set to true, a linear independent basis is created from all atom function in f. If simplify_eqs is set to true, simplify is called on f.\n\nExample\n\nusing ModelingToolkit\nusing DataDrivenDiffEq\n\n@parameters w[1:2] t\n@variables u[1:2]\n\nΨ = Basis([u; sin.(w.*u)], u, parameters = p, iv = t)\n\nNote\n\nThe keyword argument eval_expression controls the function creation behavior. eval_expression=true means that eval is used, so normal world-age behavior applies (i.e. the functions cannot be called from the function that generates them). If eval_expression=false, then construction via GeneralizedGenerated.jl is utilized to allow for same world-age evaluation. However, this can cause Julia to segfault on sufficiently large basis functions. By default eval_expression=false.\n\n\n\n\n\n","category":"type"},{"location":"basis/#Example-1","page":"Basis","title":"Example","text":"","category":"section"},{"location":"basis/#","page":"Basis","title":"Basis","text":"We start by crearting some Variables and Parameters using ModelingToolkit.","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"using LinearAlgebra\nusing DataDrivenDiffEq\nusing Plots\nusing ModelingToolkit\n\n@variables u[1:3]\n@parameters w[1:2]","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"To define a basis, simply write down the equations you want to be included as a Vector{Operation}. Possible used parameters have to be given to the constructor.","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"h = [u[1]; u[2]; cos(w[1]*u[2]+w[2]*u[3])]\nb = Basis(h, u, parameters = w)","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"What can a Basis do? Can it do stuff? Let's find out!","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"Basis are callable with the signature of functions to be used in DifferentialEquations. So, the function value at a single point looks like:","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"x = b([1;2;3])","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"Or, in place","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"dx = similar(x)\nb(dx, [1;2;3])","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"Notice that since we did not use any numerical values for the parameters, the basis uses the symbolic values in the result.","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"To use numerical values, simply pass this on in the function call. Here, we evaluate over a trajectory with two parameters and 40 timestamps.","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"X = randn(3, 40)\nY = b(X, [2;4], 0:39)\nnothing # hide","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"Suppose we want to add another equation, say sin(u[1]). A Basis behaves like an array, so we can simply","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"push!(b, sin(u[1]))\nsize(b)","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"To ensure that a basis is well-behaved, functions already present are not included again.","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"push!(b, sin(u[1]))\nsize(b)","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"We can also define functions of time and add them","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"t = independent_variable(b)\npush!(b, cos(t*π))\nprintln(b)","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"Additionally, we can iterate over a Basis using [eq for eq in basis] or index specific equations, like basis[2].","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"We can also chain Basis via just using it in the constructor","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"@variables x[1:2]\ny = [sin(x[1]); cos(x[1]); x[2]]\nt = independent_variable(b)\nb2 = Basis(b(y, parameters(b), t), x, parameters = w, iv = t)\nprintln(b2)","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"You can also use merge to create the union of two Basis:","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"b3 = merge(b, b2)\nprintln(b3)","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"which combines all the used variables and parameters ( and assumes the same independent_variable ):","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"variables(b)","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"parameters(b)","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"If you have a function already defined as pure code, you can use this also to create a Basis. Only the signature has to be consistent, so use f(u,p,t).","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"f(u, p, t) = [u[1]; u[2]; cos(p[1]*u[2]+p[2]*u[3])]\nb_f = Basis(f, u, parameters = w)\nprintln(b_f)","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"This works for every function defined over Operations. So to create a Basis from a Flux model, simply extend the activations used:","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"using Flux\nNNlib.σ(x::Operation) = 1 / (1+exp(-x))\n\nc = Chain(Dense(3,2,σ), Dense(2, 1, σ))\nps, re = Flux.destructure(c)\n\n@parameters p[1:length(ps)]\n\ng(u, p, t) = re(p)(u)\nb = Basis(g, u, parameters = p)","category":"page"},{"location":"basis/#Functions-1","page":"Basis","title":"Functions","text":"","category":"section"},{"location":"basis/#","page":"Basis","title":"Basis","text":"parameters\nvariables\nDataDrivenDiffEq.independent_variable\njacobian\ndynamics\npush!\ndeleteat!\nmerge\nmerge!","category":"page"},{"location":"sparse_identification/isindy/#Implicit-Sparse-Identification-of-Nonlinear-Dynamics-1","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"","category":"section"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"While SINDy works well for ODEs, some systems take the form of DAEs. A common form is f(x, p, t) - g(x, p, t)*dx = 0. These can be inferred via ISINDy, which extends SINDy for Implicit problems. In particular, it solves","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"Xi = min  leftlVert Theta(X p t)^T Xi rightrVert_2 + lambda  leftlVert Xi rightrVert_1","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"where Xi lies in the nullspace of Theta.","category":"page"},{"location":"sparse_identification/isindy/#Example-:-Michaelis-Menten-Kinetics-1","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Example : Michaelis-Menten Kinetics","text":"","category":"section"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"Let's try to infer the Michaelis-Menten Kinetics, like in the corresponding paper. We start by generating the corresponding data.","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing OrdinaryDiffEq\nusing LinearAlgebra\nusing Plots\ngr()\n\nfunction michaelis_menten(u, p, t)\n    [0.6 - 1.5u[1]/(0.3+u[1])]\nend\n\nu0 = [0.5]\ntspan = (0.0, 5.0)\nproblem = ODEProblem(michaelis_menten, u0, tspan)\n\nsolution = solve(problem, Tsit5(), saveat = 0.1, atol = 1e-7, rtol = 1e-7)\n    \nplot(solution) # hide\nsavefig(\"iSINDy_example.png\")","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"(Image: )","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"X = solution[:,:]\nDX = similar(X)\nfor (i, xi) in enumerate(eachcol(X))\n    DX[:, i] = michaelis_menten(xi, [], 0.0)\nend\n\n@variables u\nbasis= Basis([u^i for i in 0:4], [u])","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"The signature of ISINDy is equal to SINDy, but requires an AbstractSubspaceOptimizer. Currently, DataDrivenDiffEq just implements ADM() based on alternating directions. rtol gets passed into the derivation of the nullspace via LinearAlgebra.","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"opt = ADM(1.1e-1)","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"Since ADM() returns sparsified columns of the nullspace we need to find a pareto optimal solution. To achieve this, we provide a sufficient cost function g to ISINDy. This allows us to evaluate each individual column of the sparse matrix on its 0-norm (sparsity) and the 2-norm of the matrix vector product of Theta^T xi (nullspace). This is a default setting which can be changed by providing a function f which maps the coefficients and the library onto a feature space. Here, we want to set the focus on the the magnitude of the deviation from the nullspace.","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"Ψ = ISINDy(X, DX, basis, opt, g = x->norm([1e-1*x[1]; x[2]]), maxiter = 100)\nnothing #hide","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"The function call returns a SparseIdentificationResult. As in Sparse Identification of Nonlinear Dynamics, we can transform the SparseIdentificationResult into an ODESystem.","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"# Transform into ODE System\nsys = ODESystem(Ψ)\ndudt = ODEFunction(sys)\nps = parameters(Ψ)\n\nestimator = ODEProblem(dudt, u0, tspan, ps)\nestimation = solve(estimator, Tsit5(), saveat = 0.1)\n\nplot(solution, color = :red, label = \"True\") # hide\nplot!(estimation, color = :green, label = \"Estimation\") # hide\nsavefig(\"iSINDy_example_final.png\") # hide","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"(Image: )","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"The model recovered by ISINDy is  correct","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"print_equations(Ψ)","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"The parameters are off a little, but, as before, we can use DiffEqFlux to tune them.","category":"page"},{"location":"sparse_identification/isindy/#Example-:-Cart-Pole-with-Time-Dependent-Control-1","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Example : Cart-Pole with Time-Dependent Control","text":"","category":"section"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"Implicit dynamics can also be reformulated as an explicit problem as stated in this paper. The algorithm searches the correct equations by trying out all candidate functions as a right hand side and performing a sparse regression onto the remaining set of candidates. Let's start by defining the problem and generate the data:","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"\nusing DataDrivenDiffEq\nusing ModelingToolkit\nusing OrdinaryDiffEq\nusing LinearAlgebra\nusing Plots\ngr()\n\nfunction cart_pole(u, p, t)\n    du = similar(u)\n    F = -0.2 + 0.5*sin(6*t) # the input\n    du[1] = u[3]\n    du[2] = u[4]\n    du[3] = -(19.62*sin(u[1])+sin(u[1])*cos(u[1])*u[3]^2+F*cos(u[1]))/(2-cos(u[1])^2)\n    du[4] = -(sin(u[1])*u[3]^2 + 9.81*sin(u[1])*cos(u[1])+F)/(2-cos(u[1])^2)\n    return du\nend\n\nu0 = [0.3; 0; 1.0; 0]\ntspan = (0.0, 16.0)\ndt = 0.001\ncart_pole_prob = ODEProblem(cart_pole, u0, tspan)\nsolution = solve(cart_pole_prob, Tsit5(), saveat = dt)\n\n# Create the differential data\nX = solution[:,:]\nDX = similar(X)\nfor (i, xi) in enumerate(eachcol(X))\n    DX[:, i] = cart_pole(xi, [], solution.t[i])\nend\n\nplot(solution) # hide\nsavefig(\"iSINDy_cartpole_data.png\") # hide\n","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"(Image: )","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"We see that we include a forcing term F inside the model which is depending on t. As before, we will also need a Basis to derive our equations from:","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"@variables u[1:4] t\npolys = Operation[]\nfor i ∈ 0:4\n    if i == 0\n        push!(polys, u[1]^0)\n    else\n        if i < 2\n            push!(polys, u.^i...)\n        else\n            push!(polys, u[3:4].^i...)\n        end\n        \n    end\nend\npush!(polys, sin.(u[1])...)\npush!(polys, cos.(u[1]))\npush!(polys, sin.(u[1]).*u[3:4]...)\npush!(polys, sin.(u[1]).*u[3:4].^2...)\npush!(polys, cos.(u[1]).^2...)\npush!(polys, sin.(u[1]).*cos.(u[1])...)\npush!(polys, sin.(u[1]).*cos.(u[1]).*u[3:4]...)\npush!(polys, sin.(u[1]).*cos.(u[1]).*u[3:4].^2...)\npush!(polys, -0.2+0.5*sin(6*t))\npush!(polys, (-0.2+0.5*sin(6*t))*cos(u[1]))\npush!(polys, (-0.2+0.5*sin(6*t))*sin(u[1]))\nbasis= Basis(polys, u, iv = t)","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"We added the time dependent input directly into the basis to account for its influence.","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"NOTE : Including input signals may change in future releases!","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"Like for a SINDy, we can use any AbstractOptimizer with a pareto front optimization over different thresholds. ","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"λ = exp10.(-4:0.1:-1)\ng(x) = norm([1e-3; 10.0] .* x, 2)\nΨ = ISINDy(X[:,:], DX[:, :], basis, λ, STRRidge(), maxiter = 100, normalize = false, t = solution.t, g = g)\n\n# Transform into ODE System\nsys = ODESystem(Ψ)\ndudt = ODEFunction(sys)\nps = parameters(Ψ)\n\n# Simulate\nestimator = ODEProblem(dudt, u0, tspan, ps)\nsol_ = solve(estimator, Tsit5(), saveat = dt)\n\nplot(solution.t[:], solution[:,:]', color = :red, label = nothing) # hide\nplot!(sol_.t, sol_[:, :]', color = :green, label = \"Estimation\") # hide\nsavefig(\"iSINDy_cartpole_estimation.png\") # hide","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"(Image: )","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"Let's have a look at the equations recovered. They match up.","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"print_equations(Ψ)","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"Alternatively, we can also use the input as an extended state x.","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"@variables u[1:4] t x\npolys = Operation[]\n# Lots of basis functions -> sindy pi can handle more than ADM()\nfor i ∈ 0:4\n    if i == 0\n        push!(polys, u[1]^0)\n    else\n        if i < 2\n            push!(polys, u.^i...)\n        else\n            push!(polys, u[3:4].^i...)\n        end\n        \n    end\nend\npush!(polys, sin.(u[1])...)\npush!(polys, cos.(u[1]))\npush!(polys, sin.(u[1]).*u[3:4]...)\npush!(polys, sin.(u[1]).*u[3:4].^2...)\npush!(polys, cos.(u[1]).^2...)\npush!(polys, sin.(u[1]).*cos.(u[1])...)\npush!(polys, sin.(u[1]).*cos.(u[1]).*u[3:4]...)\npush!(polys, sin.(u[1]).*cos.(u[1]).*u[3:4].^2...)\npush!(polys, x)\npush!(polys, x*cos(u[1]))\npush!(polys, x*sin(u[1]))\nbasis= Basis(polys, vcat(u, x), iv = t)","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"Now we include the input signal into the extended state array Xᵤ and perform a sparse regression.","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"U = -0.2 .+ 0.5*sin.(6*solution.t)\nXᵤ = vcat(X, U')\n\nλ = exp10.(-4:0.5:-1)\ng(x) = norm([1e-3; 10.0] .* x, 2)\nΨ = ISINDy(Xᵤ[:,:], DX[:, :], basis, λ, STRRidge(), maxiter = 100, normalize = false, t = solution.t, g = g)\nprint_equations(Ψ, show_parameter = true)","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"Currently, we can not generate an ODESystem out of the resulting equations, which is a work in progress.","category":"page"},{"location":"sparse_identification/isindy/#Functions-1","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Functions","text":"","category":"section"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"ISINDy","category":"page"},{"location":"koopman/koopman/#koopman_operator-1","page":"Koopman Operators","title":"Koopman Operators","text":"","category":"section"},{"location":"koopman/koopman/#","page":"Koopman Operators","title":"Koopman Operators","text":"LinearKoopman\nNonlinearKoopman","category":"page"},{"location":"koopman/koopman/#Functions-1","page":"Koopman Operators","title":"Functions","text":"","category":"section"},{"location":"koopman/koopman/#","page":"Koopman Operators","title":"Koopman Operators","text":"operator\ngenerator\ninputmap\noutputmap\nupdate!\nis_discrete\nis_continuous\nupdatable\nisstable\neigen\neigvals\neigvecs\nmodes\nfrequencies\nreduce_basis","category":"page"},{"location":"utils/#Basis-Generators-1","page":"Utilities","title":"Basis Generators","text":"","category":"section"},{"location":"utils/#","page":"Utilities","title":"Utilities","text":"monomial_basis\npolynomial_basis\nchebyshev_basis\nsin_basis\ncos_basis\nfourier_basis","category":"page"},{"location":"utils/#Utility-Functions-1","page":"Utilities","title":"Utility Functions","text":"","category":"section"},{"location":"utils/#","page":"Utilities","title":"Utilities","text":"AIC\nAICC\nBIC\noptimal_shrinkage\nsavitzky_golay\nburst_sampling\nsubsample","category":"page"},{"location":"sparse_identification/optimizers/#Optimizer-1","page":"Optimizer","title":"Optimizer","text":"","category":"section"},{"location":"sparse_identification/optimizers/#","page":"Optimizer","title":"Optimizer","text":"DataDrivenDiffEq comes with some implementations for sparse regression included. All of these are stored inside the DataDrivenDiffEq.Optimize package and extend the AbstractOptimizer, if an explicit optimization is needed or the AbstractSubspaceOptimizer for an implicit problem (where the solution is within the nullspace).","category":"page"},{"location":"sparse_identification/optimizers/#Functions-1","page":"Optimizer","title":"Functions","text":"","category":"section"},{"location":"sparse_identification/optimizers/#","page":"Optimizer","title":"Optimizer","text":"STRRidge\nADMM\nSR3\nDataDrivenDiffEq.Optimize.ADM","category":"page"},{"location":"sparse_identification/optimizers/#Implementing-New-Optimizer-1","page":"Optimizer","title":"Implementing New Optimizer","text":"","category":"section"},{"location":"sparse_identification/optimizers/#","page":"Optimizer","title":"Optimizer","text":"Similarly to Algorithms for Estimation, the extension of optimizers is more or less straightforward. Suppose you want to define a new optimizer MyOpt, which should solve AX = Y for a sparse X.","category":"page"},{"location":"sparse_identification/optimizers/#","page":"Optimizer","title":"Optimizer","text":"mutable struct MyOpt <: DataDrivenDiffEq.Optimize.AbstractOptimizer\n    threshold\nend","category":"page"},{"location":"sparse_identification/optimizers/#","page":"Optimizer","title":"Optimizer","text":"To use MyOpt within SINDy, an init! function has to be implemented.","category":"page"},{"location":"sparse_identification/optimizers/#","page":"Optimizer","title":"Optimizer","text":"function init!(X::AbstractArray, o::MyOpt, A::AbstractArray, Y::AbstractArray)\n    X .=  A \\ Y\nend","category":"page"},{"location":"sparse_identification/optimizers/#","page":"Optimizer","title":"Optimizer","text":"To perform thresholding - and use maybe for searching the right threshold - a setter and getter is required:","category":"page"},{"location":"sparse_identification/optimizers/#","page":"Optimizer","title":"Optimizer","text":"set_threshold!(opt::MyOpt, threshold) = opt.threshold .= threshold\n\nget_threshold(opt::MyOpt) = opt.threshold","category":"page"},{"location":"sparse_identification/optimizers/#","page":"Optimizer","title":"Optimizer","text":"And, at last, the method which fits the data and returns the iterations needed:","category":"page"},{"location":"sparse_identification/optimizers/#","page":"Optimizer","title":"Optimizer","text":"function fit!(X::AbstractArray, A::AbstractArray, Y::AbstractArray, opt::MyOpt; maxiter, convergence_error)\n    # Compute awesome stuff here\n    return iterations\nend","category":"page"},{"location":"koopman/edmd/#Extended-Dynamic-Mode-Decomposition-1","page":"Extended Dynamic Mode Decomposition","title":"Extended Dynamic Mode Decomposition","text":"","category":"section"},{"location":"koopman/edmd/#","page":"Extended Dynamic Mode Decomposition","title":"Extended Dynamic Mode Decomposition","text":"Extended Dynamic Mode Decomposition is a method for generating an approximating linear differential equation in a chosen basis of observables. If X and Y are data matrices containing points of the same trajectory and Ψ is a basis, then EDMD approximates","category":"page"},{"location":"koopman/edmd/#","page":"Extended Dynamic Mode Decomposition","title":"Extended Dynamic Mode Decomposition","text":"K = Ψ(Y)Ψ(X)^dagger","category":"page"},{"location":"koopman/edmd/#","page":"Extended Dynamic Mode Decomposition","title":"Extended Dynamic Mode Decomposition","text":"where dagger denotes the Moore-Penrose pseudoinverse and K is the approximation of the Koopman Operator.","category":"page"},{"location":"koopman/edmd/#","page":"Extended Dynamic Mode Decomposition","title":"Extended Dynamic Mode Decomposition","text":"EDMD approximates discrete time systems of the form","category":"page"},{"location":"koopman/edmd/#","page":"Extended Dynamic Mode Decomposition","title":"Extended Dynamic Mode Decomposition","text":"Psi(u_i+1) = K  Psi(u_i) \nu_i+1 = CPsi(u_i)","category":"page"},{"location":"koopman/edmd/#","page":"Extended Dynamic Mode Decomposition","title":"Extended Dynamic Mode Decomposition","text":"gEDMD approximates continuous time systems of the form","category":"page"},{"location":"koopman/edmd/#","page":"Extended Dynamic Mode Decomposition","title":"Extended Dynamic Mode Decomposition","text":"fracddtPsi(u) =  K_G  Psi(u) \nfracddtu = CfracddtPsi(u)","category":"page"},{"location":"koopman/edmd/#","page":"Extended Dynamic Mode Decomposition","title":"Extended Dynamic Mode Decomposition","text":"where K_G is the generator of the Koopman Operator. C is a matrix mapping from the observations back onto the states or differential states.","category":"page"},{"location":"koopman/edmd/#Functions-1","page":"Extended Dynamic Mode Decomposition","title":"Functions","text":"","category":"section"},{"location":"koopman/edmd/#","page":"Extended Dynamic Mode Decomposition","title":"Extended Dynamic Mode Decomposition","text":"EDMD\ngEDMD","category":"page"},{"location":"extended_examples/#Multiple-Trajectories-for-Koopman-Approximation-1","page":"Extended Examples","title":"Multiple Trajectories for Koopman Approximation","text":"","category":"section"},{"location":"extended_examples/#","page":"Extended Examples","title":"Extended Examples","text":"Lets consider the case of approximating a Koopman Operator based on multiple trajectories. We assume pairs (x_i dotx_i) of the measured state space trajectory and its time derivative where i denotes a single measurement. ","category":"page"},{"location":"extended_examples/#","page":"Extended Examples","title":"Extended Examples","text":"Lets create our artificial measurements for a system with a slow and fast manifold, for which there exists an analytical solution of this problem.","category":"page"},{"location":"extended_examples/#","page":"Extended Examples","title":"Extended Examples","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing OrdinaryDiffEq\nusing LinearAlgebra\nusing Plots\ngr()\n\n\nfunction slow_manifold(du, u, p, t)\n    du[1] = p[1]*u[1]\n    du[2] = p[2]*(u[2]-u[1]^2)\nend\n  \nu0 = [3.0; -2.0]\ntspan = (0.0, 3.0)\np = [-0.05, -1.0]\n\nproblem = ODEProblem(slow_manifold, u0, (0f0, 3f0), p)\nsol_1= solve(problem, Tsit5(), saveat = 0.3)\nX_1 = Array(sol_1)\nDX_1 = sol_1(sol_1.t, Val{1})[:,:]\n\nproblem = ODEProblem(slow_manifold, 2f0*u0, (0f0, 2f0), p)\nsol_2 = solve(problem, Tsit5(), saveat = 0.1)\nX_2 = Array(sol_2)\nDX_2 = sol_2(sol_2.t, Val{1})[:,:]\n\nscatter(X_1[1,:], X_1[2,:], legend = false, label = \"Trajectory 1\") #hide\nscatter!(X_2[1,:], X_2[2,:], legend = true, label = \"Trajectory 2\") #hide\nsavefig(\"multiple_koopman_trajectories.png\") #hide","category":"page"},{"location":"extended_examples/#","page":"Extended Examples","title":"Extended Examples","text":"Note that we varied the inital conditions and the measurement time. The resulting trajectories are shown below.","category":"page"},{"location":"extended_examples/#","page":"Extended Examples","title":"Extended Examples","text":"(Image: )","category":"page"},{"location":"extended_examples/#","page":"Extended Examples","title":"Extended Examples","text":"In this paper on the Dynamic Mode Decomposition its pointed out that the overall ordering of the snapshots does not matter, as long as the specific pair is consistent. This means we can simply append the trajectories and use the new array to derive the approximation.","category":"page"},{"location":"extended_examples/#","page":"Extended Examples","title":"Extended Examples","text":"X = hcat(X_1, X_2)\nDX = hcat(DX_1, DX_2)","category":"page"},{"location":"extended_examples/#","page":"Extended Examples","title":"Extended Examples","text":"In the next steps, we simply create a basis for the approximation and proceed as usual. At first we create the basis and afterwards feed it to the function for approximating the Koopman generator.","category":"page"},{"location":"extended_examples/#","page":"Extended Examples","title":"Extended Examples","text":"@variables u[1:2]\n\nobservables = [u; u[1]^2]\n\nbasis = Basis(observables, u)\n\napproximation = gEDMD(X, DX, basis)\n\nscatter(eigvals(approximation), label = \"Estimate\") # hide\nscatter!(eigvals([p[1] 0 0; 0 p[2] -p[2]; 0 0 2*p[1]]), label = \"True\", legend = :bottomright) #hide\nsavefig(\"eigenvalue_slowmanifold_multiple_trajectories.png\") #hide","category":"page"},{"location":"extended_examples/#","page":"Extended Examples","title":"Extended Examples","text":"Which results in the following eigenvalues of the system and its approximation.","category":"page"},{"location":"extended_examples/#","page":"Extended Examples","title":"Extended Examples","text":"(Image: )","category":"page"},{"location":"extended_examples/#","page":"Extended Examples","title":"Extended Examples","text":"This procedure works for all methods which take two snapshot matrices as input arguments. ","category":"page"},{"location":"quickstart/#Quickstart-1","page":"Getting Started","title":"Quickstart","text":"","category":"section"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"In the following, we will use some of the techniques provided by DataDrivenDiffEq to infer some models.","category":"page"},{"location":"quickstart/#Linear-Damped-Oscillator-Dynamic-Mode-Decomposition-1","page":"Getting Started","title":"Linear Damped Oscillator - Dynamic Mode Decomposition","text":"","category":"section"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"To begin, let's create our own data for the linear oscillator with damping.","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"using OrdinaryDiffEq\nusing Plots\ngr()\n\nusing DataDrivenDiffEq\nusing LinearAlgebra\n\nfunction linear!(du, u, p, t)\n  du[1] = u[2]\n  du[2] = -u[1] - 0.1*u[2]\nend\n\nu0 = Float64[0.99π; -0.3]\ntspan = (0.0, 40.0)\n\nproblem = ODEProblem(linear!, u0, tspan)\nsolution = solve(problem, Tsit5(), saveat = 1.0)\n\nplot(solution)\nsavefig(\"linear_solution.png\") #hide","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"Let's assume we have just the trajectory data and let's call it X. Since we gathered the data at a fixed interval of one time unit, we will try to fit a linear model. And, of course, we use a subset of the data for training and the rest for testing.","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"\nX = Array(solution)\n\napproximation = DMD(X[:, 1:20])\n\napprox_prob = DiscreteProblem(approximation, u0, tspan)\napprox_sol = solve(approx_prob, FunctionMap())\n\nplot(approx_sol, label = [\"u[1]\" \"u[2]\"]) #hide\nscatter!(solution, label = [\"True u[1]\" \"True u[2]\"]) #hide\nsavefig(\"pendulum_approximation.png\") #hide","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"Yeah! The model fits! But what exactly did we do?","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"DMD is short for Dynamic Mode Decomposition, a technique which generates a linear model from data. So, given the data matrix X, we simply divided it up into two data sets and performed a linear fitting between those.","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"Note that we fitted a discrete model, which fits our continuous data. This is possible because:","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"The measurements were taken at an interval of 1.0\nThe original, unknown model has a discrete, linear solution","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"To check this, we can compare the operator of our linear fit with the matrix exponential of the original model.","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"dt = 1.0\nK = operator(approximation)\nnorm(K - exp(dt*[0.0 1.0; -1.0 -0.1]), 2)","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"The reason for using operator as a function to get the corresponding matrix of the approximation is the connection of Dynamic Mode Decomposition to the Koopman Operator. You might have noticed that the return value of DMD is a LinearKoopman.","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"The LinearKoopman overloads some useful functions from LinearAlgebra to perform analysis. Let's have a look at the eigenvalues of the operator:","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"scatter(eigvals(approximation))\n\n# Add the stability margin\nϕ = 0:0.01π:2π\nplot!(cos.(ϕ), sin.(ϕ),\n  color = :red, linestyle = :dot,\n  label = \"Stability Margin\",\n  xlim = (-1,1), ylim = (-1,1), legend = :bottomleft)\n\nsavefig(\"eigenvalue_lineardamped.png\") #hide","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"For more information on the LinearKoopman, have a look at the corresponding documentation.","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"But wait! We want a continuous model. There is also a corresponding algorithm for this : gDMD ! As opposed to DMD, which provides a discrete model based on the direct measurements X, gDMD estimates the generator of the dynamical system given X and the differential states DX. Since we did not measure any differential states, we can just provide a vector of time measurements. gDMD will automatically interpolate using DataInterpolations.jl and perform numerical differentiation using FiniteDifferences.jl.","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"Here, we will provide gDMD with the measurement data and use a new sample time of 0.1","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"t = solution.t\nX = Array(solution)\n\ngenerator_approximation = gDMD(t[1:20], X[:, 1:20], dt = 0.1)\n\ngenerator_prob = ODEProblem(generator_approximation, u0 , tspan)\ngenerator_sol = solve(generator_prob, Tsit5())\n\nplot(generator_sol, label = [\"u[1]\" \"u[2]\"]) #hide\nscatter!(solution, label = [\"True u[1]\" \"True u[2]\"]) #hide\nsavefig(\"linear_approximation_cont.png\") #hide","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"Since we have a continuous estimation, let's look at the generator of the estimation","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"G = generator(generator_approximation)\nnorm(G-[0.0 1.0; -1.0 -0.1], 2)","category":"page"},{"location":"quickstart/#Nonlinear-Systems-Extended-Dynamic-Mode-Decomposition-1","page":"Getting Started","title":"Nonlinear Systems - Extended Dynamic Mode Decomposition","text":"","category":"section"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"But what about nonlinear systems? Even though Dynamic Mode Decomposition will help us to figure out the best linear fit, we are interested in figuring out all the nonlinear parts of the equations. Luckily, Koopman theory covers this! To put it very (very very) simply : If you spread out your information in many observable functions, you will end up with a linear system in those observables. So you might end up with a trade-off between a huge system which is linear in the observables vs a small, nonlinear system.","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"But how can we leverage this? We use the Extended Dynamic Mode Decomposition, or EDMD for short. EDMD does more or less the exact same thing like DMD, but in the new Basis of nonlinear observables. We will investigate now a fairly standard system, with a slow and fast manifold, for which there exists an analytical solution of this problem.","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"using OrdinaryDiffEq\nusing Plots\ngr()\n\nusing DataDrivenDiffEq\nusing LinearAlgebra\nusing ModelingToolkit\n\nfunction slow_manifold(du, u, p, t)\n  du[1] = p[1]*u[1]\n  du[2] = p[2]*(u[2]-u[1]^2)\nend\n\nu0 = [3.0; -2.0]\ntspan = (0.0, 10.0)\np = [-0.05, -1.0]\n\nproblem = ODEProblem(slow_manifold, u0, tspan, p)\nsolution = solve(problem, Tsit5(), saveat = 0.2)\n\nX = Array(solution)\nDX = solution(solution.t, Val{1})\n\nplot(solution) # hide\nsavefig(\"slow_manifold.png\") # hide","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"Since we want to estimate the continuous system, we also capture the trajectory of the differential states. Now, we will create our nonlinear observables, which is represented as a Basis in DataDrivenDiffEq.jl.","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"@variables u[1:2]\n\nobservables = [u; u[1]^2]\n\nbasis = Basis(observables, u)","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"A Basis captures a bunch of functions defined over some variables provided via ModelingToolkit.jl. Here, we included the state and u[1]^2. Now, we simply call gEDMD, which will compute the generator of the Koopman Operator associated with the model.","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"approximation = gEDMD(X, DX, basis)\n\napproximation_problem = ODEProblem(approximation, u0, tspan)\ngenerator_sol = solve(approximation_problem, Tsit5(), saveat = solution.t)\n\nplot(generator_sol, label = [\"u[1]\" \"u[2]\"]) #hide\nscatter!(solution, label = [\"True u[1]\" \"True u[2]\"]) #hide\nsavefig(\"slow_approximation_cont.png\") #hide\nscatter(eigvals(approximation), label = \"Estimate\") # hide\nscatter!(eigvals([p[1] 0 0; 0 p[2] -p[2]; 0 0 2*p[1]]), label = \"True\", legend = :bottomright) #hide\nsavefig(\"eigenvalue_slowmanifold.png\") #hide\n","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"Looking at the eigenvalues of the system, we see that the estimated eigenvalues of the linear system are close to the true values.","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"quickstart/#Nonlinear-Systems-Sparse-Identification-of-Nonlinear-Dynamics-1","page":"Getting Started","title":"Nonlinear Systems - Sparse Identification of Nonlinear Dynamics","text":"","category":"section"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"Okay, so far we can fit linear models via DMD and nonlinear models via EDMD. But what if we want to find a model of a nonlinear system without moving to Koopman space? Simple, we use Sparse Identification of Nonlinear Dynamics or SINDy.","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"As the name suggests, SINDy finds the sparsest basis of functions which build the observed trajectory. Again, we will start with a nonlinear system","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing OrdinaryDiffEq\nusing LinearAlgebra\nusing Plots\ngr()\n\nfunction pendulum(u, p, t)\n    x = u[2]\n    y = -9.81sin(u[1]) - 0.1u[2]\n    return [x;y]\nend\n\nu0 = [0.4π; 1.0]\ntspan = (0.0, 20.0)\nproblem = ODEProblem(pendulum, u0, tspan)\nsolution = solve(problem, Tsit5(), atol = 1e-8, rtol = 1e-8, saveat = 0.001)\n\nX = Array(solution)\nDX = solution(solution.t, Val{1})\n\nplot(solution) # hide\nsavefig(\"nonlinear_pendulum.png\") # hide","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"which is the simple nonlinear pendulum with damping.","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"Suppose we are like John and know nothing about the system, we have just the data in front of us. To apply SINDy, we need three ingredients:","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"A Basis containing all possible candidate functions which might be in the model\nAn optimizer which is able to produce a sparse output\nA threshold for the optimizer","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"It might seem to you that the third point is more a parameter of the optimizer (which it is), but, nevertheless, it is a crucial decision where to cut off parameters.","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"So, let's create a bunch of basis functions for our problem first","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"\n@variables u[1:2]\n\nh = Operation[u; u.^2; u.^3; sin.(u); cos.(u); 1]\n\nbasis = Basis(h, u)\nnothing # hide","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"DataDrivenDiffEq comes with some optimizers to tackle sparse regression problems. Here, we will use SR3, used here and introduced here. We choose a threshold of 3.5e-1 and start the optimizer.","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"opt = SR3(3e-1, 1.0)\nΨ = SINDy(X[:, 1:1000], DX[:, 1:1000], basis, opt, maxiter = 10000, normalize = true)\nprint_equations(Ψ) # hide","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"We recovered the equations! Let's transform the SINDyResult into a performant piece of Julia Code using ODESystem","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"sys = ODESystem(Ψ)\np = parameters(Ψ)\n\ndudt = ODEFunction(sys)\n\nestimator = ODEProblem(dudt, u0, tspan, p)\nestimation = solve(estimator, Tsit5(), saveat = solution.t)\n\nplot(solution.t[1:1000], solution[:,1:1000]', color = :red, line = :dot, label = nothing) # hide\nplot!(solution.t[1000:end], solution[:,1000:end]', color = :blue, line = :dot,label = nothing) # hide\nplot!(estimation, color = :green, label = \"Estimation\") # hide\nsavefig(\"SINDy_estimation.png\") # hide","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"sparse_identification/sindy/#Sparse-Identification-of-Nonlinear-Dynamics-1","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"","category":"section"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"Sparse Identification of Nonlinear Dynamics - or SINDy - identifies the equations of motion of a system as the result of a sparse regression over a chosen basis. In particular, it tries to find coefficients Xi such that:","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"Xi = min  leftlVert Y^T - Theta(X p t)^T Xi rightrVert_2 + lambda  leftlVert Xi rightrVert_1","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"where, in most cases, Yis the data matrix containing the derivatives of the state data stored in X. Theta is a matrix containing candidate functions xi over the measurements in X.","category":"page"},{"location":"sparse_identification/sindy/#Example-1","page":"Sparse Identification of Nonlinear Dynamics","title":"Example","text":"","category":"section"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"As in the original paper, we will estimate the Lorenz System. First, let's create the necessary data and have a look at the trajectory.","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing OrdinaryDiffEq\n\nusing LinearAlgebra\nusing Plots\ngr()\n\n# Create a test problem\nfunction lorenz(u,p,t)\n    x, y, z = u\n    ẋ = 10.0*(y - x)\n    ẏ = x*(28.0-z) - y\n    ż = x*y - (8/3)*z\n    return [ẋ, ẏ, ż]\nend\n\nu0 = [-8.0; 7.0; 27.0]\np = [10.0; -10.0; 28.0; -1.0; -1.0; 1.0; -8/3]\ntspan = (0.0,100.0)\ndt = 0.001\nproblem = ODEProblem(lorenz,u0,tspan)\nsolution = solve(problem, Tsit5(), saveat = dt, atol = 1e-7, rtol = 1e-8)\n\nplot(solution,vars=(1,2,3), legend = false) #hide\nsavefig(\"lorenz.png\") #hide","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"(Image: )","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"Additionally, we generate the ideal derivative data.","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"X = Array(solution)\nDX = similar(X)\nfor (i, xi) in enumerate(eachcol(X))\n    DX[:,i] = lorenz(xi, [], 0.0)\nend","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"To generate the symbolic equations, we need to define a Basis over the variables x y z. In this example, we will use all monomials up to degree of 4 and their products:","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"@variables x y z\nu = Operation[x; y; z]\npolys = Operation[]\nfor i ∈ 0:4\n    for j ∈ 0:i\n        for k ∈ 0:j\n            push!(polys, u[1]^i*u[2]^j*u[3]^k)\n            push!(polys, u[2]^i*u[3]^j*u[1]^k)\n            push!(polys, u[3]^i*u[1]^j*u[2]^k)\n        end\n    end\nend\n\nbasis = Basis(polys, u)\nnothing #hide","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"A Basis consists of unique functions, so duplicates will be included just once","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"To perform the sparse identification on our data, we need to define an Optimizer. Here, we will use STRRidge, which is described in the original paper. The threshold of the optimizer is set to 0.1. An overview of the different optimizers can be found below.","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"opt = STRRidge(0.1)\nΨ = SINDy(X, DX, basis, opt, maxiter = 100, normalize = true)","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"Ψ is a SINDyResult, which stores some about the regression. As we can see, we have 7 active terms inside the model. To look at the equations, simply type","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"print_equations(Ψ)","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"First, let's have a look at the L2-Error and Akaikes Information Criterion of the result","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"get_error(Ψ)","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"get_aicc(Ψ)","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"We can also access the coefficient matrix Xi directly via get_coefficients(Ψ).","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"To generate a numerical model usable in DifferentialEquations, we simply use the ODESystem function from ModelingToolkit. The resulting parameters used for the identification can be accessed via parameters(Ψ). The returned vector also includes the parameters of the original Basis used to generate the result.","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"ps = parameters(Ψ)\nsys = ODESystem(Ψ)\ndudt = ODEFunction(sys)\n\nprob = ODEProblem(dudt, u0, tspan, ps)\nsol = solve(prob, Tsit5(), saveat = solution.t, atol = 1e-7, rtol = 1e-8)\n\nϵ = norm.(eachcol(solution .- sol)) # hide\nplot(solution.t, ϵ .+ eps(), yaxis = :log, legend = false) # hide\nxlabel!(\"Time [s]\") # hide\nylabel!(\"L2 Error\") # hide\nsavefig(\"lorenz_error.png\") # hide\nplot(solution, vars = (0, 1), label = \"True\") # hide\nplot!(sol, vars = (0,1), label = \"Estimation\") # hide\nsavefig(\"lorenz_trajectory_estimate.png\") # hide","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"Let's have a look at the trajectory of u_1(t).","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"(Image: )","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"Finally, let's investigate the error of the chaotic equations:","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"(Image: )","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"which resembles the papers results. Next, we could use classical parameter estimation methods or use DiffEqFlux to fine-tune our result (if needed).","category":"page"},{"location":"sparse_identification/sindy/#Functions-1","page":"Sparse Identification of Nonlinear Dynamics","title":"Functions","text":"","category":"section"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"SINDy\nsparse_regression","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"SparseIdentificationResult\nget_sparsity\nget_error\nget_aicc\nget_coefficients","category":"page"},{"location":"#DataDrivenDiffEq.jl-1","page":"Home","title":"DataDrivenDiffEq.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"DataDrivenDiffEq.jl is a package for estimating equation-free and equation-based models for discrete and continuous differential equations.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"As opposed to parameter identification, these methods aim to find the governing equations of motion automatically from a given set of data. They do not require a known model as input. Instead, these methods take in data and return the differential equation model which generated the data.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"There are various avenues in which structural estimation can occur. However, the main branches are: do you want to know the equations in a human-understandable manner, or is it sufficient to have a function that predicts the derivative and generates the correct time series? We will refer to methods which return symbolic forms of the differential equation as structural identification, while those which return functions only for prediction as structural estimation.","category":"page"},{"location":"#Package-Overview-1","page":"Home","title":"Package Overview","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"DataDrivenDiffEq currently implements the following algorithms for structural estimation:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Dynamic Mode Decomposition\nExtended Dynamic Mode Decomposition\nSparse Identification of Nonlinear Dynamics\nImplicit Sparse Identification of Nonlinear Dynamics","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"To use 'DataDrivenDiffEq.jl', simply install it via:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"]add DataDrivenDiffEq\nusing DataDrivenDiffEq","category":"page"}]
}
