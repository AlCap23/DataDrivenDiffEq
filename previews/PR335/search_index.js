var documenterSearchIndex = {"docs":
[{"location":"solvers/symbolic_regression/#symbolic_regression","page":"Symbolic Regression","title":"Symbolic Regression","text":"","category":"section"},{"location":"solvers/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"DataDrivenDiffEq includes the following symbolic regression algorithms.","category":"page"},{"location":"solvers/symbolic_regression/#SymbolicRegression","page":"Symbolic Regression","title":"SymbolicRegression","text":"","category":"section"},{"location":"solvers/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"warning: Warning\nThis feature requires the explicit loading of SymbolicRegression.jl in addition to DataDrivenDiffEq. It will only be useable if loaded like:using DataDrivenDiffEq\nusing SymbolicRegression","category":"page"},{"location":"solvers/symbolic_regression/#Symbolic-Regression","page":"Symbolic Regression","title":"Symbolic Regression","text":"","category":"section"},{"location":"solvers/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"See the tutorial.","category":"page"},{"location":"solvers/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"EQSearch","category":"page"},{"location":"solvers/symbolic_regression/#DataDrivenDiffEq.EQSearch","page":"Symbolic Regression","title":"DataDrivenDiffEq.EQSearch","text":"struct EQSearch <: DataDrivenDiffEq.AbstractSymbolicRegression\n\nOptions for using SymbolicRegression.jl within the solve function. Automatically creates Options with the given specification. Sorts the operators stored in functions into unary and binary operators on conversion.\n\nFields\n\nfunctions\nOperators used for symbolic regression\nkwargs\nAdditionally keyworded arguments passed to SymbolicRegression.Options\n\n\n\n\n\n","category":"type"},{"location":"solvers/symbolic_regression/#OccamNet","page":"Symbolic Regression","title":"OccamNet","text":"","category":"section"},{"location":"solvers/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"See the tutorial.","category":"page"},{"location":"solvers/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"warning: Warning\nThis feature requires the explicit loading of Flux.jl in addition to DataDrivenDiffEq. It will only be useable if loaded like:using DataDrivenDiffEq\nusing Flux","category":"page"},{"location":"solvers/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"OccamNet\nOccamSR\nProbabilityLayer","category":"page"},{"location":"solvers/symbolic_regression/#DataDrivenDiffEq.OccamNet","page":"Symbolic Regression","title":"DataDrivenDiffEq.OccamNet","text":"mutable struct OccamNet{F, C, P} <: DataDrivenDiffEq.AbstractOccam\n\nDefines an OccamNet which learns symbolic expressions from data using a probabilistic approach. See Interpretable Neuroevolutionary Models for Learning Non-Differentiable Functions and Programs  for more details.\n\nIt get constructed via:\n\nnet = OccamNet(inp::Int, outp::Int, layers::Int, f::Vector{Function}, t::Real = 1.0; constants = typeof(t)[], parameters::Int = 0, skip::Bool = false, init_w = ones, init_p = Flux.glorot_uniform)\n\ninp describes the size of the input domain, outp the size of the output domain, layers the number of layers (including the input layer and excluding the linear output layer) and f the functions to be used. Optional is the temperature t which is set to 1.0 at the beginning.\n\nKeyworded arguments are constants, a vector of constants like π, ℯ which can concatenated to the input, the number of trainable parameters and if skip connections should be used. The constructors to the weights and parameters can be passed in via init_w and init_p.\n\nOccamNet is callable with and without a specific route, which can be sampled from the networks weights via rand(net).\n\nFields\n\nc\nThe Chain representing the network\nconstants\nAdditional constants added to the input which are not trainable.\nparameters\nAdditional parameters added to the input which are trainable.\n\n\n\n\n\n","category":"type"},{"location":"solvers/symbolic_regression/#DataDrivenDiffEq.OccamSR","page":"Symbolic Regression","title":"DataDrivenDiffEq.OccamSR","text":"struct OccamSR{F, C, T} <: DataDrivenDiffEq.AbstractSymbolicRegression\n\nOptions for using OccamNet within the solve function. Automatically creates a network with the given specification.\n\nFields\n\nfunctions\nFunctions used within the network\nconstants\nConstants added to the input\nlayers\nNumber of layers\nparameters\nNumber of parameters\nskip\nActivate skip connections\n\n\n\n\n\n","category":"type"},{"location":"solvers/symbolic_regression/#DataDrivenDiffEq.ProbabilityLayer","page":"Symbolic Regression","title":"DataDrivenDiffEq.ProbabilityLayer","text":"mutable struct ProbabilityLayer{F, W, T, A} <: DataDrivenDiffEq.AbstractProbabilityLayer\n\nDefines a basic ProbabilityLayer in which the parameters act as probabilities via the softmax function for an array of functions.\n\nThe layer is callable either via layer(x), using all weights to form the output or by layer(x, route) where route is the result of rand(layer) which samples the function arguments from the underlying distribution.\n\nFields\n\nop\nNonlinear functions forming the basis of the layer\nweight\nWeights\nt\nTemperature controlling the shape of the distribution\narieties\nArities of the functions\nskip\nSkip connection\n\n\n\n\n\n","category":"type"},{"location":"solvers/symbolic_regression/#Related-Functions","page":"Symbolic Regression","title":"Related Functions","text":"","category":"section"},{"location":"solvers/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"set_temp!\nprobability\nlogprobability\nprobabilities\nlogprobabilities","category":"page"},{"location":"solvers/symbolic_regression/#DataDrivenDiffEq.set_temp!","page":"Symbolic Regression","title":"DataDrivenDiffEq.set_temp!","text":"set_temp!(p, t)\n\n\nSet the temperature of the ProbabilityLayer or OccamNet.\n\n\n\n\n\n","category":"function"},{"location":"solvers/symbolic_regression/#DataDrivenDiffEq.probability","page":"Symbolic Regression","title":"DataDrivenDiffEq.probability","text":"probability(o, route)\n\n\nReturns the probability of the result of the OccamNet using the specific route.\n\n\n\n\n\n","category":"function"},{"location":"solvers/symbolic_regression/#DataDrivenDiffEq.logprobability","page":"Symbolic Regression","title":"DataDrivenDiffEq.logprobability","text":"logprobability(o, route)\n\n\nReturns the logprobability of the result of the OccamNet using the specific route.\n\n\n\n\n\n","category":"function"},{"location":"solvers/symbolic_regression/#DataDrivenDiffEq.probabilities","page":"Symbolic Regression","title":"DataDrivenDiffEq.probabilities","text":"probabilities(p)\n\n\nReturn the probability associated with the ProbabilityLayer or OccamNet by applying softmax on the weights.\n\n\n\n\n\n","category":"function"},{"location":"solvers/symbolic_regression/#DataDrivenDiffEq.logprobabilities","page":"Symbolic Regression","title":"DataDrivenDiffEq.logprobabilities","text":"logprobabilities(p)\n\n\nReturn the logprobability associated with the ProbabilityLayer or OccamNet by applying logsoftmax on the weights.\n\n\n\n\n\n","category":"function"},{"location":"examples/cartpole/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"EditURL = \"https://github.com/SciML/DataDrivenDiffEq.jl/blob/master/docs/examples/cartpole.jl\"","category":"page"},{"location":"examples/cartpole/#cartpole","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"","category":"section"},{"location":"examples/cartpole/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"The following is another example on how to use the ImplicitOptimizer that is taken from the original paper. As always, we start by creating a corresponding dataset:","category":"page"},{"location":"examples/cartpole/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing OrdinaryDiffEq\nusing LinearAlgebra\nusing Plots\ngr()\n\n\nfunction cart_pole(u, p, t)\n    du = similar(u)\n    F = -0.2 + 0.5*sin(6*t) # the input\n    du[1] = u[3]\n    du[2] = u[4]\n    du[3] = -(19.62*sin(u[1])+sin(u[1])*cos(u[1])*u[3]^2+F*cos(u[1]))/(2-cos(u[1])^2)\n    du[4] = -(sin(u[1])*u[3]^2 + 9.81*sin(u[1])*cos(u[1])+F)/(2-cos(u[1])^2)\n    return du\nend\n\nu0 = [0.3; 0; 1.0; 0]\ntspan = (0.0, 5.0)\ndt = 0.05\ncart_pole_prob = ODEProblem(cart_pole, u0, tspan)\nsolution = solve(cart_pole_prob, Tsit5(), saveat = dt)\n\nX = solution[:,:]\nDX = similar(X)\nfor (i, xi) in enumerate(eachcol(X))\n    DX[:, i] = cart_pole(xi, [], solution.t[i])\nend\nt = solution.t\n\nddprob = ContinuousDataDrivenProblem(\n    X , t, DX = DX[3:4, :], U = (u,p,t) -> [-0.2 + 0.5*sin(6*t)]\n)\n\nplot(ddprob)","category":"page"},{"location":"examples/cartpole/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"Next, we define a sufficient Basis. Again, we need to include implicits in the definition of our candidate functions and inform the Basis of it.","category":"page"},{"location":"examples/cartpole/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"@parameters t\n@variables u[1:4] du[1:2] x[1:1]\nu, du, x = map(collect, [u, du, x])\npolys = polynomial_basis(u, 2)\npush!(polys, sin.(u[1]))\npush!(polys, cos.(u[1]))\npush!(polys, sin.(u[1])^2)\npush!(polys, cos.(u[1])^2)\npush!(polys, sin.(u[1]).*u[3:4]...)\npush!(polys, sin.(u[1]).*u[3:4].^2...)\npush!(polys, sin.(u[1]).*cos.(u[1])...)\npush!(polys, sin.(u[1]).*cos.(u[1]).*u[3:4]...)\npush!(polys, sin.(u[1]).*cos.(u[1]).*u[3:4].^2...)\nimplicits = [du;  du[1] .* u; du[2] .* u; du .* cos(u[1]);   du .* cos(u[1])^2; polys]\npush!(implicits, x...)\npush!(implicits, x[1]*cos(u[1]))\npush!(implicits, x[1]*sin(u[1]))\n\nbasis= Basis(implicits, u, implicits = du, controls = x,  iv = t);\nprintln(basis) # hide","category":"page"},{"location":"examples/cartpole/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"We solve the problem by varying over a sufficient set of thresholds for the associated optimizer. Additionally we activate the scale_coefficients option for the ImplicitOptimizer, which helps to find sparse equations by normalizing the resulting coefficient matrix after each suboptimization. To evaluate the pareto optimal solution, we use the functions f and g which can be passed as keyword arguments into the solve function. f is a function with different signatures for different optimizers, but returns the L_0 norm of the coefficients and the L_2 error of the current model. g takes this vector and projects it down onto a scalar, using the L_2 norm per default. However, here we want to use the AIC  of the output of f. A noteworthy exception is of course, that we want only results with two or more active coefficents. Hence, we modify g accordingly.","category":"page"},{"location":"examples/cartpole/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"λ = [1e-4;5e-4;1e-3;2e-3;3e-3;4e-3;5e-3;6e-3;7e-3;8e-3;9e-3;1e-2;2e-2;3e-2;4e-2;5e-2;\n6e-2;7e-2;8e-2;9e-2;1e-1;2e-1;3e-1;4e-1;5e-1;6e-1;7e-1;8e-1;9e-1;1;1.5;2;2.5;3;3.5;4;4.5;5;\n6;7;8;9;10;20;30;40;50;100;200];\n\nopt = ImplicitOptimizer(λ)\n\ng(x) = x[1] <= 1 ? Inf : 2*x[1]-2*log(x[2])\n\nres = solve(ddprob, basis, opt, du, maxiter = 1000, g = g, scale_coefficients = true)\nsystem = result(res)\nprintln(system) #hide","category":"page"},{"location":"examples/cartpole/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"We have recovered the correct equations of motion! Another visual check using the problem and the result yields","category":"page"},{"location":"examples/cartpole/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"plot(\n    plot(ddprob), plot(res), layout = (1,2)\n)","category":"page"},{"location":"examples/cartpole/#cartpole_copy_paste","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"examples/cartpole/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing OrdinaryDiffEq\nusing LinearAlgebra\n\n\nfunction cart_pole(u, p, t)\n    du = similar(u)\n    F = -0.2 + 0.5*sin(6*t) # the input\n    du[1] = u[3]\n    du[2] = u[4]\n    du[3] = -(19.62*sin(u[1])+sin(u[1])*cos(u[1])*u[3]^2+F*cos(u[1]))/(2-cos(u[1])^2)\n    du[4] = -(sin(u[1])*u[3]^2 + 9.81*sin(u[1])*cos(u[1])+F)/(2-cos(u[1])^2)\n    return du\nend\n\nu0 = [0.3; 0; 1.0; 0]\ntspan = (0.0, 5.0)\ndt = 0.05\ncart_pole_prob = ODEProblem(cart_pole, u0, tspan)\nsolution = solve(cart_pole_prob, Tsit5(), saveat = dt)\n\nX = solution[:,:]\nDX = similar(X)\nfor (i, xi) in enumerate(eachcol(X))\n    DX[:, i] = cart_pole(xi, [], solution.t[i])\nend\nt = solution.t\n\nddprob = ContinuousDataDrivenProblem(\n    X , t, DX = DX[3:4, :], U = (u,p,t) -> [-0.2 + 0.5*sin(6*t)]\n)\n\n@parameters t\n@variables u[1:4] du[1:2] x[1:1]\nu, du, x = map(collect, [u, du, x])\npolys = polynomial_basis(u, 2)\npush!(polys, sin.(u[1]))\npush!(polys, cos.(u[1]))\npush!(polys, sin.(u[1])^2)\npush!(polys, cos.(u[1])^2)\npush!(polys, sin.(u[1]).*u[3:4]...)\npush!(polys, sin.(u[1]).*u[3:4].^2...)\npush!(polys, sin.(u[1]).*cos.(u[1])...)\npush!(polys, sin.(u[1]).*cos.(u[1]).*u[3:4]...)\npush!(polys, sin.(u[1]).*cos.(u[1]).*u[3:4].^2...)\nimplicits = [du;  du[1] .* u; du[2] .* u; du .* cos(u[1]);   du .* cos(u[1])^2; polys]\npush!(implicits, x...)\npush!(implicits, x[1]*cos(u[1]))\npush!(implicits, x[1]*sin(u[1]))\n\nbasis= Basis(implicits, u, implicits = du, controls = x,  iv = t);\nprintln(basis) # hide\n\nλ = [1e-4;5e-4;1e-3;2e-3;3e-3;4e-3;5e-3;6e-3;7e-3;8e-3;9e-3;1e-2;2e-2;3e-2;4e-2;5e-2;\n6e-2;7e-2;8e-2;9e-2;1e-1;2e-1;3e-1;4e-1;5e-1;6e-1;7e-1;8e-1;9e-1;1;1.5;2;2.5;3;3.5;4;4.5;5;\n6;7;8;9;10;20;30;40;50;100;200];\n\nopt = ImplicitOptimizer(λ)\n\ng(x) = x[1] <= 1 ? Inf : 2*x[1]-2*log(x[2])\n\nres = solve(ddprob, basis, opt, du, maxiter = 1000, g = g, scale_coefficients = true)\nsystem = result(res)\nprintln(system) #hide\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/cartpole/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"","category":"page"},{"location":"examples/cartpole/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"This page was generated using Literate.jl.","category":"page"},{"location":"contributions/#Contributions","page":"Contributing","title":"Contributions","text":"","category":"section"},{"location":"contributions/","page":"Contributing","title":"Contributing","text":"Contributions are welcome! To help, please:","category":"page"},{"location":"contributions/","page":"Contributing","title":"Contributing","text":"Open (or solve) an issue\nReview pull requests\nAdapt code to be more efficient\nWrite new optimizers or algorithms\nWrite tutorials or adapt the docs","category":"page"},{"location":"contributions/","page":"Contributing","title":"Contributing","text":"Feel free to write a private message to @AlCap23 for further discussion.","category":"page"},{"location":"citations/#Citing","page":"Citing","title":"Citing","text":"","category":"section"},{"location":"citations/","page":"Citing","title":"Citing","text":"If you are using DataDrivenDiffEq.jl for research, please cite","category":"page"},{"location":"citations/","page":"Citing","title":"Citing","text":"@software{datadrivendiffeq,\n  author       = {JuliusMartensen and\n                  Christopher Rackauckas and others},\n  title        = {DataDrivenDiffEq.jl},\n  month        = jul,\n  year         = 2021,\n  publisher    = {Zenodo},\n  doi          = {10.5281/zenodo.5083412},\n  url          = {https://doi.org/10.5281/zenodo.5083412}\n}","category":"page"},{"location":"citations/","page":"Citing","title":"Citing","text":"If you are using the SymbolicRegression.jl API, please cite","category":"page"},{"location":"citations/","page":"Citing","title":"Citing","text":"@software{pysr,\n  author       = {Miles Cranmer},\n  title        = {PySR: Fast \\& Parallelized Symbolic Regression in Python/Julia},\n  month        = sep,\n  year         = 2020,\n  publisher    = {Zenodo},\n  doi          = {10.5281/zenodo.4041459},\n  url          = {http://doi.org/10.5281/zenodo.4041459}\n}","category":"page"},{"location":"examples/linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"EditURL = \"https://github.com/SciML/DataDrivenDiffEq.jl/blob/master/docs/examples/linear_continuous_system_controls.jl\"","category":"page"},{"location":"examples/linear_continuous_system_controls/#linear_continuous_controls","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"","category":"section"},{"location":"examples/linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"Now we will extend the previous example by adding some exegeneous control signals. As always, we will generate some data via OrdinaryDiffEq.jl","category":"page"},{"location":"examples/linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing Plots\n\nA = [-0.9 0.2; 0.0 -0.2]\nB = [0.0; 1.0]\nu0 = [10.0; -10.0]\ntspan = (0.0, 10.0)\n\nf(u,p,t) = A*u .+ B .* sin(0.5*t)\n\nsys = ODEProblem(f, u0, tspan)\nsol = solve(sys, Tsit5(), saveat = 0.05);\nnothing #hide","category":"page"},{"location":"examples/linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"We will use the data provided by our problem, but add the control signal U = sin(0.5*t) to it.","category":"page"},{"location":"examples/linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"X = Array(sol)\nt = sol.t\ncontrol(u,p,t) = [sin(0.5*t)]\nprob = ContinuousDataDrivenProblem(X, t, U = control)","category":"page"},{"location":"examples/linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"And plot the problems data.","category":"page"},{"location":"examples/linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"plot(prob)","category":"page"},{"location":"examples/linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"Again, we will use gDMD to estimate the systems dynamics. Since we have a control signal defined in the problem, the algorithm will detect it automatically and use gDMDc:","category":"page"},{"location":"examples/linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"res = solve(prob, DMDSVD(), digits = 1)\nprintln(res)","category":"page"},{"location":"examples/linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"We see that the system has been recovered correctly, indicated by the small error and high AIC score of the result. We can confirm this by looking at the resulting Basis","category":"page"},{"location":"examples/linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"system = result(res)\nprintln(system)","category":"page"},{"location":"examples/linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"And also plot the prediction of the recovered dynamics","category":"page"},{"location":"examples/linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"plot(res)","category":"page"},{"location":"examples/linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"Again, we can have a look at the generator of the system, which is independent from the inputs.","category":"page"},{"location":"examples/linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"generator(system)","category":"page"},{"location":"examples/linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"Sticking to the same procedure as earlier, we now use a linear sparse regression to solve the problem","category":"page"},{"location":"examples/linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"@parameters t\n@variables x[1:2](t) u[1:1](t)\n\nbasis = Basis([x; u], x, controls = u, independent_variable = t, name = :LinearBasis)\nprint(basis) #hide","category":"page"},{"location":"examples/linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"Note that we added a new variable u[1](t) as a control to both the equations and the basis constructor. Afterwards, we simply solve the already defined problem with our Basis and a SparseOptimizer","category":"page"},{"location":"examples/linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"sparse_res = solve(prob, basis, STLSQ(1e-1))\nprintln(sparse_res)","category":"page"},{"location":"examples/linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"Which holds the same equations","category":"page"},{"location":"examples/linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"sparse_system = result(sparse_res)\nprintln(sparse_system)","category":"page"},{"location":"examples/linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"Again, we can have a look at the result","category":"page"},{"location":"examples/linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"plot(\n    plot(prob), plot(sparse_res), layout = (1,2)\n)","category":"page"},{"location":"examples/linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"Both results can be converted into an ODESystem. To include the control signal, we simply substitute the control variables in the corresponding equations.","category":"page"},{"location":"examples/linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"subs_control = (u[1] => sin(0.5*t))\n\neqs = map(equations(sparse_system)) do eq\n    eq.lhs ~ substitute(eq.rhs, subs_control)\nend\n\n@named sys = ODESystem(\n    eqs,\n    get_iv(sparse_system),\n    states(sparse_system),\n    parameters(sparse_system)\n    );\nnothing #hide","category":"page"},{"location":"examples/linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"And simulated using OrdinaryDiffEq.jl using the (known) initial conditions and the parameter mapping of the estimation.","category":"page"},{"location":"examples/linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"x0 = [x[1] => u0[1], x[2] => u0[2]]\nps = parameter_map(sparse_res)\n\node_prob = ODEProblem(sys, x0, tspan, ps)\nestimate = solve(ode_prob, Tsit5(), saveat = prob.t);\nnothing #hide","category":"page"},{"location":"examples/linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"And look at the result","category":"page"},{"location":"examples/linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"plot(sol, color = :black)\nplot!(estimate, color = :red, linestyle = :dash)","category":"page"},{"location":"examples/linear_continuous_system_controls/#linear_continuous_copy_paste","page":"Linear Time Continuous System with Controls","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"examples/linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing LinearAlgebra\nusing OrdinaryDiffEq\n\nA = [-0.9 0.2; 0.0 -0.2]\nB = [0.0; 1.0]\nu0 = [10.0; -10.0]\ntspan = (0.0, 10.0)\n\nf(u,p,t) = A*u .+ B .* sin(0.5*t)\n\nsys = ODEProblem(f, u0, tspan)\nsol = solve(sys, Tsit5(), saveat = 0.05);\n\nX = Array(sol)\nt = sol.t\ncontrol(u,p,t) = [sin(0.5*t)]\nprob = ContinuousDataDrivenProblem(X, t, U = control)\n\nres = solve(prob, DMDSVD(), digits = 1)\n\nsystem = result(res)\n\ngenerator(system)\n\n@parameters t\n@variables x[1:2](t) u[1:1](t)\n\nbasis = Basis([x; u], x, controls = u, independent_variable = t, name = :LinearBasis)\n\nsparse_res = solve(prob, basis, STLSQ(1e-1))\n\nsparse_system = result(sparse_res)\n\nsubs_control = (u[1] => sin(0.5*t))\n\neqs = map(equations(sparse_system)) do eq\n    eq.lhs ~ substitute(eq.rhs, subs_control)\nend\n\n@named sys = ODESystem(\n    eqs,\n    get_iv(sparse_system),\n    states(sparse_system),\n    parameters(sparse_system)\n    );\n\nx0 = [x[1] => u0[1], x[2] => u0[2]]\nps = parameter_map(sparse_res)\n\node_prob = ODEProblem(sys, x0, tspan, ps)\nestimate = solve(ode_prob, Tsit5(), saveat = prob.t);\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"","category":"page"},{"location":"examples/linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"This page was generated using Literate.jl.","category":"page"},{"location":"solutions/#Solutions","page":"Solutions","title":"Solutions","text":"","category":"section"},{"location":"solutions/","page":"Solutions","title":"Solutions","text":"DataDrivenSolution","category":"page"},{"location":"solutions/#DataDrivenDiffEq.DataDrivenSolution","page":"Solutions","title":"DataDrivenDiffEq.DataDrivenSolution","text":"struct DataDrivenSolution{L, A, O} <: DataDrivenDiffEq.AbstractDataDrivenSolution\n\nThe solution to a DataDrivenProblem derived via a certain algorithm. The solution is represented via an AbstractBasis, which makes it callable.\n\nFields\n\nbasis\nThe basis representation of the solution\nparameters\nParameters of the solution\nretcode\nReturncode\nalg\nAlgorithm\nout\nOriginal output of the solution algorithm\nprob\nProblem\nl2_error\nL₂ norm error\naic\nAIC\nrsquared\nCoefficient of determinantion\n\nNote\n\nThe L₂ norm error, AIC and coefficient of determinantion get only computed, if eval_expression is set to true or if the solution can be interpreted as a linear regression result.\n\n\n\n\n\n","category":"type"},{"location":"solutions/#Functions","page":"Solutions","title":"Functions","text":"","category":"section"},{"location":"solutions/","page":"Solutions","title":"Solutions","text":"result\nget_problem\nmetrics\nparameters\nparameter_map\naic\nerror\ndetermination\nalgorithm\noutput","category":"page"},{"location":"solutions/#DataDrivenDiffEq.result","page":"Solutions","title":"DataDrivenDiffEq.result","text":"result(r)\n\n\nReturns the Basis of the result.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#DataDrivenDiffEq.get_problem","page":"Solutions","title":"DataDrivenDiffEq.get_problem","text":"get_problem(r)\n\n\nReturns the original DataDrivenProblem.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#DataDrivenDiffEq.metrics","page":"Solutions","title":"DataDrivenDiffEq.metrics","text":"metrics(r)\n\n\nReturns all applicable metrics of the solution.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#ModelingToolkit.parameters","page":"Solutions","title":"ModelingToolkit.parameters","text":"parameters(r)\n\n\nReturns the estimated parameters in form of an Vector.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#DataDrivenDiffEq.parameter_map","page":"Solutions","title":"DataDrivenDiffEq.parameter_map","text":"parameter_map(r)\n\n\nGenerate a mapping of the parameter values and symbolic representation useable to solve and ODESystem.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#DataDrivenDiffEq.aic","page":"Solutions","title":"DataDrivenDiffEq.aic","text":"aic(r)\n\n\nReturns the AIC of the result.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#DataDrivenDiffEq.determination","page":"Solutions","title":"DataDrivenDiffEq.determination","text":"determination(r)\n\n\nReturns the coefficient of determinantion of the result, if the result has been derived via a linear regression, e.g. sparse regression or koopman.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#DataDrivenDiffEq.algorithm","page":"Solutions","title":"DataDrivenDiffEq.algorithm","text":"algorithm(r)\n\n\nReturns the algorithm used to derive the solution.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#DataDrivenDiffEq.output","page":"Solutions","title":"DataDrivenDiffEq.output","text":"output(r)\n\n\nReturns the original output of the algorithm.\n\n\n\n\n\n","category":"function"},{"location":"examples/linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"EditURL = \"https://github.com/SciML/DataDrivenDiffEq.jl/blob/master/docs/examples/linear_discrete_system.jl\"","category":"page"},{"location":"examples/linear_discrete_system/#linear_discrete","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"","category":"section"},{"location":"examples/linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"We will start by estimating the underlying dynamical system of a time discrete process based on some measurements via Dynamic Mode Decomposition on a simple linear system of the form u(k+1) = A u(k).","category":"page"},{"location":"examples/linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"At first, we simulate the correspoding system using OrdinaryDiffEq.jl and generate a DiscreteDataDrivenProblem from the simulated data.","category":"page"},{"location":"examples/linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing Plots\n\nA = [0.9 -0.2; 0.0 0.2]\nu0 = [10.0; -10.0]\ntspan = (0.0, 11.0)\n\nf(u,p,t) = A*u\n\nsys = DiscreteProblem(f, u0, tspan)\nsol = solve(sys, FunctionMap());\nnothing #hide","category":"page"},{"location":"examples/linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"Next we transform our simulated solution into a DataDrivenProblem. Given that the solution knows its a discrete solution, we can simply write","category":"page"},{"location":"examples/linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"prob = DataDrivenProblem(sol)","category":"page"},{"location":"examples/linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"And plot the solution and the problem","category":"page"},{"location":"examples/linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"plot(sol, label = string.([:x₁ :x₂]))\nscatter!(prob)","category":"page"},{"location":"examples/linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"To estimate the underlying operator in the states x_1 x_2, we solve the estimation problem using the DMDSVD algorithm for approximating the operator. First, we will have a look at the DataDrivenSolution","category":"page"},{"location":"examples/linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"res = solve(prob, DMDSVD(), digits = 1)\nprintln(res) # hide","category":"page"},{"location":"examples/linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"We see that the system has been recovered correctly, indicated by the small error and high AIC score of the result. We can confirm this by looking at the resulting Basis","category":"page"},{"location":"examples/linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"system = result(res)\nusing Symbolics\n\nprintln(system) # hide","category":"page"},{"location":"examples/linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"And also plot the prediction of the recovered dynamics","category":"page"},{"location":"examples/linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"plot(res)","category":"page"},{"location":"examples/linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"Or a have a look at the metrics of the result","category":"page"},{"location":"examples/linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"metrics(res)","category":"page"},{"location":"examples/linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"To have a look at the representation of the operator as a Matrix, we can simply call","category":"page"},{"location":"examples/linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"Matrix(system)","category":"page"},{"location":"examples/linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"to see that the operator is indeed our initial A. Since we have a linear representation, we can gain further insights into the stability of the dynamics via its eigenvalues","category":"page"},{"location":"examples/linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"eigvals(system)","category":"page"},{"location":"examples/linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"And plot the stability margin of the discrete System","category":"page"},{"location":"examples/linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"φ = 0:0.01π:2π\nplot(sin.(φ), cos.(φ), xlabel = \"Real\", ylabel = \"Im\", label = \"Stability margin\", color = :red, linestyle = :dash)\nscatter!(real(eigvals(system)), imag(eigvals(system)), label = \"Eigenvalues\", color = :black, marker = :cross)","category":"page"},{"location":"examples/linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"Similarly, we could use a sparse regression to derive our system from our data. We start by defining a Basis","category":"page"},{"location":"examples/linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"using ModelingToolkit\n\n@parameters t\n@variables x[1:2](t)\n\nbasis = Basis(x, x, independent_variable = t, name = :LinearBasis)\nprint(basis) #hide","category":"page"},{"location":"examples/linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"Afterwards, we simply solve the already defined problem with our Basis and a SparseOptimizer","category":"page"},{"location":"examples/linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"sparse_res = solve(prob, basis, STLSQ())\nprintln(sparse_res) #hide","category":"page"},{"location":"examples/linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"Which holds the same equations","category":"page"},{"location":"examples/linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"sparse_system = result(sparse_res)\nprintln(sparse_system) #hide","category":"page"},{"location":"examples/linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"Again, we can have a look at the result","category":"page"},{"location":"examples/linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"plot(\n    plot(prob), plot(sparse_res), layout = (1,2)\n)","category":"page"},{"location":"examples/linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"Both results can be converted into a DiscreteProblem","category":"page"},{"location":"examples/linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"@named sys = DiscreteSystem(equations(sparse_system), get_iv(sparse_system),states(sparse_system), parameters(sparse_system))\nprintln(sys) #hide","category":"page"},{"location":"examples/linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"And simulated using OrdinaryDiffEq.jl using the (known) initial conditions and the parameter mapping of the estimation.","category":"page"},{"location":"examples/linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"x0 = [x[1] => u0[1], x[2] => u0[2]]\nps = parameter_map(sparse_res)\n\ndiscrete_prob = DiscreteProblem(sys, x0, tspan, ps)\nestimate = solve(discrete_prob, FunctionMap());\nnothing #hide","category":"page"},{"location":"examples/linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"And look at the result","category":"page"},{"location":"examples/linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"plot(sol, color = :black)\nplot!(estimate, color = :red, linestyle = :dash)","category":"page"},{"location":"examples/linear_discrete_system/#linear_discrete_copy_paste","page":"Linear Time Discrete System","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"examples/linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing LinearAlgebra\nusing OrdinaryDiffEq\n\nA = [0.9 -0.2; 0.0 0.2]\nu0 = [10.0; -10.0]\ntspan = (0.0, 11.0)\n\nf(u,p,t) = A*u\n\nsys = DiscreteProblem(f, u0, tspan)\nsol = solve(sys, FunctionMap());\n\nprob = DataDrivenProblem(sol)\n\nres = solve(prob, DMDSVD(), digits = 1)\n\nsystem = result(res)\nusing Symbolics\n\nusing ModelingToolkit\n\n@parameters t\n@variables x[1:2](t)\n\nbasis = Basis(x, x, independent_variable = t, name = :LinearBasis)\n\nsparse_res = solve(prob, basis, STLSQ())\n\nsparse_system = result(sparse_res)\n\n@named sys = DiscreteSystem(equations(sparse_system), get_iv(sparse_system),states(sparse_system), parameters(sparse_system))\n\nx0 = [x[1] => u0[1], x[2] => u0[2]]\nps = parameter_map(sparse_res)\n\ndiscrete_prob = DiscreteProblem(sys, x0, tspan, ps)\nestimate = solve(discrete_prob, FunctionMap());\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"","category":"page"},{"location":"examples/linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"EditURL = \"https://github.com/SciML/DataDrivenDiffEq.jl/blob/master/docs/examples/nonlinear_continuous_system.jl\"","category":"page"},{"location":"examples/nonlinear_continuous_system/#nonlinear_continuos","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"","category":"section"},{"location":"examples/nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"Similarly, we can use the Extended Dynamic Mode Decomposition via a nonlinear Basis of observables. Here, we will look at a rather famous example with a finite dimensional solution.","category":"page"},{"location":"examples/nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing ModelingToolkit\nusing OrdinaryDiffEq\nusing Plots\n\nfunction slow_manifold(du, u, p, t)\n    du[1] = p[1] * u[1]\n    du[2] = p[2] * (u[2] - u[1]^2)\nend\n\nu0 = [3.0; -2.0]\ntspan = (0.0, 5.0)\np = [-0.8; -0.7]\n\nproblem = ODEProblem(slow_manifold, u0, tspan, p)\nsolution = solve(problem, Tsit5(), saveat = 0.01)\nplot(solution)","category":"page"},{"location":"examples/nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"Since we are dealing with a continuous system in time, we define the associated DataDrivenProblem accordingly using the measured states X, their derivatives DX and the time t.","category":"page"},{"location":"examples/nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"prob = ContinuousDataDrivenProblem(solution)","category":"page"},{"location":"examples/nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"Additionally, we need to define the Basis for our lifting, before we solve the problem in the lifted space.","category":"page"},{"location":"examples/nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"@parameters t\n@variables u[1:2](t)\nΨ = Basis([u; u[1]^2], u, independent_variable = t)\nres = solve(prob, Ψ, DMDPINV(), digits = 1)\nsystem = result(res)\nprintln(res) # hide\nprintln(system) # hide\nprintln(parameters(res)) # hide","category":"page"},{"location":"examples/nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"The underlying dynamics have been recovered correctly by the algorithm! Similarly we could use sparse identification to solve the problem","category":"page"},{"location":"examples/nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"sparse_res = solve(prob, Ψ, STLSQ(), digits = 1)\nprintln(sparse_res)","category":"page"},{"location":"examples/nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"And the resulting system","category":"page"},{"location":"examples/nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"sparse_system = result(sparse_res)\nprintln(sparse_system)","category":"page"},{"location":"examples/nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"We can also directly look at the parameters of each result","category":"page"},{"location":"examples/nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"parameter_map(res)","category":"page"},{"location":"examples/nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"Note that we are using parameter_map instead of just parameters, which returns a vector suitable to use with ModelingToolkit.","category":"page"},{"location":"examples/nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"parameter_map(sparse_res)","category":"page"},{"location":"examples/nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"To simulate the system, we create an ODESystem from the result","category":"page"},{"location":"examples/nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"Both results can be converted into an ODESystem","category":"page"},{"location":"examples/nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"@named sys = ODESystem(\n    equations(sparse_system),\n    get_iv(sparse_system),\n    states(sparse_system),\n    parameters(sparse_system)\n    );\n\n\nx0 = [u[1] => u0[1], u[2] => u0[2]]\nps = parameter_map(sparse_res)","category":"page"},{"location":"examples/nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"And simulated using OrdinaryDiffEq.jl using the (known) initial conditions and the parameter mapping of the estimation.","category":"page"},{"location":"examples/nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"ode_prob = ODEProblem(sys, x0, tspan, ps)\nestimate = solve(ode_prob, Tsit5(), saveat = prob.t);\nnothing #hide","category":"page"},{"location":"examples/nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"And look at the result","category":"page"},{"location":"examples/nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"plot(solution, color = :black)\nplot!(estimate, color = :red, linestyle = :dash)","category":"page"},{"location":"examples/nonlinear_continuous_system/#linear_discrete_copy_paste","page":"Nonlinear Time Continuous System","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"examples/nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing ModelingToolkit\nusing OrdinaryDiffEq\n\nfunction slow_manifold(du, u, p, t)\n    du[1] = p[1] * u[1]\n    du[2] = p[2] * (u[2] - u[1]^2)\nend\n\nu0 = [3.0; -2.0]\ntspan = (0.0, 5.0)\np = [-0.8; -0.7]\n\nproblem = ODEProblem(slow_manifold, u0, tspan, p)\nsolution = solve(problem, Tsit5(), saveat = 0.01)\n\nprob = ContinuousDataDrivenProblem(solution)\n\n@parameters t\n@variables u[1:2](t)\nΨ = Basis([u; u[1]^2], u, independent_variable = t)\nres = solve(prob, Ψ, DMDPINV(), digits = 1)\nsystem = result(res)\n\nsparse_res = solve(prob, Ψ, STLSQ(), digits = 1)\nprintln(sparse_res)\n\nsparse_system = result(sparse_res)\nprintln(sparse_system)\n\nparameter_map(res)\n\nparameter_map(sparse_res)\n\n@named sys = ODESystem(\n    equations(sparse_system),\n    get_iv(sparse_system),\n    states(sparse_system),\n    parameters(sparse_system)\n    );\n\n\nx0 = [u[1] => u0[1], u[2] => u0[2]]\nps = parameter_map(sparse_res)\n\node_prob = ODEProblem(sys, x0, tspan, ps)\nestimate = solve(ode_prob, Tsit5(), saveat = prob.t);\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"","category":"page"},{"location":"examples/nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"EditURL = \"https://github.com/SciML/DataDrivenDiffEq.jl/blob/master/docs/examples/symbolic_regression.jl\"","category":"page"},{"location":"examples/symbolic_regression/#symbolic_regression_simple","page":"Symbolic Regression","title":"Symbolic Regression","text":"","category":"section"},{"location":"examples/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"#note # Symbolic regression is using  regularized evolution, simulated annealing, and gradient-free optimization to find suitable equations. Hence, the performance might differ and depends strongly on the hyperparameters of the optimization. This example might not recover the groundtruth, but is showing off the use within `DataDrivenDiffEq.jl`.","category":"page"},{"location":"examples/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"DataDrivenDiffEq offers an interface to SymbolicRegression.jl to infer more complex functions. To use it, simply load a sufficient version of SymbolicRegression (currently we supported version 0.6.14 to 0.6.19).","category":"page"},{"location":"examples/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing SymbolicRegression\nusing Plots\n\nA = [-0.9 0.2; 0.0 -0.5]\nB = [0.0; 1.0]\nu0 = [10.0; -10.0]\ntspan = (0.0, 20.0)\n\nf(u,p,t) = A*u .+ B .* sin(0.5*t)\n\nsys = ODEProblem(f, u0, tspan)\nsol = solve(sys, Tsit5(), saveat = 0.01);\nnothing #hide","category":"page"},{"location":"examples/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"We will use the data provided by our problem, but add the control signal U = sin(0.5*t) to it. Instead of using a function, like in another example","category":"page"},{"location":"examples/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"X = Array(sol)\nt = sol.t\nU = permutedims(sin.(0.5*t))\nprob = ContinuousDataDrivenProblem(X, t, U = U)","category":"page"},{"location":"examples/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"And plot the problems data.","category":"page"},{"location":"examples/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"plot(prob)","category":"page"},{"location":"examples/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"To solve our problem, we will use EQSearch, which provides a wrapper for the symbolic regression interface. By default, it takes in a Vector of Functions and additional keyworded arguments. We will stick to simple operations like subtraction and multiplication, use a L1DistLoss , limit the maximum size and punish complex equations while fitting our equations on minibatches.","category":"page"},{"location":"examples/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"alg = EQSearch([-, *], loss = L1DistLoss(), verbosity = 0, maxsize = 9, batching = true, batchSize = 50, parsimony = 0.01f0)","category":"page"},{"location":"examples/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"Again, we solve the problem to obtain a DataDrivenResult. Note that any additional keyworded arguments are passed onto symbolic regressions EquationSearch with the exception of niterations which is max_iter","category":"page"},{"location":"examples/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"res = solve(prob, alg, max_iter = 300, numprocs = 0, multithreading = false)\nprintln(res)","category":"page"},{"location":"examples/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"We see that the system has been recovered correctly, indicated by the small error. A closer look at the equations r","category":"page"},{"location":"examples/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"system = result(res)\n\nprintln(system)","category":"page"},{"location":"examples/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"Shows that while not obvious, the representation And also plot the prediction of the recovered dynamics","category":"page"},{"location":"examples/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"plot(res)","category":"page"},{"location":"examples/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"To convert the result into an ODESystem, we substitute the control signal","category":"page"},{"location":"examples/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"u = controls(system)\nt = get_iv(system)\n\nsubs_control = (u[1] => sin(0.5*t))\n\neqs = map(equations(system)) do eq\n    eq.lhs ~ substitute(eq.rhs, subs_control)\nend\n\n@named sys = ODESystem(\n    eqs,\n    get_iv(system),\n    states(system),\n    []\n    );\nnothing #hide","category":"page"},{"location":"examples/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"And simulated using OrdinaryDiffEq.jl using the (known) initial conditions and the parameter mapping of the estimation. Since the parameters are hard numerical values we do not need to include those.","category":"page"},{"location":"examples/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"x = states(system)\nx0 = [x[1] => u0[1], x[2] => u0[2]]\n\node_prob = ODEProblem(sys, x0, tspan)\nestimate = solve(ode_prob, Tsit5(), saveat = prob.t);\nnothing #hide","category":"page"},{"location":"examples/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"And look at the result","category":"page"},{"location":"examples/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"plot(sol, color = :black)\nplot!(estimate, color = :red, linestyle = :dash)","category":"page"},{"location":"examples/symbolic_regression/#symbolic_regression_simple_copy_paste","page":"Symbolic Regression","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"examples/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"#note # Symbolic regression is using  regularized evolution, simulated annealing, and gradient-free optimization to find suitable equations. Hence, the performance might differ and depends strongly on the hyperparameters of the optimization. This example might not recover the groundtruth, but is showing off the use within `DataDrivenDiffEq.jl`.\n\nusing DataDrivenDiffEq\nusing ModelingToolkit\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing SymbolicRegression\n\nA = [-0.9 0.2; 0.0 -0.5]\nB = [0.0; 1.0]\nu0 = [10.0; -10.0]\ntspan = (0.0, 20.0)\n\nf(u,p,t) = A*u .+ B .* sin(0.5*t)\n\nsys = ODEProblem(f, u0, tspan)\nsol = solve(sys, Tsit5(), saveat = 0.01);\n\nX = Array(sol)\nt = sol.t\nU = permutedims(sin.(0.5*t))\nprob = ContinuousDataDrivenProblem(X, t, U = U)\n\nalg = EQSearch([-, *], loss = L1DistLoss(), verbosity = 0, maxsize = 9, batching = true, batchSize = 50, parsimony = 0.01f0)\n\nres = solve(prob, alg, max_iter = 300, numprocs = 0, multithreading = false)\n\nsystem = result(res)\nprintln(system)\n\nu = controls(system)\nt = get_iv(system)\n\nsubs_control = (u[1] => sin(0.5*t))\n\neqs = map(equations(system)) do eq\n    eq.lhs ~ substitute(eq.rhs, subs_control)\nend\n\n@named sys = ODESystem(\n    eqs,\n    get_iv(system),\n    states(system),\n    []\n    );\n\nx = states(system)\nx0 = [x[1] => u0[1], x[2] => u0[2]]\n\node_prob = ODEProblem(sys, x0, tspan)\nestimate = solve(ode_prob, Tsit5(), saveat = prob.t);\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"","category":"page"},{"location":"examples/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"This page was generated using Literate.jl.","category":"page"},{"location":"basis/#Basis","page":"Basis","title":"Basis","text":"","category":"section"},{"location":"basis/","page":"Basis","title":"Basis","text":"Basis","category":"page"},{"location":"basis/#DataDrivenDiffEq.Basis","page":"Basis","title":"DataDrivenDiffEq.Basis","text":"mutable struct Basis <: DataDrivenDiffEq.AbstractBasis\n\nA basis over the states with parameters, independent variable, and possible exogenous controls. It extends an AbstractSystem as defined in ModelingToolkit.jl. f can either be a Julia function which is able to use ModelingToolkit variables or a vector of eqs. It can be called with the typical SciML signature, meaning out of place with f(u,p,t) or in place with f(du, u, p, t). If control inputs are present, it is assumed that no control corresponds to zero for all inputs. The corresponding function calls are f(u,p,t,inputs) and f(du,u,p,t,inputs) and need to be specified fully. \n\nThe optional implicits declare implicit variables in the Basis, meaning variables representing the (measured) target of the system. Right now only supported with the use of ImplicitOptimizers.\n\nIf linear_independent is set to true, a linear independent basis is created from all atom functions in f.\n\nIf simplify_eqs is set to true, simplify is called on f.\n\nAdditional keyworded arguments include name, which can be used to name the basis, and observed for defining observables.\n\nFields\n\neqs\nThe equations of the basis\nstates\nDependent (state) variables\nctrls\nControl variables\nps\nParameters\nobserved\nObserved\niv\nIndependent variable\nimplicit\nImplicit variables of the basis\nf\nInternal function representation of the basis\nname\nName of the basis\nsystems\nInternal systems\n\nExample\n\nusing ModelingToolkit\nusing DataDrivenDiffEq\n\n@parameters w[1:2] t\n@variables u[1:2](t)\n\nΨ = Basis([u; sin.(w.*u)], u, parameters = p, iv = t)\n\nNote\n\nThe keyword argument eval_expression controls the function creation behavior. eval_expression=true means that eval is used, so normal world-age behavior applies (i.e. the functions cannot be called from the function that generates them). If eval_expression=false, then construction via GeneralizedGenerated.jl is utilized to allow for same world-age evaluation. However, this can cause Julia to segfault on sufficiently large basis functions. By default eval_expression=false.\n\n\n\n\n\n","category":"type"},{"location":"basis/#Generators","page":"Basis","title":"Generators","text":"","category":"section"},{"location":"basis/","page":"Basis","title":"Basis","text":"monomial_basis\npolynomial_basis\nsin_basis\ncos_basis\nfourier_basis\nchebyshev_basis","category":"page"},{"location":"basis/#DataDrivenDiffEq.monomial_basis","page":"Basis","title":"DataDrivenDiffEq.monomial_basis","text":"monomial_basis(x)\nmonomial_basis(x, degree)\n\n\nConstructs an array containing monomial basis in the variables x up to degree c of the form [x₁, x₁^2, ... , x₁^c, x₂, x₂^2, ...].\n\n\n\n\n\n","category":"function"},{"location":"basis/#DataDrivenDiffEq.polynomial_basis","page":"Basis","title":"DataDrivenDiffEq.polynomial_basis","text":"polynomial_basis(x)\npolynomial_basis(x, degree)\n\n\nConstructs an array containing a polynomial basis in the variables x up to degree c of the form [x₁, x₂, x₃, ..., x₁^1 * x₂^(c-1)]. Mixed terms are included.\n\n\n\n\n\n","category":"function"},{"location":"basis/#DataDrivenDiffEq.sin_basis","page":"Basis","title":"DataDrivenDiffEq.sin_basis","text":"sin_basis(x, coefficients)\n\n\nConstructs an array containing a Sine basis in the variables x with coefficients c. If c is an Int returns all coefficients from 1 to c.\n\n\n\n\n\n","category":"function"},{"location":"basis/#DataDrivenDiffEq.cos_basis","page":"Basis","title":"DataDrivenDiffEq.cos_basis","text":"cos_basis(x, coefficients)\n\n\nConstructs an array containing a Cosine basis in the variables x with coefficients c. If c is an Int returns all coefficients from 1 to c.\n\n\n\n\n\n","category":"function"},{"location":"basis/#DataDrivenDiffEq.fourier_basis","page":"Basis","title":"DataDrivenDiffEq.fourier_basis","text":"fourier_basis(x, coefficients)\n\n\nConstructs an array containing a Fourier basis in the variables x with (integer) coefficients c. If c is an Int returns all coefficients from 1 to c.\n\n\n\n\n\n","category":"function"},{"location":"basis/#DataDrivenDiffEq.chebyshev_basis","page":"Basis","title":"DataDrivenDiffEq.chebyshev_basis","text":"chebyshev_basis(x, coefficients)\n\n\nConstructs an array containing a Chebyshev basis in the variables x with coefficients c. If c is an Int returns all coefficients from 1 to c.\n\n\n\n\n\n","category":"function"},{"location":"sindy_dmd/#Unifying-SINDy-and-DMD","page":"Unifying SINDy and DMD","title":"Unifying SINDy and DMD","text":"","category":"section"},{"location":"sindy_dmd/","page":"Unifying SINDy and DMD","title":"Unifying SINDy and DMD","text":"The SINDy and DMD algorithms have been combined under a single interface to match the interface of other SciML packages. Thus, you can simply define a Problem, and then seamlessly switch between solvers.","category":"page"},{"location":"sindy_dmd/","page":"Unifying SINDy and DMD","title":"Unifying SINDy and DMD","text":"See the individual descriptions below for how to call the traditional SINDy and DMD solvers within the unified interface.","category":"page"},{"location":"sindy_dmd/#DMD","page":"Unifying SINDy and DMD","title":"DMD","text":"","category":"section"},{"location":"sindy_dmd/","page":"Unifying SINDy and DMD","title":"Unifying SINDy and DMD","text":"For dynamic mode decomposition, use DMDSVD() without a basis:","category":"page"},{"location":"sindy_dmd/","page":"Unifying SINDy and DMD","title":"Unifying SINDy and DMD","text":"res = solve(problem, DMDSVD(), kwargs...)","category":"page"},{"location":"sindy_dmd/#Extended-DMD","page":"Unifying SINDy and DMD","title":"Extended DMD","text":"","category":"section"},{"location":"sindy_dmd/","page":"Unifying SINDy and DMD","title":"Unifying SINDy and DMD","text":"For extended dynamic mode decomposition, use  DMDSVD() with a basis:","category":"page"},{"location":"sindy_dmd/","page":"Unifying SINDy and DMD","title":"Unifying SINDy and DMD","text":"res = solve(problem, basis, DMDSVD(), kwargs...)","category":"page"},{"location":"sindy_dmd/#DMD-Optional-Arguments","page":"Unifying SINDy and DMD","title":"DMD Optional Arguments","text":"","category":"section"},{"location":"sindy_dmd/","page":"Unifying SINDy and DMD","title":"Unifying SINDy and DMD","text":"If control signals are present, they get processed according to this paper for dynamic mode decomposition and as described here for extended dynamic mode decomposition, assuming a linear relationship on the operator.","category":"page"},{"location":"sindy_dmd/","page":"Unifying SINDy and DMD","title":"Unifying SINDy and DMD","text":"Possible keyword arguments include:","category":"page"},{"location":"sindy_dmd/","page":"Unifying SINDy and DMD","title":"Unifying SINDy and DMD","text":"B a linear mapping known a priori which maps the control signals onto the lifted states.\ndigits controls the digits / rounding used for deriving the system equations (digits = 1 would round 10.02 to 10.0).\noperator_only returns a NamedTuple containing the operator, input and output mapping, and matrices used for updating the operator, as described here.","category":"page"},{"location":"sindy_dmd/","page":"Unifying SINDy and DMD","title":"Unifying SINDy and DMD","text":"info: Info\nIf eval_expression is set to true, the returning result of the Koopman based inference will not contain a parameterized equation, but rather use the numeric values of the operator/generator.","category":"page"},{"location":"sindy_dmd/#SINDy","page":"Unifying SINDy and DMD","title":"SINDy","text":"","category":"section"},{"location":"sindy_dmd/","page":"Unifying SINDy and DMD","title":"Unifying SINDy and DMD","text":"For Sparse Identification of Nonlinear Dynamics, use STLQS():","category":"page"},{"location":"sindy_dmd/","page":"Unifying SINDy and DMD","title":"Unifying SINDy and DMD","text":"res = solve(problem, basis, STLQS(), kwargs...)","category":"page"},{"location":"sindy_dmd/#Implicit-SINDy","page":"Unifying SINDy and DMD","title":"Implicit SINDy","text":"","category":"section"},{"location":"sindy_dmd/","page":"Unifying SINDy and DMD","title":"Unifying SINDy and DMD","text":"For Sparse Identification of Nonlinear Dynamics, use ImplicitOptimizer():","category":"page"},{"location":"sindy_dmd/","page":"Unifying SINDy and DMD","title":"Unifying SINDy and DMD","text":"res = solve(problem, basis, ImplicitOptimizer(), kwargs...)","category":"page"},{"location":"sindy_dmd/","page":"Unifying SINDy and DMD","title":"Unifying SINDy and DMD","text":"Where control signals are included in the candidate basis.","category":"page"},{"location":"sindy_dmd/","page":"Unifying SINDy and DMD","title":"Unifying SINDy and DMD","text":"For implicit optimizers, you can pass an additional Vector{Num} of variables corresponding to u_t for implicitly defined equations f(u_t u p t) = 0:","category":"page"},{"location":"sindy_dmd/","page":"Unifying SINDy and DMD","title":"Unifying SINDy and DMD","text":"res = solve(problem, basis, ImplicitOptimizer(), implicits, kwargs...)","category":"page"},{"location":"sindy_dmd/","page":"Unifying SINDy and DMD","title":"Unifying SINDy and DMD","text":"This indicates that we do not have coupling between two implicitly defined variables unless coupling is explicitly included. To elaborate, consider the following:","category":"page"},{"location":"sindy_dmd/","page":"Unifying SINDy and DMD","title":"Unifying SINDy and DMD","text":"basis = Basis([x, y, z], [x,y,z])\nres = solve(problem, basis, ImplicitOptimizer())","category":"page"},{"location":"sindy_dmd/","page":"Unifying SINDy and DMD","title":"Unifying SINDy and DMD","text":"Allows solutions of the form x = y + z.","category":"page"},{"location":"sindy_dmd/","page":"Unifying SINDy and DMD","title":"Unifying SINDy and DMD","text":"basis = Basis([x, y, z], [x,y,z])\nres = solve(problem, basis, ImplicitOptimizer(), [x,y])","category":"page"},{"location":"sindy_dmd/","page":"Unifying SINDy and DMD","title":"Unifying SINDy and DMD","text":"Excludes solutions of the form x = z or y = z since we declared x and y as implicit variables assuming they don't interact. However, defining:","category":"page"},{"location":"sindy_dmd/","page":"Unifying SINDy and DMD","title":"Unifying SINDy and DMD","text":"basis = Basis([x, y, z, x*y], [x,y,z])\nres = solve(problem, basis, ImplicitOptimizer(), [x,y])","category":"page"},{"location":"sindy_dmd/","page":"Unifying SINDy and DMD","title":"Unifying SINDy and DMD","text":"Allows solutions of the form x = y*x + z or y = y*x + z, while suppressing x = y + z. This is because y*x includes both x and y, so the function will get included in the evaluation.","category":"page"},{"location":"sindy_dmd/#SINDy-Optional-Arguments","page":"Unifying SINDy and DMD","title":"SINDy Optional Arguments","text":"","category":"section"},{"location":"sindy_dmd/","page":"Unifying SINDy and DMD","title":"Unifying SINDy and DMD","text":"Possible keyword arguments include:","category":"page"},{"location":"sindy_dmd/","page":"Unifying SINDy and DMD","title":"Unifying SINDy and DMD","text":"normalize -> normalizes the data matrix Theta such that each row (corresponding to candidate functions) has a 2-norm of 1.0\ndenoise -> applies optimal shrinking to the matrix Theta to remove the influence of noise\nmaxiter -> maximum iterations of the used optimizer\nround -> rounds according to the currently used threshold of the optimizer","category":"page"},{"location":"utils/#Collocation","page":"Utilities","title":"Collocation","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"InterpolationMethod\ncollocate_data","category":"page"},{"location":"utils/#DataDrivenDiffEq.InterpolationMethod","page":"Utilities","title":"DataDrivenDiffEq.InterpolationMethod","text":"A wrapper for the interpolation methods of DataInterpolations.jl.\n\nWraps the methods in such a way that they are callable as f(u,t) to create and return an interpolation of u over t. The first argument of the constructor always defines the interpolation method, all following arguments will be used in the interpolation.\n\nExample\n\n# Create the wrapper struct\nitp_method = InterpolationMethod(QuadraticSpline)\n# Create a callable interpolation\nitp = itp_method(u,t)\n# Return u[2]\nitp(t[2])\n\n\n\n\n\n","category":"type"},{"location":"utils/#DataDrivenDiffEq.collocate_data","page":"Utilities","title":"DataDrivenDiffEq.collocate_data","text":"collocate_data(data, tpoints)\ncollocate_data(data, tpoints, kernel)\n\n\nUnified interface for collocation techniques. The input can either be a CollocationKernel (see list below) or a wrapped InterpolationMethod from DataInterpolations.jl.\n\nComputes a non-parametrically smoothed estimate of u' and u given the data, where each column is a snapshot of the timeseries at tpoints[i].\n\nExamples\n\nu′,u = collocate_data(data,tpoints,kernel=SigmoidKernel())\nu′,u = collocate_data(data,tpoints,tpoints_sample,interp,args...)\nu′,u = collocate_data(data,tpoints,interp)\n\nCollocation Kernels\n\nSee this paper for more information.\n\nEpanechnikovKernel\nUniformKernel\nTriangularKernel\nQuarticKernel\nTriweightKernel\nTricubeKernel\nGaussianKernel\nCosineKernel\nLogisticKernel\nSigmoidKernel\nSilvermanKernel\n\nInterpolation Methods\n\nSee DataInterpolations.jl for more information.\n\nConstantInterpolation\nLinearInterpolation\nQuadraticInterpolation\nLagrangeInterpolation\nQuadraticSpline\nCubicSpline\nBSplineInterpolation\nBSplineApprox\nCurvefit\n\n\n\n\n\n","category":"function"},{"location":"solvers/optimization/#sparse_optimization","page":"Sparse Optimizers","title":"Sparse Optimizers","text":"","category":"section"},{"location":"solvers/optimization/","page":"Sparse Optimizers","title":"Sparse Optimizers","text":"STLSQ\nADMM\nSR3\nImplicitOptimizer","category":"page"},{"location":"solvers/optimization/#DataDrivenDiffEq.STLSQ","page":"Sparse Optimizers","title":"DataDrivenDiffEq.STLSQ","text":"mutable struct STLSQ{T} <: DataDrivenDiffEq.AbstractOptimizer{T}\n\nSTLQS is taken from the original paper on SINDY and implements a sequentially thresholded least squares iteration. λ is the threshold of the iteration. It is based upon this matlab implementation. It solves the following problem\n\nargmin_x frac12  Ax-b_2 + lambda x_2\n\nFields\n\nλ\nSparsity threshold\n\nExample\n\nopt = STLQS()\nopt = STLQS(1e-1)\nopt = STLQS(Float32[1e-2; 1e-1])\n\nNote\n\nThis was formally STRRidge and has been renamed.\n\n\n\n\n\n","category":"type"},{"location":"solvers/optimization/#DataDrivenDiffEq.ADMM","page":"Sparse Optimizers","title":"DataDrivenDiffEq.ADMM","text":"mutable struct ADMM{T, R} <: DataDrivenDiffEq.AbstractOptimizer{T}\n\nADMM is an implementation of Lasso using the alternating direction methods of multipliers and loosely based on this implementation. It solves the following problem\n\nargmin_x frac12  Ax-b_2 + lambda x_1\n\nFields\n\nλ\nSparsity threshold\nρ\nAugmented Lagrangian parameter\n\nExample\n\nopt = ADMM()\nopt = ADMM(1e-1, 2.0)\n\n\n\n\n\n","category":"type"},{"location":"solvers/optimization/#DataDrivenDiffEq.SR3","page":"Sparse Optimizers","title":"DataDrivenDiffEq.SR3","text":"mutable struct SR3{T, V, P<:DataDrivenDiffEq.AbstractProximalOperator} <: DataDrivenDiffEq.AbstractOptimizer{T}\n\nSR3 is an optimizer framework introduced by Zheng et. al., 2018 and used within Champion et. al., 2019. SR3 contains a sparsification parameter λ, a relaxation ν. It solves the following problem\n\nargmin_x w frac12  Ax-b_2 + lambda R(w) + fracnu2x-w_2\n\nWhere R is a proximal operator and the result is given by w.\n\nFields\n\nλ\nSparsity threshold\nν\nRelaxation parameter\nR\nProximal operator\n\nExample\n\nopt = SR3()\nopt = SR3(1e-2)\nopt = SR3(1e-3, 1.0)\nopt = SR3(1e-3, 1.0, SoftThreshold())\n\nNote\n\nOpposed to the original formulation, we use ν as a relaxation parameter, as given in Champion et. al., 2019. In the standard case of hard thresholding the sparsity is interpreted as λ = threshold^2 / 2, otherwise λ = threshold.\n\n\n\n\n\n","category":"type"},{"location":"solvers/optimization/#DataDrivenDiffEq.ImplicitOptimizer","page":"Sparse Optimizers","title":"DataDrivenDiffEq.ImplicitOptimizer","text":"mutable struct ImplicitOptimizer{T} <: DataDrivenDiffEq.AbstractSubspaceOptimizer{T}\n\nOptimizer for finding a sparse implicit relationship via alternating the left hand side of the problem and solving the explicit problem, as introduced here.\n\nargmin_x x_0 stAx= 0\n\nFields\n\no\nExplicit Optimizer\n\nExample\n\nImplicitOptimizer(STLSQ())\nImplicitOptimizer(0.1f0, ADMM)\n\n\n\n\n\n","category":"type"},{"location":"solvers/optimization/#Related-Functions","page":"Sparse Optimizers","title":"Related Functions","text":"","category":"section"},{"location":"solvers/optimization/","page":"Sparse Optimizers","title":"Sparse Optimizers","text":"sparse_regression!\nset_threshold!\nget_threshold","category":"page"},{"location":"solvers/optimization/#DataDrivenDiffEq.sparse_regression!","page":"Sparse Optimizers","title":"DataDrivenDiffEq.sparse_regression!","text":"sparse_regression!(X, A, Y, opt; maxiter, abstol, progress, f, g, progress_outer, progress_offset, kwargs...)\n\n\nImplements a sparse regression, given an AbstractOptimizer or AbstractSubspaceOptimizer. X denotes the coefficient matrix, A the design matrix and Y the matrix of observed or target values. X can be derived via init(opt, A, Y). maxiter indicates the maximum iterations for each call of the optimizer, abstol the absolute tolerance of the difference between iterations in the 2 norm. If the optimizer is called with a Vector of thresholds, each maxiter indicates the maximum iterations for each threshold.\n\nIf progress is set to true, a progressbar will be available. progress_outer and progress_offset are used to compute the initial offset of the progressbar.\n\nIf used with a Vector of thresholds, the functions f with signature f(X, A, Y) and g with signature g(x, threshold) = G(f(X, A, Y)) with the arguments given as stated above can be passed in. These are used for finding the pareto-optimal solution to the sparse regression. \n\n\n\n\n\n","category":"function"},{"location":"solvers/optimization/#DataDrivenDiffEq.set_threshold!","page":"Sparse Optimizers","title":"DataDrivenDiffEq.set_threshold!","text":"set_threshold!(opt, threshold)\n\n\nSet the threshold(s) of an optimizer to (a) specific value(s).\n\n\n\n\n\n","category":"function"},{"location":"solvers/optimization/#DataDrivenDiffEq.get_threshold","page":"Sparse Optimizers","title":"DataDrivenDiffEq.get_threshold","text":"get_threshold(opt)\n\n\nGet the threshold(s) of an optimizer.\n\n\n\n\n\n","category":"function"},{"location":"solvers/optimization/#Proximal-Operators","page":"Sparse Optimizers","title":"Proximal Operators","text":"","category":"section"},{"location":"solvers/optimization/","page":"Sparse Optimizers","title":"Sparse Optimizers","text":"SoftThreshold\nHardThreshold\nClippedAbsoluteDeviation","category":"page"},{"location":"solvers/optimization/#DataDrivenDiffEq.SoftThreshold","page":"Sparse Optimizers","title":"DataDrivenDiffEq.SoftThreshold","text":"struct SoftThreshold <: DataDrivenDiffEq.AbstractProximalOperator\n\nProximal operator which implements the soft thresholding operator.\n\nsign(x) * max(abs(x) - λ, 0)\n\nSee by Zheng et. al., 2018.\n\n\n\n\n\n","category":"type"},{"location":"solvers/optimization/#DataDrivenDiffEq.HardThreshold","page":"Sparse Optimizers","title":"DataDrivenDiffEq.HardThreshold","text":"struct HardThreshold <: DataDrivenDiffEq.AbstractProximalOperator\n\nProximal operator which implements the hard thresholding operator.\n\nabs(x) > sqrt(2*λ) ? x : 0\n\nSee by Zheng et. al., 2018.\n\n\n\n\n\n","category":"type"},{"location":"solvers/optimization/#DataDrivenDiffEq.ClippedAbsoluteDeviation","page":"Sparse Optimizers","title":"DataDrivenDiffEq.ClippedAbsoluteDeviation","text":"struct ClippedAbsoluteDeviation{T} <: DataDrivenDiffEq.AbstractProximalOperator\n\nProximal operator which implements the (smoothly) clipped absolute deviation operator.\n\nabs(x) > ρ ? x : sign(x) * max(abs(x) - λ, 0)\n\nWhere ρ = 5λ per default.\n\n#Fields\n\nρ\nUpper threshold\n\nExample\n\nopt = ClippedAbsoluteDeviation()\nopt = ClippedAbsoluteDeviation(1e-1)\n\nSee by Zheng et. al., 2018.\n\n\n\n\n\n","category":"type"},{"location":"examples/linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"EditURL = \"https://github.com/SciML/DataDrivenDiffEq.jl/blob/master/docs/examples/linear_continuous_system.jl\"","category":"page"},{"location":"examples/linear_continuous_system/#linear_continuous","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"","category":"section"},{"location":"examples/linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"Similar to the linear time discrete example, we will now estimate a linear time continuous system partial_t u = A u. We simulate the correspoding system using OrdinaryDiffEq.jl and generate a ContinuousDataDrivenProblem from the simulated data.","category":"page"},{"location":"examples/linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing Plots\n\nA = [-0.9 0.2; 0.0 -0.2]\nu0 = [10.0; -10.0]\ntspan = (0.0, 10.0)\n\nf(u,p,t) = A*u\n\nsys = ODEProblem(f, u0, tspan)\nsol = solve(sys, Tsit5(), saveat = 0.05);\nnothing #hide","category":"page"},{"location":"examples/linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"We could use the DESolution to define our problem, but here we want to use the data for didactic purposes. For a ContinuousDataDrivenProblem, we need either the state trajectory and the timepoints or the state trajectory and its derivate.","category":"page"},{"location":"examples/linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"X = Array(sol)\nt = sol.t\nprob = ContinuousDataDrivenProblem(X, t)","category":"page"},{"location":"examples/linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"And plot the problems data.","category":"page"},{"location":"examples/linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"plot(prob)","category":"page"},{"location":"examples/linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"We can see that the derivative has been automatically added via a collocation method, which defaults to a LinearInterpolation. We can do a visual check and compare our derivatives with the interpolation of the ODESolution.","category":"page"},{"location":"examples/linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"DX = Array(sol(t, Val{1}))\nscatter(t, DX', label = [\"Solution\" nothing], color = :red, legend = :bottomright)\nplot!(t, prob.DX', label = [\"Linear Interpolation\" nothing], color = :black)","category":"page"},{"location":"examples/linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"Since we have a linear system, we can use gDMD, which approximates the generator of the dynamics","category":"page"},{"location":"examples/linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"res = solve(prob, DMDSVD())\nprintln(res)","category":"page"},{"location":"examples/linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"We see that the system has been recovered correctly, indicated by the small error and high AIC score of the result. We can confirm this by looking at the resulting Basis","category":"page"},{"location":"examples/linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"system = result(res)\nprintln(system)","category":"page"},{"location":"examples/linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"And also plot the prediction of the recovered dynamics","category":"page"},{"location":"examples/linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"plot(res)","category":"page"},{"location":"examples/linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"Or a have a look at the metrics of the result","category":"page"},{"location":"examples/linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"metrics(res)","category":"page"},{"location":"examples/linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"And check the parameters of the result","category":"page"},{"location":"examples/linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"parameters(res)","category":"page"},{"location":"examples/linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"or the generator of the system","category":"page"},{"location":"examples/linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"Matrix(generator(system))","category":"page"},{"location":"examples/linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"to see that the operator is slightly off, but within expectations. In a real example, this could have many reasons, e.g. noisy data, insufficient time samples or missing states.","category":"page"},{"location":"examples/linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"Sticking to the same procedure as earlier, we now use a linear sparse regression to solve the problem","category":"page"},{"location":"examples/linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"using ModelingToolkit\n\n@parameters t\n@variables x[1:2](t)\n\nbasis = Basis(x, x, independent_variable = t, name = :LinearBasis)\nprint(basis) #hide","category":"page"},{"location":"examples/linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"Afterwards, we simply solve the already defined problem with our Basis and a SparseOptimizer","category":"page"},{"location":"examples/linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"sparse_res = solve(prob, basis, STLSQ(1e-1))\nprintln(sparse_res)","category":"page"},{"location":"examples/linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"Which holds the same equations","category":"page"},{"location":"examples/linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"sparse_system = result(sparse_res)\nprintln(sparse_system)","category":"page"},{"location":"examples/linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"Again, we can have a look at the result","category":"page"},{"location":"examples/linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"plot(\n    plot(prob), plot(sparse_res), layout = (1,2)\n)","category":"page"},{"location":"examples/linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"Both results can be converted into an ODESystem","category":"page"},{"location":"examples/linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"@named sys = ODESystem(\n    equations(sparse_system),\n    get_iv(sparse_system),\n    states(sparse_system),\n    parameters(sparse_system)\n    );\nnothing #hide","category":"page"},{"location":"examples/linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"And simulated using OrdinaryDiffEq.jl using the (known) initial conditions and the parameter mapping of the estimation.","category":"page"},{"location":"examples/linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"x0 = [x[1] => u0[1], x[2] => u0[2]]\nps = parameter_map(sparse_res)\n\node_prob = ODEProblem(sys, x0, tspan, ps)\nestimate = solve(ode_prob, Tsit5(), saveat = prob.t);\nnothing #hide","category":"page"},{"location":"examples/linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"And look at the result","category":"page"},{"location":"examples/linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"plot(sol, color = :black)\nplot!(estimate, color = :red, linestyle = :dash)","category":"page"},{"location":"examples/linear_continuous_system/#linear_continuous_copy_paste","page":"Linear Time Continuous System","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"examples/linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing LinearAlgebra\nusing OrdinaryDiffEq\n\nA = [-0.9 0.2; 0.0 -0.2]\nu0 = [10.0; -10.0]\ntspan = (0.0, 10.0)\n\nf(u,p,t) = A*u\n\nsys = ODEProblem(f, u0, tspan)\nsol = solve(sys, Tsit5(), saveat = 0.05);\n\nX = Array(sol)\nt = sol.t\nprob = ContinuousDataDrivenProblem(X, t)\n\nusing ModelingToolkit\n\n@parameters t\n@variables x[1:2](t)\n\nbasis = Basis(x, x, independent_variable = t, name = :LinearBasis)\n\nsparse_res = solve(prob, basis, STLSQ(1e-1))\n\nsparse_system = result(sparse_res)\n\n@named sys = ODESystem(\n    equations(sparse_system),\n    get_iv(sparse_system),\n    states(sparse_system),\n    parameters(sparse_system)\n    );\n\nx0 = [x[1] => u0[1], x[2] => u0[2]]\nps = parameter_map(sparse_res)\n\node_prob = ODEProblem(sys, x0, tspan, ps)\nestimate = solve(ode_prob, Tsit5(), saveat = prob.t);\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"","category":"page"},{"location":"examples/linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"This page was generated using Literate.jl.","category":"page"},{"location":"solvers/koopman/#Koopman","page":"Koopman","title":"Koopman","text":"","category":"section"},{"location":"solvers/koopman/","page":"Koopman","title":"Koopman","text":"Koopman","category":"page"},{"location":"solvers/koopman/#DataDrivenDiffEq.Koopman","page":"Koopman","title":"DataDrivenDiffEq.Koopman","text":"mutable struct Koopman{O, M, G, T} <: DataDrivenDiffEq.AbstractKoopman\n\nA special basis over the states with parameters , independent variable  and possible exogenous controls. It extends an AbstractBasis, which also stores information about the lifted dynamics, specified by a sufficient matrix factorization, an output mapping and internal variables to update the equations. It can be called with the typical SciML signature, meaning out of place with f(u,p,t) or in place with f(du, u, p, t). If control inputs are present, it is assumed that no control corresponds to zero for all inputs. The corresponding function calls are f(u,p,t,inputs) and f(du,u,p,t,inputs) and need to be specified fully.\n\nIf linear_independent is set to true, a linear independent basis is created from all atom functions in f.\n\nIf simplify_eqs is set to true, simplify is called on f.\n\nAdditional keyworded arguments include name, which can be used to name the basis, and observed for defining observeables.\n\nFields\n\neqs\nThe equations of the basis\nstates\nDependent (state) variables\nctrls\nControl variables\nps\nParameters\nobserved\nObserved\niv\nIndependent variable\nf\nInternal function representation of the basis\nlift\nAssociated lifting of the operator\nname\nName of the basis\nsystems\nInternal systems\nis_discrete\nDiscrete or time continuous\nK\nThe operator/generator of the dynamics\nC\nMapping back onto the observed states\nQ\nInternal matrix Q used for updating\nP\nInternal matrix P used for updating\n\nNote\n\nThe keyword argument eval_expression controls the function creation behavior. eval_expression=true means that eval is used, so normal world-age behavior applies (i.e. the functions cannot be called from the function that generates them). If eval_expression=false, then construction via GeneralizedGenerated.jl is utilized to allow for same world-age evaluation. However, this can cause Julia to segfault on sufficiently large basis functions. By default eval_expression=false.\n\n\n\n\n\n","category":"type"},{"location":"solvers/koopman/#Functions","page":"Koopman","title":"Functions","text":"","category":"section"},{"location":"solvers/koopman/","page":"Koopman","title":"Koopman","text":"is_discrete\nis_continuous\nDataDrivenDiffEq.eigen\nDataDrivenDiffEq.eigvals\nDataDrivenDiffEq.eigvecs\nmodes\nfrequencies\noperator\ngenerator\nupdatable\nis_stable\nupdate!","category":"page"},{"location":"solvers/koopman/#DataDrivenDiffEq.is_discrete","page":"Koopman","title":"DataDrivenDiffEq.is_discrete","text":"is_discrete(k)\n\n\nReturns true if the AbstractKoopmanOperator k is discrete in time.\n\n\n\n\n\nCheck if the problem is time discrete.\n\n\n\n\n\n","category":"function"},{"location":"solvers/koopman/#DataDrivenDiffEq.is_continuous","page":"Koopman","title":"DataDrivenDiffEq.is_continuous","text":"is_continuous(k)\n\n\nReturns true if the AbstractKoopmanOperator k is continuous in time.\n\n\n\n\n\nCheck if the problem is time continuous.\n\n\n\n\n\n","category":"function"},{"location":"solvers/koopman/#LinearAlgebra.eigen","page":"Koopman","title":"LinearAlgebra.eigen","text":"eigen(k)\n\n\nReturn the eigendecomposition of the AbstractKoopmanOperator.\n\n\n\n\n\n","category":"function"},{"location":"solvers/koopman/#LinearAlgebra.eigvals","page":"Koopman","title":"LinearAlgebra.eigvals","text":"eigvals(k)\n\n\nReturn the eigenvalues of the AbstractKoopmanOperator.\n\n\n\n\n\n","category":"function"},{"location":"solvers/koopman/#LinearAlgebra.eigvecs","page":"Koopman","title":"LinearAlgebra.eigvecs","text":"eigvecs(k)\n\n\nReturn the eigenvectors of the AbstractKoopmanOperator.\n\n\n\n\n\n","category":"function"},{"location":"solvers/koopman/#DataDrivenDiffEq.modes","page":"Koopman","title":"DataDrivenDiffEq.modes","text":"modes(k)\n\n\nReturn the eigenvectors of a continuous AbstractKoopmanOperator.\n\n\n\n\n\n","category":"function"},{"location":"solvers/koopman/#DataDrivenDiffEq.frequencies","page":"Koopman","title":"DataDrivenDiffEq.frequencies","text":"frequencies(k)\n\n\nReturn the eigenvalues of a continuous AbstractKoopmanOperator.\n\n\n\n\n\n","category":"function"},{"location":"solvers/koopman/#DataDrivenDiffEq.operator","page":"Koopman","title":"DataDrivenDiffEq.operator","text":"operator(k)\n\n\nReturn the approximation of the discrete Koopman operator stored in k.\n\n\n\n\n\n","category":"function"},{"location":"solvers/koopman/#DataDrivenDiffEq.generator","page":"Koopman","title":"DataDrivenDiffEq.generator","text":"generator(k)\n\n\nReturn the approximation of the continuous Koopman generator stored in k.\n\n\n\n\n\n","category":"function"},{"location":"solvers/koopman/#DataDrivenDiffEq.updatable","page":"Koopman","title":"DataDrivenDiffEq.updatable","text":"updatable(k)\n\n\nReturns true if the AbstractKoopmanOperator is updatable.\n\n\n\n\n\n","category":"function"},{"location":"solvers/koopman/#DataDrivenDiffEq.is_stable","page":"Koopman","title":"DataDrivenDiffEq.is_stable","text":"is_stable(k)\n\n\nReturns true if either:\n\nthe Koopman operator has just eigenvalues with magnitude less than one or\nthe Koopman generator has just eigenvalues with a negative real part\n\n\n\n\n\n","category":"function"},{"location":"solvers/koopman/#DataDrivenDiffEq.update!","page":"Koopman","title":"DataDrivenDiffEq.update!","text":"update!(k, X, Y; p, t, U, threshold)\n\n\nUpdate the Koopman k given new data X and Y. The operator is updated in place if the L2 error of the prediction exceeds the threshold.\n\np and t are the parameters of the basis and the vector of timepoints, if necessary.\n\n\n\n\n\n","category":"function"},{"location":"solvers/koopman/#koopman_algorithms","page":"Koopman","title":"Algorithms","text":"","category":"section"},{"location":"solvers/koopman/","page":"Koopman","title":"Koopman","text":"DMDPINV\nDMDSVD\nTOTALDMD","category":"page"},{"location":"solvers/koopman/#DataDrivenDiffEq.DMDPINV","page":"Koopman","title":"DataDrivenDiffEq.DMDPINV","text":"mutable struct DMDPINV <: DataDrivenDiffEq.AbstractKoopmanAlgorithm\n\nApproximates the Koopman operator K based on\n\nK = Y / X\n\nwhere Y and X are data matrices. Returns a  Eigen factorization of the operator.\n\nFields\n\nSignatures\n\n\n\n\n\n","category":"type"},{"location":"solvers/koopman/#DataDrivenDiffEq.DMDSVD","page":"Koopman","title":"DataDrivenDiffEq.DMDSVD","text":"mutable struct DMDSVD{T} <: DataDrivenDiffEq.AbstractKoopmanAlgorithm\n\nApproximates the Koopman operator K based on the singular value decomposition of X such that:\n\nK = Y*V*Σ*U'\n\nwhere Y and X = U*Σ*V' are data matrices. The singular value decomposition is truncated via the truncation parameter, which can either be an Int indiciating an index based truncation or a Real indiciating a tolerance based truncation. Returns a Eigen factorization of the operator.\n\nFields\n\ntruncation\nIndiciates the truncation\n\nSignatures\n\n\n\n\n\n","category":"type"},{"location":"solvers/koopman/#DataDrivenDiffEq.TOTALDMD","page":"Koopman","title":"DataDrivenDiffEq.TOTALDMD","text":"mutable struct TOTALDMD{R, A} <: DataDrivenDiffEq.AbstractKoopmanAlgorithm\n\nApproximates the Koopman operator K with the algorithm alg over the rank-reduced data matrices Xᵣ = X Qᵣ and Yᵣ = Y Qᵣ, where Qᵣ originates from the singular value decomposition of the joint data Z = [X; Y]. Based on this paper.\n\nIf rtol ∈ (0, 1) is given, the singular value decomposition is reduced to include only entries bigger than rtol*maximum(Σ). If rtol is an integer, the reduced SVD up to rtol is used for computation.\n\nFields\n\ntruncation\nalg\n\nSignatures\n\n\n\n\n\n","category":"type"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The workflow for DataDrivenDiffEq.jl is similar to other SciML packages. You start by defining a DataDrivenProblem and then dispatch on the solve command to return a DataDrivenSolution.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Here is an outline of the required elements and choices:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Define a problem using your data.\nData can be discrete, continuous, or direct.\nChoose a basis.\nThis is optional depending on which solver you choose.\nSolve the problem.\nMany solvers exist; see the docs.","category":"page"},{"location":"getting_started/#Basic-usage","page":"Getting Started","title":"Basic usage","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using DataDrivenDiffEq, ModelingToolkit, LinearAlgebra\n\n# The function we are trying to find\nf(u) = u.^2 .+ 2.0u .- 1.0\n#\nX = randn(1, 100)\nY = reduce(hcat, map(f, eachcol(X)))\n# Create a problem from the data\nproblem = DirectDataDrivenProblem(X, Y)\n\n# Choose a basis\n@variables u\nbasis = Basis(monomial_basis([u], 2), [u])\nprintln(basis)\n\n\n\n\n# Solve the problem, using the solver of your choosing\nres = solve(problem, basis, STLSQ())\nprintln(res)\nprintln(result(res))","category":"page"},{"location":"getting_started/#Defining-a-Problem","page":"Getting Started","title":"Defining a Problem","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Problems of identification, estimation, or inference are defined by data. These data contain at least measurements of the states X, which would be sufficient to describe a DiscreteDataDrivenProblem with unit time steps similar to the first example on dynamic mode decomposition. Of course, we can extend this to include time points t, control signals U or a function describing those u(x,p,t). Additionally, any parameters p known a priori can be included in the problem. In practice, this looks like:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"problem = DiscreteDataDrivenProblem(X)\nproblem = DiscreteDataDrivenProblem(X, t)\nproblem = DiscreteDataDrivenProblem(X, t, U)\nproblem = DiscreteDataDrivenProblem(X, t, U, p = p)\nproblem = DiscreteDataDrivenProblem(X, t, (x,p,t)->u(x,p,t))","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Similarly, a ContinuousDataDrivenProblem would need at least measurements and time-derivatives (X and DX) or measurements, time information and a way to derive the time derivatives(X, t and a Collocation method). Again, this can be extended by including a control input as measurements or a function and possible parameters:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"problem = ContinuousDataDrivenProblem(X, DX)\nproblem = ContinuousDataDrivenProblem(X, t, DX)\nproblem = ContinuousDataDrivenProblem(X, t, DX, U, p = p)\nproblem = ContinuousDataDrivenProblem(X, t, DX, (x,p,t)->u(x,p,t))\n# Using collocation\nproblem = ContinuousDataDrivenProblem(X, t, InterpolationMethod())\nproblem = ContinuousDataDrivenProblem(X, t, GaussianKernel())\nproblem = ContinuousDataDrivenProblem(X, t, U, InterpolationMethod())\nproblem = ContinuousDataDrivenProblem(X, t, U, GaussianKernel(), p = p)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"You can also directly use a DESolution as an input to your DataDrivenProblem:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"problem = DataDrivenProblem(sol; kwargs...)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"which evaluates the function at the specific timepoints t using the parameters p of the original problem instead of using the interpolation. If you want to use the interpolated data, add the additional keyword use_interpolation = true.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"An additional type of problem is the DirectDataDrivenProblem, which does not assume any kind of causal relationship. It is defined by X and an observed output Y in addition to the usual arguments:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"problem = DirectDataDrivenProblem(X, Y)\nproblem = DirectDataDrivenProblem(X, t, Y)\nproblem = DirectDataDrivenProblem(X, t, Y, U)\nproblem = DirectDataDrivenProblem(X, t, Y, p = p)\nproblem = DirectDataDrivenProblem(X, t, Y, (x,p,t)->u(x,p,t), p = p)","category":"page"},{"location":"getting_started/#Choosing-a-Basis","page":"Getting Started","title":"Choosing a Basis","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"A basis is optional, depending on the solver and solution method you are using. For instance, for DMD, a basis is not required, but for SINDy using STLQS(), it is required.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"A basis can be defined like:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"@variables u[1:2]\nΨ = Basis([u; u[1]^2], u)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"See the Implicit Systems tutorials for more complex examples of defining a Basis.","category":"page"},{"location":"getting_started/#Solving-the-Problem","page":"Getting Started","title":"Solving the Problem","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Next up, we choose a method to solve the DataDrivenProblem. Depending on the input arguments and the type of problem, the function will return a result derived via Koopman, Sparse Optimization, or general Symbolic Regression. Different options can be provided, depending on the inference method, for options like rounding, normalization, or the progress bar. A Basis can be used for lifting the measurements.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Use a Koopman based inference\nres = solve(problem, DMDSVD(), kwargs...)\n# Use a sparse identification\nres = solve(problem, basis, STLQS(), kwargs...)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The DataDrivenSolution res contains a result which is the inferred system and a Basis, metrics which is a NamedTuple containing different metrics of the inferred system. These can be accessed via:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# The inferred system\nsystem = result(res)\n# The metrics\nm = metrics(res)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Since the inferred system is a parametrized equation, the corresponding parameters can be accessed and returned via","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Vector\nps = parameters(res)\n# Parameter map\nps = parameter_map(res)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"info: Info\nThe keyword argument eval_expression controls the function creation behavior. eval_expression=true means that eval is used, so normal world-age behavior applies (i.e. the functions cannot be called from the function that generates them). If eval_expression=false, then construction via GeneralizedGenerated.jl is utilized to allow for same world-age evaluation. However, this can cause Julia to segfault on sufficiently large basis functions. By default eval_expression=false.","category":"page"},{"location":"problems/#Problems","page":"Problems","title":"Problems","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"DataDrivenProblem","category":"page"},{"location":"problems/#DataDrivenDiffEq.DataDrivenProblem","page":"Problems","title":"DataDrivenDiffEq.DataDrivenProblem","text":"struct DataDrivenProblem{dType, cType, probType} <: DataDrivenDiffEq.AbstractDataDrivenProblem{dType, cType, probType}\n\nThe DataDrivenProblem defines a general estimation problem given measurements, inputs and (in the near future) observations. Two construction methods are available:\n\nDiscreteDataDrivenProblem for time discrete systems\nContinousDataDrivenProblem for systems continuous in time\n\nboth are aliases for constructing a problem.\n\nFields\n\nX\nState measurements\nt\nTime measurements (optional)\nDX\nDifferental state measurements (optional); Used for time continuous problems\nY\nOutput measurements (optional); Used for direct problems\nU\nInput measurements (optional); Used for non-autonoumous problems\np\nParameters associated with the problem (optional)\nname\nName of the problem\n\nSignatures\n\nExample\n\nX, DX, t = data...\n\n# Define a discrete time problem\nprob = DiscreteDataDrivenProblem(X)\n\n# Define a continuous time problem without explicit time points\nprob = ContinuousDataDrivenProblem(X, DX)\n\n# Define a continuous time problem without explicit derivatives\nprob = ContinuousDataDrivenProblem(X, t)\n\n# Define a discrete time problem with an input function as a function\ninput_signal(u,p,t) = t^2\nprob = DiscreteDataDrivenProblem(X, t, input_signal)\n\n\n\n\n\n","category":"type"},{"location":"problems/#Concrete-Types","page":"Problems","title":"Concrete Types","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"DiscreteDataDrivenProblem\nContinuousDataDrivenProblem\nDirectDataDrivenProblem","category":"page"},{"location":"problems/#DataDrivenDiffEq.DiscreteDataDrivenProblem","page":"Problems","title":"DataDrivenDiffEq.DiscreteDataDrivenProblem","text":"A time discrete DataDrivenProblem useable for problems of the form f(x[i],p,t,u) ↦ x[i+1].\n\nDiscreteDataDrivenProblem(X; kwargs...)\n\n\n\n\n\n\n","category":"function"},{"location":"problems/#DataDrivenDiffEq.ContinuousDataDrivenProblem","page":"Problems","title":"DataDrivenDiffEq.ContinuousDataDrivenProblem","text":"A time continuous DataDrivenProblem useable for problems of the form f(x,p,t,u) ↦ dx/dt.\n\nContinuousDataDrivenProblem(X, DX; kwargs...)\n\n\nAutomatically constructs derivatives via an additional collocation method, which can be either a collocation or an interpolation from DataInterpolations.jl wrapped by an InterpolationMethod.\n\n\n\n\n\n","category":"function"},{"location":"problems/#DataDrivenDiffEq.DirectDataDrivenProblem","page":"Problems","title":"DataDrivenDiffEq.DirectDataDrivenProblem","text":"A direct DataDrivenProblem useable for problems of the form f(x,p,t,u) ↦ y.\n\nDirectDataDrivenProblem(X, Y; kwargs...)\n\n\n\n\n\n\n","category":"function"},{"location":"examples/michaelis_menten/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"EditURL = \"https://github.com/SciML/DataDrivenDiffEq.jl/blob/master/docs/examples/michaelis_menten.jl\"","category":"page"},{"location":"examples/michaelis_menten/#michaelis_menten","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"","category":"section"},{"location":"examples/michaelis_menten/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"What if you want to estimate an implicitly defined system of the form f(u_t u p t) = 0? The solution : Implicit Sparse Identification. This method was originally described in this paper, and currently there exist robust algorithms to identify these systems. We will focus on Michaelis Menten Kinetics. As before, we will define the DataDrivenProblem and the Basis containing possible candidate functions for our sparse_regression!. Lets generate some data! We will use two experiments starting from different initial conditions.","category":"page"},{"location":"examples/michaelis_menten/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing ModelingToolkit\nusing OrdinaryDiffEq\nusing Plots\n\nfunction michaelis_menten(u, p, t)\n    [0.6 - 1.5u[1]/(0.3+u[1])]\nend\n\nu0 = [0.5]\n\nproblem_1 = ODEProblem(michaelis_menten, u0, (0.0, 4.0))\nsolution_1 = solve(problem_1, Tsit5(), saveat = 0.1)\nproblem_2 = ODEProblem(michaelis_menten, 2*u0, (4.0, 8.0))\nsolution_2 = solve(problem_2, Tsit5(), saveat = 0.1)\nX = [solution_1[:,:] solution_2[:,:]]\nts = [solution_1.t; solution_2.t]\n\nDX = similar(X)\nfor (i, xi) in enumerate(eachcol(X))\n    DX[:, i] = michaelis_menten(xi, [], ts[i])\nend\n\nprob = ContinuousDataDrivenProblem(X, ts, DX = DX)\nplot(prob)","category":"page"},{"location":"examples/michaelis_menten/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"Next, we define our Basis. Since we want to identify an implicit system, we have to include some candidate terms which use these as an argument and inform our constructor about the meaning of these variables.","category":"page"},{"location":"examples/michaelis_menten/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"@parameters t\nD = Differential(t)\n@variables u[1:1](t)\nh = [monomial_basis(u[1:1], 4)...]\nbasis = Basis([h; h .* D(u[1])], u, implicits = D.(u), iv = t)\nprintln(basis) # hide","category":"page"},{"location":"examples/michaelis_menten/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"Next, we define the ImplicitOptimizer and solve the problem. It wraps a standard optimizer, by default STLSQ, and performs implicit sparse regression upon the selected basis. To improve our result, we batch the data by using a DataSampler. Here, we use a train-test split of 0.8 and divide the training data into 10 batches. Since we are using a batching process, we can also use a different","category":"page"},{"location":"examples/michaelis_menten/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"sampler = DataSampler(\n    Split(ratio = 0.8), Batcher(n = 10)\n)\n\nopt = ImplicitOptimizer(1e-1:1e-1:5e-1)\nres = solve(prob, basis, opt,  normalize = false, denoise = false, by = :min, sampler = sampler, maxiter = 1000);\nprintln(res) # hide","category":"page"},{"location":"examples/michaelis_menten/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"As we can see, the DataDrivenSolution has good metrics. Furthermore, inspection of the underlying system shows that the original equations have been recovered correctly:","category":"page"},{"location":"examples/michaelis_menten/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"system = result(res)\nprintln(system) # hide\n\nplot(\n    plot(prob), plot(res), layout = (1,2)\n)","category":"page"},{"location":"examples/michaelis_menten/#michaelis_menten_copy_paste","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"examples/michaelis_menten/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing ModelingToolkit\nusing OrdinaryDiffEq\n\nfunction michaelis_menten(u, p, t)\n    [0.6 - 1.5u[1]/(0.3+u[1])]\nend\n\nu0 = [0.5]\n\nproblem_1 = ODEProblem(michaelis_menten, u0, (0.0, 4.0))\nsolution_1 = solve(problem_1, Tsit5(), saveat = 0.1)\nproblem_2 = ODEProblem(michaelis_menten, 2*u0, (4.0, 8.0))\nsolution_2 = solve(problem_2, Tsit5(), saveat = 0.1)\nX = [solution_1[:,:] solution_2[:,:]]\nts = [solution_1.t; solution_2.t]\n\nDX = similar(X)\nfor (i, xi) in enumerate(eachcol(X))\n    DX[:, i] = michaelis_menten(xi, [], ts[i])\nend\n\nprob = ContinuousDataDrivenProblem(X, ts, DX = DX)\n\n@parameters t\nD = Differential(t)\n@variables u[1:1](t)\nh = [monomial_basis(u[1:1], 4)...]\nbasis = Basis([h; h .* D(u[1])], u, implicits = D.(u), iv = t)\nprintln(basis) # hide\n\nsampler = DataSampler(\n    Split(ratio = 0.8), Batcher(n = 10)\n)\n\nopt = ImplicitOptimizer(1e-1:1e-1:5e-1)\nres = solve(prob, basis, opt,  normalize = false, denoise = false, by = :min, sampler = sampler, maxiter = 1000);\nprintln(res) # hide\n\nsystem = result(res)\nprintln(system) # hide\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/michaelis_menten/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"","category":"page"},{"location":"examples/michaelis_menten/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#DataDrivenDiffEq.jl","page":"Home","title":"DataDrivenDiffEq.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DataDrivenDiffEq.jl is a package for finding the governing equations of motion automatically from a dataset.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The methods in this package take in data and return the differential equation model which generated the data. A known model is not required as input. These methods can estimate equation-free and equation-based models for discrete and continuous differential equations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are two main types of estimation, depending on if you need the result to be human-understandable:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Structural identification - returns a human readable result in symbolic form.\nStructural estimation - returns a function that predicts the derivative and generates a correct time series, but is not necessarily human readable.","category":"page"},{"location":"#Package-Overview","page":"Home","title":"Package Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DataDrivenDiffEq.jl currently implements the following algorithms for structural estimation and identification. Please note that all the algorithms have been unified under a single mathematical framework, so the interface might be a little different than what you expect.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Dynamic Mode Decomposition (DMD)\nExtended Dynamic Mode Decomposition\nSparse Identification of Nonlinear Dynamics (SINDy)\nImplicit Sparse Identification of Nonlinear Dynamics","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To use DataDrivenDiffEq.jl, install via:","category":"page"},{"location":"","page":"Home","title":"Home","text":"]add DataDrivenDiffEq\nusing DataDrivenDiffEq","category":"page"}]
}
