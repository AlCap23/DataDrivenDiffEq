var documenterSearchIndex = {"docs":
[{"location":"basis/#Basis-1","page":"Basis","title":"Basis","text":"","category":"section"},{"location":"basis/#","page":"Basis","title":"Basis","text":"Basis","category":"page"},{"location":"basis/#DataDrivenDiffEq.Basis","page":"Basis","title":"DataDrivenDiffEq.Basis","text":"mutable struct Basis <: DataDrivenDiffEq.AbstractBasis\n\nA basis over the states with parameters , independent variable  and possible exogenous controls. It extends an AbstractSystem as defined in ModelingToolkit.jl. f can either be a Julia function which is able to use ModelingToolkit variables or a vector of eqs. It can be called with the typical SciML signature, meaning out of place with f(u,p,t) or in place with f(du, u, p, t). If control inputs are present, it is assumed that no control corresponds to zero for all inputs. The corresponding function calls are f(u,p,t,inputs) and f(du,u,p,t,inputs) and need to be specified fully.\n\nIf linear_independent is set to true, a linear independent basis is created from all atom function in f.\n\nIf simplify_eqs is set to true, simplify is called on f.\n\nAdditional keyworded arguments include name, which can be used to name the basis, and observed for defining observeables.\n\nFields\n\neqs\nThe equations of the basis\nstates\nDependent (state) variables\ncontrols\nControl variables\nps\nParameters\nobserved\nObserved\niv\nIndependent variable\nf\nInternal function representation of the basis\nname\nName of the basis\nsystems\nInternal systems\n\nExample\n\nusing ModelingToolkit\nusing DataDrivenDiffEq\n\n@parameters w[1:2] t\n@variables u[1:2](t)\n\nΨ = Basis([u; sin.(w.*u)], u, parameters = p, iv = t)\n\nNote\n\nThe keyword argument eval_expression controls the function creation behavior. eval_expression=true means that eval is used, so normal world-age behavior applies (i.e. the functions cannot be called from the function that generates them). If eval_expression=false, then construction via GeneralizedGenerated.jl is utilized to allow for same world-age evaluation. However, this can cause Julia to segfault on sufficiently large basis functions. By default eval_expression=false.\n\n\n\n\n\n","category":"type"},{"location":"optimization/#Sparse-Optimizers-1","page":"Sparse Optimization","title":"Sparse Optimizers","text":"","category":"section"},{"location":"optimization/#","page":"Sparse Optimization","title":"Sparse Optimization","text":"STLSQ\nADMM\nSR3\nImplicitOptimizer\nADM","category":"page"},{"location":"optimization/#DataDrivenDiffEq.Optimize.STLSQ","page":"Sparse Optimization","title":"DataDrivenDiffEq.Optimize.STLSQ","text":"mutable struct STLSQ{T} <: DataDrivenDiffEq.Optimize.AbstractOptimizer{T}\n\nSTLQS is taken from the original paper on SINDY and implements a sequentially thresholded least squares iteration. λ is the threshold of the iteration. It is based upon this matlab implementation. It solves the following problem\n\nargmin_x frac12  Ax-b_2 + lambda x_2\n\nFields\n\nλ\nSparsity threshold\n\nExample\n\nopt = STLQS()\nopt = STLQS(1e-1)\nopt = STLQS(Float32[1e-2; 1e-1])\n\nNote\n\nThis was formally STRRidge and has been renamed.\n\n\n\n\n\n","category":"type"},{"location":"optimization/#DataDrivenDiffEq.Optimize.ADMM","page":"Sparse Optimization","title":"DataDrivenDiffEq.Optimize.ADMM","text":"mutable struct ADMM{T, R} <: DataDrivenDiffEq.Optimize.AbstractOptimizer{T}\n\nADMM is an implementation of Lasso using the alternating direction methods of multipliers and loosely based on this implementation. It solves the following problem\n\nargmin_x frac12  Ax-b_2 + lambda x_1\n\nFields\n\nλ\nSparsity threshold\nρ\nAugmented Lagrangian parameter\n\nExample\n\nopt = ADMM()\nopt = ADMM(1e-1, 2.0)\n\n\n\n\n\n","category":"type"},{"location":"optimization/#DataDrivenDiffEq.Optimize.SR3","page":"Sparse Optimization","title":"DataDrivenDiffEq.Optimize.SR3","text":"mutable struct SR3{T, V, P<:DataDrivenDiffEq.Optimize.AbstractProximalOperator} <: DataDrivenDiffEq.Optimize.AbstractOptimizer{T}\n\nSR3 is an optimizer framework introduced by Zheng et. al., 2018 and used within Champion et. al., 2019. SR3 contains a sparsification parameter λ, a relaxation ν. It solves the following problem\n\nargmin_x w frac12  Ax-b_2 + lambda R(w) + fracnu2x-w_2\n\nWhere R is a proximal operator and the result is given by w.\n\nFields\n\nλ\nSparsity threshold\nν\nRelaxation parameter\nR\nProximal operator\n\nExample\n\nopt = SR3()\nopt = SR3(1e-2)\nopt = SR3(1e-3, 1.0)\nopt = SR3(1e-3, 1.0, SoftThreshold())\n\nNote\n\nOpposed to the original formulation, we use ν as a relaxation parameter, as given in Champion et. al., 2019. In the standard case of hard thresholding the sparsity is interpreted as λ = threshold^2 / 2, otherwise λ = threshold.\n\n\n\n\n\n","category":"type"},{"location":"optimization/#DataDrivenDiffEq.Optimize.ImplicitOptimizer","page":"Sparse Optimization","title":"DataDrivenDiffEq.Optimize.ImplicitOptimizer","text":"mutable struct ImplicitOptimizer{T} <: DataDrivenDiffEq.Optimize.AbstractSubspaceOptimizer{T}\n\nOptimizer for finding a sparse implicit relationship via alternating the left hand side of the problem and solving the explicit problem, as introduced here.\n\nargmin_x x_0 stAx= 0\n\nFields\n\no\nExplicit Optimizer\n\nExample\n\nADM()\nADM(λ = 0.1)\n\n\n\n\n\n","category":"type"},{"location":"optimization/#DataDrivenDiffEq.Optimize.ADM","page":"Sparse Optimization","title":"DataDrivenDiffEq.Optimize.ADM","text":"mutable struct ADM{T} <: DataDrivenDiffEq.Optimize.AbstractSubspaceOptimizer{T}\n\nOptimizer for finding a sparse basis vector in a subspace based on this paper. It solves the following problem\n\nargmin_x x_0 stAx= 0\n\nFields\n\nλ\nSparsity threshold\n\nExample\n\nADM()\nADM(λ = 0.1)\n\nNote\n\nWhile useable for implicit problems, a better choice in general is given by the ImplicitOptimizer which tends to be more robust.\n\n\n\n\n\n","category":"type"},{"location":"optimization/#Related-Functions-1","page":"Sparse Optimization","title":"Related Functions","text":"","category":"section"},{"location":"optimization/#","page":"Sparse Optimization","title":"Sparse Optimization","text":"sparse_regression!\nset_threshold!\nget_threshold","category":"page"},{"location":"optimization/#DataDrivenDiffEq.Optimize.sparse_regression!","page":"Sparse Optimization","title":"DataDrivenDiffEq.Optimize.sparse_regression!","text":"sparse_regression!(X, A, Y, opt; maxiter, abstol, progress, progress_outer, progress_offset, kwargs...)\n\n\nImplements a sparse regression, given an AbstractOptimizer or AbstractSubspaceOptimizer. maxiter indicate the maximum iterations for each call of the optimizer, abstol the absolute tolerance of the difference between iterations in the 2 norm. If the optimizer is called with a Vector of thresholds, each maxiter indicates the maximum iterations for each threshold.\n\nIf progress is set to true, a progressbar will be available.\n\n\n\n\n\n","category":"function"},{"location":"optimization/#DataDrivenDiffEq.Optimize.set_threshold!","page":"Sparse Optimization","title":"DataDrivenDiffEq.Optimize.set_threshold!","text":"set_threshold!(opt, threshold)\n\n\nSet the threshold(s) of an optimizer to (a) specific value(s).\n\n\n\n\n\n","category":"function"},{"location":"optimization/#DataDrivenDiffEq.Optimize.get_threshold","page":"Sparse Optimization","title":"DataDrivenDiffEq.Optimize.get_threshold","text":"get_threshold(opt)\n\n\nGet the threshold(s) of an optimizer.\n\n\n\n\n\n","category":"function"},{"location":"optimization/#Proximal-Operators-1","page":"Sparse Optimization","title":"Proximal Operators","text":"","category":"section"},{"location":"optimization/#","page":"Sparse Optimization","title":"Sparse Optimization","text":"SoftThreshold\nHardThreshold\nClippedAbsoluteDeviation","category":"page"},{"location":"optimization/#DataDrivenDiffEq.Optimize.SoftThreshold","page":"Sparse Optimization","title":"DataDrivenDiffEq.Optimize.SoftThreshold","text":"struct SoftThreshold <: DataDrivenDiffEq.Optimize.AbstractProximalOperator\n\nProximal operator which implements the soft thresholding operator.\n\nsign(x) * max(abs(x) - λ, 0)\n\nSee by Zheng et. al., 2018.\n\n\n\n\n\n","category":"type"},{"location":"optimization/#DataDrivenDiffEq.Optimize.HardThreshold","page":"Sparse Optimization","title":"DataDrivenDiffEq.Optimize.HardThreshold","text":"struct HardThreshold <: DataDrivenDiffEq.Optimize.AbstractProximalOperator\n\nProximal operator which implements the hard thresholding operator.\n\nabs(x) > sqrt(2*λ) ? x : 0\n\nSee by Zheng et. al., 2018.\n\n\n\n\n\n","category":"type"},{"location":"optimization/#DataDrivenDiffEq.Optimize.ClippedAbsoluteDeviation","page":"Sparse Optimization","title":"DataDrivenDiffEq.Optimize.ClippedAbsoluteDeviation","text":"struct ClippedAbsoluteDeviation{T} <: DataDrivenDiffEq.Optimize.AbstractProximalOperator\n\nProximal operator which implements the (smoothly) clipped absolute deviation operator.\n\nabs(x) > ρ ? x : sign(x) * max(abs(x) - λ, 0)\n\nWhere ρ = 5λ per default.\n\n#Fields\n\nρ\nUpper threshold\n\nExample\n\nopt = ClippedAbsoluteDeviation()\nopt = ClippedAbsoluteDeviation(1e-1)\n\nSee by Zheng et. al., 2018.\n\n\n\n\n\n","category":"type"},{"location":"quickstart/#Quickstart-1","page":"Getting Started","title":"Quickstart","text":"","category":"section"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"In the following, we will use some of the techniques provided by DataDrivenDiffEq to infer some models.","category":"page"},{"location":"quickstart/#Linear-Systems-via-Dynamic-Mode-Decomposition-1","page":"Getting Started","title":"Linear Systems via Dynamic Mode Decomposition","text":"","category":"section"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing ModelingToolkit\nusing OrdinaryDiffEq\n\nA = [0.9 -0.2; 0.0 0.2]\nu0 = [10.0; -10.0]\ntspan = (0.0, 11.0)\n\nf(u,p,t) = A*u\n\nsys = DiscreteProblem(f, u0, tspan)\nsol = solve(sys, FunctionMap())\n\nX = Array(sol)\n\nprob = DiscreteDataDrivenProblem(X, t = sol.t)\n\nres = solve(prob, DMDSVD(), digits = 1)\nsystem = result(res)\nprintln(system) # hide","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"Matrix(system)","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"res = solve(prob, DMDSVD(), digits = 1, operator_only = true)","category":"page"},{"location":"quickstart/#Nonlinear-System-with-Extended-Dynamic-Mode-Decomposition-1","page":"Getting Started","title":"Nonlinear System with Extended Dynamic Mode Decomposition","text":"","category":"section"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing ModelingToolkit\nusing Plots\nusing OrdinaryDiffEq\n\nfunction slow_manifold(du, u, p, t)\n    du[1] = p[1] * u[1]\n    du[2] = p[2] * (u[2] - u[1]^2)\nend\n\nu0 = [3.0; -2.0]\ntspan = (0.0, 5.0)\np = [-0.8; -0.7]\n\nproblem = ODEProblem(slow_manifold, u0, tspan, p)\nsolution = solve(problem, Tsit5(), saveat = 0.01)\nDX = solution(solution.t, Val{1})[:, :]\n\nprob = ContinuousDataDrivenProblem(solution[:, :], solution.t, DX = DX)\n@variables u[1:2]\nΨ = Basis([u; u[1]^2], u)\nres = solve(prob, Ψ, DMDPINV(), digits = 1)\nsystem = result(res)\nprintln(res) # hide\nprintln(system) # hide\nprintln(parameters(res)) # hide","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"The eigendecomposition of the Koopman operator can be accessed via operator.","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"operator(system)","category":"page"},{"location":"quickstart/#Nonlinear-Systems-Sparse-Identification-of-Nonlinear-Dynamics-1","page":"Getting Started","title":"Nonlinear Systems - Sparse Identification of Nonlinear Dynamics","text":"","category":"section"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"Assume you have a set of measurements and want to find the underlying continuous, nonlinear dynamical system. The answer is : Sparse Identification of Nonlinear Dynamics or SINDy.","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"As the name suggests, SINDy finds the sparsest basis of functions which build the observed trajectory. Again, we will start with a nonlinear system","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing ModelingToolkit\nusing Plots\nusing OrdinaryDiffEq\nusing Random\n\nRandom.seed!(1111) # Due to the noise\n\n# Create a nonlinear pendulum\nfunction pendulum(u, p, t)\n    x = u[2]\n    y = -9.81sin(u[1]) - 0.3u[2]^3 -3.0*cos(u[1]) - 10.0*exp(-((t-5.0)/5.0)^2)\n    return [x;y]\nend\n\nu0 = [0.99π; -1.0]\ntspan = (0.0, 15.0)\nprob = ODEProblem(pendulum, u0, tspan)\nsol = solve(prob, Tsit5(), saveat = 0.01)\n\n# Create the data with additional noise\nX = sol[:,:] + 0.1 .* randn(size(sol))\nDX = similar(sol[:,:])\n\nfor (i, xi) in enumerate(eachcol(sol[:,:]))\n    DX[:,i] = pendulum(xi, [], sol.t[i])\nend\n\nts = sol.t\nnothing #hide","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"To estimate the system, we first create a DataDrivenProblem via feeding in the measurement data. Using different collocation techniques, it automatically provides the derivative. Additional control signals can be passed in as a function (u,p,t)->control or an array of measurements.","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"prob = ContinuousDataDrivenProblem(X, ts, GaussianKernel() ,\n    U = (u,p,t)->[exp(-((t-5.0)/5.0)^2)], p = ones(2))\n\np1 = plot(ts, X', label = [\"Measurement\" nothing], color = :black, style = :dash, legend = :bottomleft, ylabel =\"Measurement\") # hide\nplot!(ts, prob.X', label = [\"Smoothed\" nothing], color = :red) # hide\np2 = plot(ts, prob.DX', label = nothing, color = :red, ylabel = \"Derivative\") # hide\nplot!(ts, DX', label = nothing, color = :black, style = :dash) # hide\np3 = plot(ts, prob.U', label = nothing, color = :red, xlabel = \"Time [s]\", ylabel = \"Control\") # hide\nplot(p1,p2,p3, layout = (3,1), size = (600,600)) # hide\nsavefig(\"SINDy_Example_Data.png\") # hide","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"Now we infer the systems structure. First we define a Basis which collects all possible candidate terms. Since we want to use SINDy, we call solve with an Optimizer, in this case STLSQ which iterates different sparsity thresholds and returns a pareto optimal solution. Note that we include the control signal in the basis as an additional variable c.","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"@variables u[1:2] c[1:1]\n@parameters w[1:2]\nh = Num[sin(w[1]*u[1]);cos(w[2]*u[1]); polynomial_basis(u, 5); c]\nbasis = Basis(h, u, parameters = w, controls = c)\nλs = exp10.(-10:0.1:-1)\nopt = STLSQ(λs)\nres = solve(prob, basis, opt, progress = false, denoise = false, normalize = false, maxiter = 5000)\nprintln(res) # hide","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"Where the resulting SparseIdentificationResult stores information about the infered model and the parameters:","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"system = result(res);\nparams = parameters(res);\nprintln(system) #hide\nprintln(params) #hide","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"which is indeed our pendulum model with a slight offset due to the noisy measurements and the estimation of the time derivates.","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"Since any system obtained via a solve command is a Basis and hence a subtype of an AbstractSystem defined in ModelingToolkit, we can simply simulate the result via:","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"infered_prob = ODEProblem(system, u0, tspan, parameters(res))\ninfered_solution = solve(infered_prob, Tsit5(), saveat = ts)\nplot(infered_solution, label = [\"Infered\" nothing], color = :red) # hide\n\nfunction pendulum(u, p, t) # hide\n    x = u[2] # hide\n    y = -9.81sin(u[1]) - 0.3u[2]^3 -3.0*cos(u[1]) # hide\n    return [x;y] # hide\nend # hide\n\nprob = ODEProblem(pendulum, u0, tspan) # hide\nsol = solve(prob, Tsit5(), saveat = 0.01) # hide\n\nplot!(sol, label = [\"Ground Truth\" nothing], color = :black, style = :dash) # hide\nsavefig(\"SINDy_Example_Data_Infered.png\") #hide","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"warning: Warning\nAs of now, the control input is dropped in the simulation of a system. We are working on this and pull requests are welcome!","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"As we can see above, the estimated system matches the ground truth reasonably well.","category":"page"},{"location":"quickstart/#Implicit-Nonlinear-Dynamics-1","page":"Getting Started","title":"Implicit Nonlinear Dynamics","text":"","category":"section"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing ModelingToolkit\nusing Plots\nusing OrdinaryDiffEq\n\nfunction michaelis_menten(u, p, t)\n    [0.6 - 1.5u[1]/(0.3+u[1])]\nend\n\nu0 = [0.5]\n\nproblem_1 = ODEProblem(michaelis_menten, u0, (0.0, 4.0))\nsolution_1 = solve(problem_1, Tsit5(), saveat = 0.1)\nproblem_2 = ODEProblem(michaelis_menten, 2*u0, (4.0, 8.0))\nsolution_2 = solve(problem_2, Tsit5(), saveat = 0.1)\nX = [solution_1[:,:] solution_2[:,:]]\nts = [solution_1.t; solution_2.t]\n\nDX = similar(X)\nfor (i, xi) in enumerate(eachcol(X))\n    DX[:, i] = michaelis_menten(xi, [], ts[i])\nend\n\np1 = plot(ts, X', label = [\"Measurement\" nothing], color = :black, style = :dash, legend = :bottomleft, ylabel =\"Measurement\") # hide\np2 = plot(ts, DX', label = nothing, color = :black, style = :dash, ylabel = \"Derivative\", xlabel = \"Time [s]\") # hide\nplot(p1,p2, layout = (2,1), size = (600,400)) # hide\nsavefig(\"SINDy_Example_Data_2.png\") # hide\n\n@parameters t\nD = Differential(t)\n@variables u[1:1](t)\nh = [monomial_basis(u[1:1], 4)...]\nbasis = Basis([h; h .* D(u[1])], [u; D(u[1])], iv = t)\nprintln(basis) # hide","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"prob = ContinuousDataDrivenProblem(X, ts, DX = DX)\n\nopt = ImplicitOptimizer(2e-1)\n\nres = solve(prob, basis, opt, normalize = false, denoise = false, maxiter = 1000);\nprintln(res) # hide","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"system = result(res); # hide\nprintln(system)","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"warning: Warning\nRight now, Implicit results cannot be simulated without further processing in ModelingToolkit","category":"page"},{"location":"contributions/#Contributions-1","page":"Contributions","title":"Contributions","text":"","category":"section"},{"location":"contributions/#","page":"Contributions","title":"Contributions","text":"Contributions are welcome! To help, please:","category":"page"},{"location":"contributions/#","page":"Contributions","title":"Contributions","text":"Open (or solve) an issue\nReview pull requests\nAdapt code to be more efficient\nWrite new optimizers or algorithms\nWrite tutorials or adapt the docs","category":"page"},{"location":"contributions/#","page":"Contributions","title":"Contributions","text":"Feel free to write a private message to @AlCap23 for further discussion.","category":"page"},{"location":"prob_and_solve/#Problem-Definition-And-Solution-1","page":"Problems And Solution","title":"Problem Definition And Solution","text":"","category":"section"},{"location":"prob_and_solve/#Types-1","page":"Problems And Solution","title":"Types","text":"","category":"section"},{"location":"prob_and_solve/#","page":"Problems And Solution","title":"Problems And Solution","text":"DataDrivenProblem\nDataDrivenSolution","category":"page"},{"location":"prob_and_solve/#DataDrivenDiffEq.DataDrivenProblem","page":"Problems And Solution","title":"DataDrivenDiffEq.DataDrivenProblem","text":"struct DataDrivenProblem{dType} <: DataDrivenDiffEq.AbstractDataDrivenProblem\n\nThe DataDrivenProblem defines a general estimation problem given measurements, inputs and (in the near future) observations. Two construction methods are available:\n\nDiscreteDataDrivenProblem for time discrete systems\nContinousDataDrivenProblem for systems continouos in time\n\nboth are aliases for constructing a problem.\n\nFields\n\nX\nState measurements\nt\nTime measurements (optional)\nDX\nDifferental state measurements (optional) or measurements of the next state\nY\nOutput measurements (optional; not used right now)\nU\nInput measurements (optional)\np\nParameters associated with the problem (optional)\nis_discrete\n(Time) discrete problem\n\nSignatures\n\nExample\n\nX, DX, t = data...\n\n# Define a discrete time problem\nprob = DiscreteDataDrivenProblem(X)\n\n# Define a continous time problem without explicit time points\nprob = ContinuousDataDrivenProblem(X, DX)\n\n# Define a continous time problem without explict derivatives\nprob = ContinuousDataDrivenProblem(X, t)\n\n# Define a discrete time problem with an input function as a function\ninput_signal(u,p,t) = t^2\nprob = DiscreteDataDrivenProblem(X, t, input_signal)\n\n\n\n\n\n","category":"type"},{"location":"prob_and_solve/#DataDrivenDiffEq.DataDrivenSolution","page":"Problems And Solution","title":"DataDrivenDiffEq.DataDrivenSolution","text":"struct DataDrivenSolution{R<:DataDrivenDiffEq.AbstractBasis, S, P, A, O, M} <: DataDrivenDiffEq.AbstractDataDrivenSolution\n\nThe solution to a DataDrivenProblem derived via a certain algorithm. The solution is represented via an AbstractBasis, which makes it callable.\n\nFields\n\nres\nResult\nretcode\nReturncode\nps\nParameters used to derive the equations\nalg\nAlgorithm used for solution\nout\nOriginal Output\ninp\nOriginal Input\nmetrics\nError metrics\n\n\n\n\n\n","category":"type"},{"location":"#DataDrivenDiffEq.jl-1","page":"Home","title":"DataDrivenDiffEq.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"DataDrivenDiffEq.jl is a package for estimating equation-free and equation-based models for discrete and continuous differential equations.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"As opposed to parameter identification, these methods aim to find the governing equations of motion automatically from a given set of data. They do not require a known model as input. Instead, these methods take in data and return the differential equation model which generated the data.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"There are various avenues in which structural estimation can occur. However, the main branches are: do you want to know the equations in a human-understandable manner, or is it sufficient to have a function that predicts the derivative and generates the correct time series? We will refer to methods which return symbolic forms of the differential equation as structural identification, while those which return functions only for prediction as structural estimation.","category":"page"},{"location":"#Package-Overview-1","page":"Home","title":"Package Overview","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"DataDrivenDiffEq currently implements the following algorithms for structural estimation:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Dynamic Mode Decomposition\nExtended Dynamic Mode Decomposition\nSparse Identification of Nonlinear Dynamics\nImplicit Sparse Identification of Nonlinear Dynamics","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"To use 'DataDrivenDiffEq.jl', simply install it via:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"]add DataDrivenDiffEq\nusing DataDrivenDiffEq","category":"page"},{"location":"koopman/#Koopman-1","page":"Koopman","title":"Koopman","text":"","category":"section"},{"location":"koopman/#","page":"Koopman","title":"Koopman","text":"Koopman","category":"page"},{"location":"koopman/#DataDrivenDiffEq.Koopman","page":"Koopman","title":"DataDrivenDiffEq.Koopman","text":"mutable struct Koopman{O, M, G, T} <: DataDrivenDiffEq.AbstractKoopman\n\nA special basis over the states with parameters , independent variable  and possible exogenous controls. It extends an AbstractBasis, which also stores information about the lifted dynamics, specified by a sufficient matrix factorization, an output mapping and internal variables to update the equations. It can be called with the typical SciML signature, meaning out of place with f(u,p,t) or in place with f(du, u, p, t). If control inputs are present, it is assumed that no control corresponds to zero for all inputs. The corresponding function calls are f(u,p,t,inputs) and f(du,u,p,t,inputs) and need to be specified fully.\n\nIf linear_independent is set to true, a linear independent basis is created from all atom function in f.\n\nIf simplify_eqs is set to true, simplify is called on f.\n\nAdditional keyworded arguments include name, which can be used to name the basis, and observed for defining observeables.\n\nFields\n\neqs\nThe equations of the basis\nstates\nDependent (state) variables\ncontrols\nControl variables\nps\nParameters\nobserved\nObserved\niv\nIndependent variable\nf\nInternal function representation of the basis\nlift\nAssociated lifting of the operator\nname\nName of the basis\nsystems\nInternal systems\nis_discrete\nDiscrete or time continuous\nK\nThe operator/generator of the dynamics\nC\nMapping back onto the observed states\nQ\nInternal matrix Q used for updating\nP\nInternal matrix P used for updating\n\nNote\n\nThe keyword argument eval_expression controls the function creation behavior. eval_expression=true means that eval is used, so normal world-age behavior applies (i.e. the functions cannot be called from the function that generates them). If eval_expression=false, then construction via GeneralizedGenerated.jl is utilized to allow for same world-age evaluation. However, this can cause Julia to segfault on sufficiently large basis functions. By default eval_expression=false.\n\n\n\n\n\n","category":"type"},{"location":"koopman/#Functions-1","page":"Koopman","title":"Functions","text":"","category":"section"},{"location":"koopman/#","page":"Koopman","title":"Koopman","text":"is_discrete\nis_continuous\nDataDrivenDiffEq.eigen\nDataDrivenDiffEq.eigvals\nDataDrivenDiffEq.eigvecs\nmodes\nfrequencies\noperator\ngenerator\nupdatable\nis_stable\nupdate!","category":"page"},{"location":"koopman/#DataDrivenDiffEq.is_discrete","page":"Koopman","title":"DataDrivenDiffEq.is_discrete","text":"is_discrete(k)\n\n\nReturns if the AbstractKoopmanOperator k is discrete in time.\n\n\n\n\n\n","category":"function"},{"location":"koopman/#DataDrivenDiffEq.is_continuous","page":"Koopman","title":"DataDrivenDiffEq.is_continuous","text":"is_continuous(k)\n\n\nReturns if the AbstractKoopmanOperator k is continuous in time.\n\n\n\n\n\n","category":"function"},{"location":"koopman/#LinearAlgebra.eigen","page":"Koopman","title":"LinearAlgebra.eigen","text":"eigen(k)\n\n\nReturn the eigendecomposition of the AbstractKoopmanOperator.\n\n\n\n\n\n","category":"function"},{"location":"koopman/#LinearAlgebra.eigvals","page":"Koopman","title":"LinearAlgebra.eigvals","text":"eigvals(k)\n\n\nReturn the eigenvalues of the AbstractKoopmanOperator.\n\n\n\n\n\n","category":"function"},{"location":"koopman/#LinearAlgebra.eigvecs","page":"Koopman","title":"LinearAlgebra.eigvecs","text":"eigvecs(k)\n\n\nReturn the eigenvectors of the AbstractKoopmanOperator.\n\n\n\n\n\n","category":"function"},{"location":"koopman/#DataDrivenDiffEq.modes","page":"Koopman","title":"DataDrivenDiffEq.modes","text":"modes(k)\n\n\nReturn the eigenvectors of a continuous AbstractKoopmanOperator.\n\n\n\n\n\n","category":"function"},{"location":"koopman/#DataDrivenDiffEq.frequencies","page":"Koopman","title":"DataDrivenDiffEq.frequencies","text":"frequencies(k)\n\n\nReturn the eigenvalues of a continuous AbstractKoopmanOperator.\n\n\n\n\n\n","category":"function"},{"location":"koopman/#DataDrivenDiffEq.operator","page":"Koopman","title":"DataDrivenDiffEq.operator","text":"operator(k)\n\n\nReturn the approximation of the discrete Koopman operator stored in k.\n\n\n\n\n\n","category":"function"},{"location":"koopman/#DataDrivenDiffEq.generator","page":"Koopman","title":"DataDrivenDiffEq.generator","text":"generator(k)\n\n\nReturn the approximation of the continuous Koopman generator stored in k.\n\n\n\n\n\n","category":"function"},{"location":"koopman/#DataDrivenDiffEq.updatable","page":"Koopman","title":"DataDrivenDiffEq.updatable","text":"updatable(k)\n\n\nReturns true if the AbstractKoopmanOperator is updatable.\n\n\n\n\n\n","category":"function"},{"location":"koopman/#DataDrivenDiffEq.is_stable","page":"Koopman","title":"DataDrivenDiffEq.is_stable","text":"is_stable(k)\n\n\nReturns true if either:\n\nthe Koopman operator has just eigenvalues with magnitude less than one or\nthe Koopman generator has just eigenvalues with a negative real part\n\n\n\n\n\n","category":"function"},{"location":"koopman/#DataDrivenDiffEq.update!","page":"Koopman","title":"DataDrivenDiffEq.update!","text":"update!(k, X, Y; p, t, U, threshold)\n\n\nUpdate the Koopman k given new data X and Y. The operator is updated in place if the L2 error of the prediction exceeds the threshold.\n\np and t are the parameters of the basis and the vector of timepoints, if necessary.\n\n\n\n\n\n","category":"function"},{"location":"koopman/#Algortihms-1","page":"Koopman","title":"Algortihms","text":"","category":"section"},{"location":"koopman/#","page":"Koopman","title":"Koopman","text":"DMDPINV\nDMDSVD\nTOTALDMD","category":"page"},{"location":"koopman/#DataDrivenDiffEq.DMDPINV","page":"Koopman","title":"DataDrivenDiffEq.DMDPINV","text":"mutable struct DMDPINV <: DataDrivenDiffEq.AbstractKoopmanAlgorithm\n\nApproximates the Koopman operator K based on\n\nK = Y / X\n\nwhere Y and X are data matrices. Returns a  Eigen factorization of the operator.\n\nFields\n\nSignatures\n\n\n\n\n\n","category":"type"},{"location":"koopman/#DataDrivenDiffEq.DMDSVD","page":"Koopman","title":"DataDrivenDiffEq.DMDSVD","text":"mutable struct DMDSVD{T} <: DataDrivenDiffEq.AbstractKoopmanAlgorithm\n\nApproximates the Koopman operator K based on the singular value decomposition of X such that:\n\nK = Y*V*Σ*U'\n\nwhere Y and X = U*Σ*V' are data matrices. The singular value decomposition is truncated via the truncation parameter, which can either be an Int indiciating an index based truncation or a Real indiciating a tolerance based truncation. Returns a Eigen factorization of the operator.\n\nFields\n\ntruncation\nIndiciates the truncation\n\nSignatures\n\n\n\n\n\n","category":"type"},{"location":"koopman/#DataDrivenDiffEq.TOTALDMD","page":"Koopman","title":"DataDrivenDiffEq.TOTALDMD","text":"mutable struct TOTALDMD{R, A} <: DataDrivenDiffEq.AbstractKoopmanAlgorithm\n\nApproximates the Koopman operator K with the algorithm alg over the rank-reduced data matrices Xᵣ = X Qᵣ and Yᵣ = Y Qᵣ, where Qᵣ originates from the singular value decomposition of the joint data Z = [X; Y]. Based on this paper.\n\nIf rtol ∈ (0, 1) is given, the singular value decomposition is reduced to include only entries bigger than rtol*maximum(Σ). If rtol is an integer, the reduced SVD up to rtol is used for computation.\n\nFields\n\ntruncation\nalg\n\nSignatures\n\n\n\n\n\n","category":"type"},{"location":"utils/#Collocation-1","page":"Utilities","title":"Collocation","text":"","category":"section"},{"location":"utils/#","page":"Utilities","title":"Utilities","text":"InterpolationMethod\ncollocate_data","category":"page"},{"location":"utils/#DataDrivenDiffEq.InterpolationMethod","page":"Utilities","title":"DataDrivenDiffEq.InterpolationMethod","text":"A wrapper for the interpolation methods of DataInterpolations.jl.\n\nWraps the methods in such a way that they are callable as f(u,t) to create and return an interpolation of u over t. The first argument of the constructor always defines the interpolation method, all following arguments will be used in the interpolation.\n\nExample\n\n# Create the wrapper struct\nitp_method = InterpolationMethod(QuadraticSpline)\n# Create a callable interpolation\nitp = itp_method(u,t)\n# Return u[2]\nitp(t[2])\n\n\n\n\n\n","category":"type"},{"location":"utils/#DataDrivenDiffEq.collocate_data","page":"Utilities","title":"DataDrivenDiffEq.collocate_data","text":"collocate_data(data, tpoints)\ncollocate_data(data, tpoints, kernel)\n\n\nUnified interface for collocation techniques. The input can either be a CollocationKernel (see list below) or a wrapped InterpolationMethod from DataInterpolations.jl.\n\nComputes a non-parametrically smoothed estimate of u' and u given the data, where each column is a snapshot of the timeseries at tpoints[i].\n\nExamples\n\nu′,u = collocate_data(data,tpoints,kernel=SigmoidKernel())\nu′,u = collocate_data(data,tpoints,tpoints_sample,interp,args...)\nu′,u = collocate_data(data,tpoints,interp)\n\nCollocation Kernels\n\nSee this paper for more information.\n\nEpanechnikovKernel\nUniformKernel\nTriangularKernel\nQuarticKernel\nTriweightKernel\nTricubeKernel\nGaussianKernel\nCosineKernel\nLogisticKernel\nSigmoidKernel\nSilvermanKernel\n\nInterpolation Methods\n\nSee DataInterpolations.jl for more information.\n\nConstantInterpolation\nLinearInterpolation\nQuadraticInterpolation\nLagrangeInterpolation\nQuadraticSpline\nCubicSpline\nBSplineInterpolation\nBSplineApprox\nCurvefit\n\n\n\n\n\n","category":"function"},{"location":"utils/#Utilities-1","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utils/#","page":"Utilities","title":"Utilities","text":"AIC\nAICC\nBIC\noptimal_shrinkage\noptimal_shrinkage!\nburst_sampling\nsubsample","category":"page"},{"location":"utils/#DataDrivenDiffEq.AIC","page":"Utilities","title":"DataDrivenDiffEq.AIC","text":"AIC(k, X, Y; likelihood)\n\n\nComputes the Akaike Information Criterion (AIC) given the free parameters k for the data X and its estimate Y of the model. likelihood can be any function of X and Y.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DataDrivenDiffEq.AICC","page":"Utilities","title":"DataDrivenDiffEq.AICC","text":"AICC(k, X, Y; likelihood)\n\n\nComputes the Akaike Information Criterion compensated for finite samples (AICC) given the free parameters k for the data X and its estimate Y of the model. likelihood can be any function of X and Y.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DataDrivenDiffEq.BIC","page":"Utilities","title":"DataDrivenDiffEq.BIC","text":"BIC(k, X, Y; likelihood)\n\n\nComputes Bayes Information Criterion (BIC) given the free parameters k for the data X and its estimate Y of the model. likelihood can be any function of X and Y.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DataDrivenDiffEq.optimal_shrinkage","page":"Utilities","title":"DataDrivenDiffEq.optimal_shrinkage","text":"optimal_shrinkage(X)\n\n\nCompute a feature reduced version of the data array X via thresholding the singular values by computing the optimal threshold for singular values.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DataDrivenDiffEq.burst_sampling","page":"Utilities","title":"DataDrivenDiffEq.burst_sampling","text":"(\n\nburst_sampling(x, samplesize, bursts)\n\n\n)\n\nRandomly selects n bursts of data with size samplesize from the data X.\n\nRandomly selects n bursts of data with size samplesize from the data X and Y.\n\nRandomly selects n bursts of data within a time window period from the data X. The time information has to be provided in t.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DataDrivenDiffEq.subsample","page":"Utilities","title":"DataDrivenDiffEq.subsample","text":"subsample(x, frequency)\n\n\nReturns the subsampled X with only every n-th entry.\n\nReturns the subsampled X with a a minimum period of dt between two data points. t provides the time information.\n\n\n\n\n\n","category":"function"}]
}
