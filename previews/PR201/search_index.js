var documenterSearchIndex = {"docs":
[{"location":"koopman/dmdc/#Dynamic-Mode-Decomposition-with-control-1","page":"Dynamic Mode Decomposition with control","title":"Dynamic Mode Decomposition with control","text":"","category":"section"},{"location":"koopman/dmdc/#","page":"Dynamic Mode Decomposition with control","title":"Dynamic Mode Decomposition with control","text":"Dynamic Mode Decomposition with Control is a method for generating an approximating linear differential equation in a chosen basis of observables. If X and Y are data matrices containing points of the same trajectory and U containing the exogenous inputs acting on that trajectory, then DMDc approximates","category":"page"},{"location":"koopman/dmdc/#","page":"Dynamic Mode Decomposition with control","title":"Dynamic Mode Decomposition with control","text":"G = Yleft beginarrayc X  U endarray right^dagger = leftK B right","category":"page"},{"location":"koopman/dmdc/#","page":"Dynamic Mode Decomposition with control","title":"Dynamic Mode Decomposition with control","text":"where dagger denotes the Moore-Penrose pseudoinverse and K is the approximation of the Koopman Operator and B the linear input map.","category":"page"},{"location":"koopman/dmdc/#","page":"Dynamic Mode Decomposition with control","title":"Dynamic Mode Decomposition with control","text":"DMDc approximates discrete time systems with inputs z of the form","category":"page"},{"location":"koopman/dmdc/#","page":"Dynamic Mode Decomposition with control","title":"Dynamic Mode Decomposition with control","text":"u_i+1 = K  u_i + B  z_i","category":"page"},{"location":"koopman/dmdc/#","page":"Dynamic Mode Decomposition with control","title":"Dynamic Mode Decomposition with control","text":"gDMDc approximates continuous time systems with inputs z of the form","category":"page"},{"location":"koopman/dmdc/#","page":"Dynamic Mode Decomposition with control","title":"Dynamic Mode Decomposition with control","text":"fracddtu =  K_G  u + B  z","category":"page"},{"location":"koopman/dmdc/#","page":"Dynamic Mode Decomposition with control","title":"Dynamic Mode Decomposition with control","text":"where K_G is the generator of the Koopman Operator.","category":"page"},{"location":"koopman/dmdc/#Functions-1","page":"Dynamic Mode Decomposition with control","title":"Functions","text":"","category":"section"},{"location":"koopman/dmdc/#","page":"Dynamic Mode Decomposition with control","title":"Dynamic Mode Decomposition with control","text":"DMDc\ngDMDc","category":"page"},{"location":"contributions/#Contributions-1","page":"Contributions","title":"Contributions","text":"","category":"section"},{"location":"contributions/#","page":"Contributions","title":"Contributions","text":"Contributions are welcome! To help, please:","category":"page"},{"location":"contributions/#","page":"Contributions","title":"Contributions","text":"Open (or solve) an issue\nReview pull requests\nAdapt code to be more efficient\nWrite new optimizers or algorithms\nWrite tutorials or adapt the docs","category":"page"},{"location":"contributions/#","page":"Contributions","title":"Contributions","text":"Feel free to write a private message to @AlCap23 for further discussion.","category":"page"},{"location":"koopman/dmd/#Dynamic-Mode-Decomposition-1","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"","category":"section"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"The (Exact) Dynamic Mode Decomposition is a method for generating an approximating linear differential equation directly from the observed data. If X and Y are data matrices containing points of the same trajectory, than DMD approximates","category":"page"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"K = YX^dagger","category":"page"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"where dagger denotes the Moore-Penrose pseudoinverse and K is the approximation of the Koopman Operator.","category":"page"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"DMD approximates discrete time systems of the form","category":"page"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"u_i+1 = K  u_i","category":"page"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"gDMD approximates continuous time systems of the form","category":"page"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"fracddtu =  K_G  u","category":"page"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"where K_G is the generator of the Koopman Operator.","category":"page"},{"location":"koopman/dmd/#Functions-1","page":"Dynamic Mode Decomposition","title":"Functions","text":"","category":"section"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"DMD\ngDMD","category":"page"},{"location":"koopman/dmd/#Examples-1","page":"Dynamic Mode Decomposition","title":"Examples","text":"","category":"section"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"using DataDrivenDiffEq\nusing OrdinaryDiffEq\nusing LinearAlgebra\nusing Plots\ngr()\n\nfunction linear_discrete(du, u, p, t)\n    du[1] = 0.9u[1]\n    du[2] = 0.05u[2] + 0.1u[1]\nend\n\nu0 = [10.0; -2.0]\ntspan = (0.0, 20.0)\nproblem = DiscreteProblem(linear_discrete, u0, tspan)\nsolution = solve(problem, FunctionMap())","category":"page"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"X = Array(solution)\n\napprox = DMD(X[:,1:3])\n\nprob_approx = DiscreteProblem(approx, u0, tspan)\napprox_sol = solve(prob_approx, FunctionMap())\n\nplot(approx_sol, label = [\"u[1]\" \"u[2]\"]) #hide\nplot!(solution, label = [\"True u[1]\" \"True u[2]\"]) #hide\nsavefig(\"dmd_example_1.png\") #hide","category":"page"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"(Image: )","category":"page"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"\nfunction linear_discrete_2(du, u, p, t)\n    du[1] = 0.9u[1] + 0.05u[2]\n    du[2] = 0.1u[1]\nend\n\nproblem = DiscreteProblem(linear_discrete_2, u0, tspan)\nsolution = solve(problem, FunctionMap())\n\nX = Array(solution)\n\nupdate!(approx, X[:, 4:end-1], X[:, 5:end])\n\nprob_approx = DiscreteProblem(approx, u0, tspan)\napprox_sol = solve(prob_approx, FunctionMap())\n\n# Show solutions\nplot(approx_sol, label = [\"u[1]\" \"u[2]\"]) #hide\nplot!(solution, label = [\"True u[1]\" \"True u[2]\"]) #hide\nsavefig(\"dmd_example_2.png\") #hide","category":"page"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"(Image: )","category":"page"},{"location":"koopman/algorithms/#Algorithms-for-Estimation-1","page":"Algorithms for Estimation","title":"Algorithms for Estimation","text":"","category":"section"},{"location":"koopman/algorithms/#","page":"Algorithms for Estimation","title":"Algorithms for Estimation","text":"There are different variants of estimation of the Koopman Operator, see e.g., here, here or here.","category":"page"},{"location":"koopman/algorithms/#","page":"Algorithms for Estimation","title":"Algorithms for Estimation","text":"Currently, DataDrivenDiffEq implements the following AbstractKoopmanAlgorithms to use with DMD, EDMD, and DMDc.","category":"page"},{"location":"koopman/algorithms/#Functions-1","page":"Algorithms for Estimation","title":"Functions","text":"","category":"section"},{"location":"koopman/algorithms/#","page":"Algorithms for Estimation","title":"Algorithms for Estimation","text":"DMDPINV\nDMDSVD\nTOTALDMD","category":"page"},{"location":"koopman/algorithms/#DataDrivenDiffEq.DMDPINV","page":"Algorithms for Estimation","title":"DataDrivenDiffEq.DMDPINV","text":"mutable struct DMDPINV <: DataDrivenDiffEq.AbstractKoopmanAlgorithm\n\nApproximates the Koopman operator K based on\n\nK = Y / X\n\nwhere Y and X are data matrices. Returns a  Eigen factorization of the operator.\n\nFields\n\nSignatures\n\n\n\n\n\n","category":"type"},{"location":"koopman/algorithms/#DataDrivenDiffEq.DMDSVD","page":"Algorithms for Estimation","title":"DataDrivenDiffEq.DMDSVD","text":"mutable struct DMDSVD{T} <: DataDrivenDiffEq.AbstractKoopmanAlgorithm\n\nApproximates the Koopman operator K based on the singular value decomposition of X such that:\n\nK = Y*V*Σ*U'\n\nwhere Y and X = U*Σ*V' are data matrices. The singular value decomposition is truncated via the truncation parameter, which can either be an Int indiciating an index based truncation or a Real indiciating a tolerance based truncation. Returns a Eigen factorization of the operator.\n\nFields\n\ntruncation\nIndiciates the truncation\n\nSignatures\n\n\n\n\n\n","category":"type"},{"location":"koopman/algorithms/#DataDrivenDiffEq.TOTALDMD","page":"Algorithms for Estimation","title":"DataDrivenDiffEq.TOTALDMD","text":"mutable struct TOTALDMD{R, A} <: DataDrivenDiffEq.AbstractKoopmanAlgorithm\n\nApproximates the Koopman operator K with the algorithm alg over the rank-reduced data matrices Xᵣ = X Qᵣ and Yᵣ = Y Qᵣ, where Qᵣ originates from the singular value decomposition of the joint data Z = [X; Y]. Based on this paper.\n\nIf rtol ∈ (0, 1) is given, the singular value decomposition is reduced to include only entries bigger than rtol*maximum(Σ). If rtol is an integer, the reduced SVD up to rtol is used for computation.\n\nFields\n\ntruncation\nalg\n\nSignatures\n\n\n\n\n\n","category":"type"},{"location":"koopman/algorithms/#Implementing-New-Algorithms-1","page":"Algorithms for Estimation","title":"Implementing New Algorithms","text":"","category":"section"},{"location":"koopman/algorithms/#","page":"Algorithms for Estimation","title":"Algorithms for Estimation","text":"Is pretty straightforward. The implementation of DMDPINV looks like:","category":"page"},{"location":"koopman/algorithms/#","page":"Algorithms for Estimation","title":"Algorithms for Estimation","text":"\nmutable struct DMDPINV <: AbstractKoopmanAlgorithm end;\n\n(x::DMDPINV)(X::AbstractArray, Y::AbstractArray) = Y / X\n","category":"page"},{"location":"koopman/algorithms/#","page":"Algorithms for Estimation","title":"Algorithms for Estimation","text":"So, right now, all you have to do is to implement a struct which is callable with the data matrices X and Y. Possible Parameters should be stored in the fields of the algorithm.","category":"page"},{"location":"basis/#Basis-1","page":"-","title":"Basis","text":"","category":"section"},{"location":"basis/#","page":"-","title":"-","text":"Many of the methods require the definition of a Basis on observables or functional forms. A Basis is generated via:","category":"page"},{"location":"basis/#","page":"-","title":"-","text":"Basis(eqs::AbstractVector, states::AbstractVector; \n    parameters::AbstractArray = [], iv = nothing,\n    simplify = false, linear_independent = false, name = gensym(:Basis), \n    pins = [], observed = [], eval_expression = false,\n    kwargs...)","category":"page"},{"location":"basis/#","page":"-","title":"-","text":"where eqs is either a vector containing symbolic functions using 'ModelingToolkit.jl' or a general function with the typical DiffEq signature h(u,p,t), which can be used with an Num or vector of Num. states are the dependent variables used to describe the Basis, and parameters are the optional parameters in the Basis. iv represents the independent variable of the system - in most cases the time. Additional arguments are simplify, which simplifies eqs before creating a Basis. linear_dependent breaks up eqs in linear independent elements which are unique. name is an optional name for the Basis, pins and observed can be using in accordance to ModelingToolkits documentation. eval_expression is used to generate a callable function from the eqs. If set to false, callable code will be returned. true will use eval on code returned from the function, which might cause worldage issues. ","category":"page"},{"location":"basis/#","page":"-","title":"-","text":"Basis","category":"page"},{"location":"basis/#DataDrivenDiffEq.Basis","page":"-","title":"DataDrivenDiffEq.Basis","text":"mutable struct Basis <: DataDrivenDiffEq.AbstractBasis\n\nA basis over the states with parameters , independent variable  and possible exogenous controls. It extends an AbstractSystem as defined in ModelingToolkit.jl. f can either be a Julia function which is able to use ModelingToolkit variables or a vector of eqs. It can be called with the typical SciML signature, meaning out of place with f(u,p,t) or in place with f(du, u, p, t). If control inputs are present, it is assumed that no control corresponds to zero for all inputs. The corresponding function calls are f(u,p,t,inputs) and f(du,u,p,t,inputs) and need to be specified fully.\n\nIf linear_independent is set to true, a linear independent basis is created from all atom function in f.\n\nIf simplify_eqs is set to true, simplify is called on f.\n\nAdditional keyworded arguments include name, which can be used to name the basis, and observed for defining observeables.\n\nFields\n\neqs\nThe equations of the basis\nstates\nDependent (state) variables\ncontrols\nControl variables\nps\nParameters\nobserved\nObserved\niv\nIndependent variable\nf\nInternal function representation of the basis\nname\nName of the basis\nsystems\nInternal systems\n\nExample\n\nusing ModelingToolkit\nusing DataDrivenDiffEq\n\n@parameters w[1:2] t\n@variables u[1:2](t)\n\nΨ = Basis([u; sin.(w.*u)], u, parameters = p, iv = t)\n\nNote\n\nThe keyword argument eval_expression controls the function creation behavior. eval_expression=true means that eval is used, so normal world-age behavior applies (i.e. the functions cannot be called from the function that generates them). If eval_expression=false, then construction via GeneralizedGenerated.jl is utilized to allow for same world-age evaluation. However, this can cause Julia to segfault on sufficiently large basis functions. By default eval_expression=false.\n\n\n\n\n\n","category":"type"},{"location":"basis/#Example-1","page":"-","title":"Example","text":"","category":"section"},{"location":"basis/#","page":"-","title":"-","text":"We start by crearting some variables and parameters using ModelingToolkit.","category":"page"},{"location":"basis/#","page":"-","title":"-","text":"using LinearAlgebra\nusing DataDrivenDiffEq\nusing Plots\nusing ModelingToolkit\n\n@variables u[1:3]\n@parameters w[1:2]","category":"page"},{"location":"basis/#","page":"-","title":"-","text":"To define a basis, simply write down the equations you want to be included as a Vector. Possible used parameters have to be given to the constructor.","category":"page"},{"location":"basis/#","page":"-","title":"-","text":"h = [u[1]; u[2]; cos(w[1]*u[2]+w[2]*u[3])]\nb = Basis(h, u, parameters = w)","category":"page"},{"location":"basis/#","page":"-","title":"-","text":"Basis are callable with the signature of functions to be used in DifferentialEquations. So, the function value at a single point looks like:","category":"page"},{"location":"basis/#","page":"-","title":"-","text":"x = b([1;2;3])","category":"page"},{"location":"basis/#","page":"-","title":"-","text":"Or, in place","category":"page"},{"location":"basis/#","page":"-","title":"-","text":"dx = similar(x)\nb(dx, [1;2;3])","category":"page"},{"location":"basis/#","page":"-","title":"-","text":"Notice that since we did not use any numerical values for the parameters, the basis uses the symbolic values in the result.","category":"page"},{"location":"basis/#","page":"-","title":"-","text":"To use numerical values, simply pass this on in the function call. Here, we evaluate over a trajectory with two parameters and 40 timestamps.","category":"page"},{"location":"basis/#","page":"-","title":"-","text":"X = randn(3, 40)\nY = b(X, [2;4], 0:39)\nnothing # hide","category":"page"},{"location":"basis/#","page":"-","title":"-","text":"Suppose we want to add another equation, say sin(u[1]). A Basis behaves like an array, so we can simply","category":"page"},{"location":"basis/#","page":"-","title":"-","text":"push!(b, sin(u[1]))\nsize(b)","category":"page"},{"location":"basis/#","page":"-","title":"-","text":"To ensure that a basis is well-behaved, functions already present are not included again.","category":"page"},{"location":"basis/#","page":"-","title":"-","text":"push!(b, sin(u[1]))\nsize(b)","category":"page"},{"location":"basis/#","page":"-","title":"-","text":"We can also define functions of the independent variable and add them","category":"page"},{"location":"basis/#","page":"-","title":"-","text":"t = independent_variable(b)\npush!(b, cos(t*π))\nprintln(b)","category":"page"},{"location":"basis/#","page":"-","title":"-","text":"Additionally, we can iterate over a Basis using [eq for eq in basis] or index specific equations, like basis[2].","category":"page"},{"location":"basis/#","page":"-","title":"-","text":"We can also chain Basis via just using it in the constructor","category":"page"},{"location":"basis/#","page":"-","title":"-","text":"@variables x[1:2]\ny = [sin(x[1]); cos(x[1]); x[2]]\nt = independent_variable(b)\nb2 = Basis(b(y, parameters(b), t), x, parameters = w, iv = t)\nprintln(b2)","category":"page"},{"location":"basis/#","page":"-","title":"-","text":"You can also use merge to create the union of two Basis:","category":"page"},{"location":"basis/#","page":"-","title":"-","text":"b3 = merge(b, b2)\nprintln(b3)","category":"page"},{"location":"basis/#","page":"-","title":"-","text":"which combines all the used variables and parameters ( and assumes the same independent_variable ):","category":"page"},{"location":"basis/#","page":"-","title":"-","text":"variables(b)","category":"page"},{"location":"basis/#","page":"-","title":"-","text":"parameters(b)","category":"page"},{"location":"basis/#","page":"-","title":"-","text":"If you have a function already defined as pure code, you can use this also to create a Basis. Only the signature has to be consistent, so use f(u,p,t).","category":"page"},{"location":"basis/#","page":"-","title":"-","text":"f(u, p, t) = [u[1]; u[2]; cos(p[1]*u[2]+p[2]*u[3])]\nb_f = Basis(f, u, parameters = w)\nprintln(b_f)","category":"page"},{"location":"basis/#","page":"-","title":"-","text":"This works for every function defined over Nums. So to create a Basis from a Flux model, simply extend the activations used:","category":"page"},{"location":"basis/#","page":"-","title":"-","text":"using Flux\nNNlib.σ(x::Num) = 1 / (1+exp(-x))\n\nc = Chain(Dense(3,2,σ), Dense(2, 1, σ))\nps, re = Flux.destructure(c)\n\n@parameters p[1:length(ps)]\n\ng(u, p, t) = re(p)(u)\nb = Basis(g, u, parameters = p)","category":"page"},{"location":"basis/#Functions-1","page":"-","title":"Functions","text":"","category":"section"},{"location":"basis/#","page":"-","title":"-","text":"jacobian\ndynamics\npush!\ndeleteat!\nmerge\nmerge!","category":"page"},{"location":"basis/#DataDrivenDiffEq.jacobian","page":"-","title":"DataDrivenDiffEq.jacobian","text":"jacobian(basis)\n\nReturns a function representing the jacobian matrix / gradient of the `Basis` with respect to the\ndependent variables as a function with the common signature `f(u,p,t)` for out of place and `f(du, u, p, t)` for in place computation.\nIf control variables are defined, the function can also be called by `f(u,p,t,control)` or `f(du,u,p,t,control)` and assumes `control .= 0` if no control is given.\n\n\n\n\n\n","category":"function"},{"location":"basis/#Base.push!","page":"-","title":"Base.push!","text":"push!(basis, eq, simplify_eqs = true; eval_expression = false)\n\nPush the equations(s) in `eq` into the basis and update all internal fields accordingly.\n`eq` can either be a single equation or an array. If `simplify_eq` is true, the equation will be simplified.\n\n\n\n\n\n","category":"function"},{"location":"basis/#Base.deleteat!","page":"-","title":"Base.deleteat!","text":"deleteat!(basis, inds, eval_expression = false)\n\nDelete the entries specified by `inds` and update the `Basis` accordingly.\n\n\n\n\n\n","category":"function"},{"location":"basis/#Base.merge","page":"-","title":"Base.merge","text":"merge(x::Basis, y::Basis; eval_expression = false)\n\nReturn a new `Basis`, which is defined via the union of `x` and `y` .\n\n\n\n\n\n","category":"function"},{"location":"basis/#Base.merge!","page":"-","title":"Base.merge!","text":"merge!(x::Basis, y::Basis; eval_expression = false)\n\nUpdates `x` to include the union of both `x` and `y`.\n\n\n\n\n\n","category":"function"},{"location":"sparse_identification/isindy/#Implicit-Sparse-Identification-of-Nonlinear-Dynamics-1","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"","category":"section"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"While SINDy works well for ODEs, some systems take the form of DAEs. A common form is f(x, p, t) - g(x, p, t)*dx = 0. These can be inferred via ISINDy, which extends SINDy for Implicit problems. In particular, it solves","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"Xi = min  leftlVert Theta(X p t)^T Xi rightrVert_2 + lambda  leftlVert Xi rightrVert_1","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"where Xi lies in the nullspace of Theta.","category":"page"},{"location":"sparse_identification/isindy/#Example-:-Michaelis-Menten-Kinetics-1","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Example : Michaelis-Menten Kinetics","text":"","category":"section"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"Let's try to infer the Michaelis-Menten Kinetics, like in the corresponding paper. We start by generating the corresponding data.","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing OrdinaryDiffEq\nusing LinearAlgebra\nusing Plots\ngr()\n\nfunction michaelis_menten(u, p, t)\n    [0.6 - 1.5u[1]/(0.3+u[1])]\nend\n\nu0 = [0.5]\ntspan = (0.0, 5.0)\nproblem = ODEProblem(michaelis_menten, u0, tspan)\n\nsolution = solve(problem, Tsit5(), saveat = 0.1, atol = 1e-7, rtol = 1e-7)\n    \nplot(solution) # hide\nsavefig(\"iSINDy_example.png\")","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"(Image: )","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"X = solution[:,:]\nDX = similar(X)\nfor (i, xi) in enumerate(eachcol(X))\n    DX[:, i] = michaelis_menten(xi, [], 0.0)\nend\n\n@variables u\nbasis= Basis([u^i for i in 0:4], [u])","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"The signature of ISINDy is equal to SINDy, but requires an AbstractSubspaceOptimizer. Currently, DataDrivenDiffEq just implements ADM() based on alternating directions. rtol gets passed into the derivation of the nullspace via LinearAlgebra.","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"opt = ADM(1.1e-1)","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"Since ADM() returns sparsified columns of the nullspace we need to find a pareto optimal solution. To achieve this, we provide a sufficient cost function g to ISINDy. This allows us to evaluate each individual column of the sparse matrix on its 0-norm (sparsity) and the 2-norm of the matrix vector product of Theta^T xi (nullspace). This is a default setting which can be changed by providing a function f which maps the coefficients and the library onto a feature space. Here, we want to set the focus on the the magnitude of the deviation from the nullspace.","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"Ψ = ISINDy(X, DX, basis, opt, g = x->norm([1e-1*x[1]; x[2]]), maxiter = 100)\nnothing #hide","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"The function call returns a SparseIdentificationResult. As in Sparse Identification of Nonlinear Dynamics, we can transform the SparseIdentificationResult into an ODESystem.","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"# Transform into ODE System\nsys = ODESystem(Ψ)\ndudt = ODEFunction(sys)\nps = parameters(Ψ)\n\nestimator = ODEProblem(dudt, u0, tspan, ps)\nestimation = solve(estimator, Tsit5(), saveat = 0.1)\n\nplot(solution, color = :red, label = \"True\") # hide\nplot!(estimation, color = :green, label = \"Estimation\") # hide\nsavefig(\"iSINDy_example_final.png\") # hide","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"(Image: )","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"The model recovered by ISINDy is  correct","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"print_equations(Ψ)","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"The parameters are off a little, but, as before, we can use DiffEqFlux to tune them.","category":"page"},{"location":"sparse_identification/isindy/#Example-:-Cart-Pole-with-Time-Dependent-Control-1","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Example : Cart-Pole with Time-Dependent Control","text":"","category":"section"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"Implicit dynamics can also be reformulated as an explicit problem as stated in this paper. The algorithm searches the correct equations by trying out all candidate functions as a right hand side and performing a sparse regression onto the remaining set of candidates. Let's start by defining the problem and generate the data:","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"\nusing DataDrivenDiffEq\nusing ModelingToolkit\nusing OrdinaryDiffEq\nusing LinearAlgebra\nusing Plots\ngr()\n\nfunction cart_pole(u, p, t)\n    du = similar(u)\n    F = -0.2 + 0.5*sin(6*t) # the input\n    du[1] = u[3]\n    du[2] = u[4]\n    du[3] = -(19.62*sin(u[1])+sin(u[1])*cos(u[1])*u[3]^2+F*cos(u[1]))/(2-cos(u[1])^2)\n    du[4] = -(sin(u[1])*u[3]^2 + 9.81*sin(u[1])*cos(u[1])+F)/(2-cos(u[1])^2)\n    return du\nend\n\nu0 = [0.3; 0; 1.0; 0]\ntspan = (0.0, 16.0)\ndt = 0.001\ncart_pole_prob = ODEProblem(cart_pole, u0, tspan)\nsolution = solve(cart_pole_prob, Tsit5(), saveat = dt)\n\n# Create the differential data\nX = solution[:,:]\nDX = similar(X)\nfor (i, xi) in enumerate(eachcol(X))\n    DX[:, i] = cart_pole(xi, [], solution.t[i])\nend\n\nplot(solution) # hide\nsavefig(\"iSINDy_cartpole_data.png\") # hide\n","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"(Image: )","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"We see that we include a forcing term F inside the model which is depending on t. As before, we will also need a Basis to derive our equations from:","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"@variables u[1:4] t\npolys = Any[]\nfor i ∈ 0:4\n    if i == 0\n        push!(polys, u[1]^0)\n    else\n        if i < 2\n            push!(polys, u.^i...)\n        else\n            push!(polys, u[3:4].^i...)\n        end\n        \n    end\nend\npush!(polys, sin.(u[1])...)\npush!(polys, cos.(u[1]))\npush!(polys, sin.(u[1]).*u[3:4]...)\npush!(polys, sin.(u[1]).*u[3:4].^2...)\npush!(polys, cos.(u[1]).^2...)\npush!(polys, sin.(u[1]).*cos.(u[1])...)\npush!(polys, sin.(u[1]).*cos.(u[1]).*u[3:4]...)\npush!(polys, sin.(u[1]).*cos.(u[1]).*u[3:4].^2...)\npush!(polys, -0.2+0.5*sin(6*t))\npush!(polys, (-0.2+0.5*sin(6*t))*cos(u[1]))\npush!(polys, (-0.2+0.5*sin(6*t))*sin(u[1]))\nbasis= Basis(polys, u, iv = t)","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"We added the time dependent input directly into the basis to account for its influence.","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"NOTE : Including input signals may change in future releases!","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"Like for a SINDy, we can use any AbstractOptimizer with a pareto front optimization over different thresholds. ","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"λ = exp10.(-4:0.1:-1)\ng(x) = norm([1e-3; 10.0] .* x, 2)\nΨ = ISINDy(X[:,:], DX[:, :], basis, λ, STRRidge(), maxiter = 100, normalize = false, t = solution.t, g = g)\n\n# Transform into ODE System\nsys = ODESystem(Ψ)\ndudt = ODEFunction(sys)\nps = parameters(Ψ)\n\n# Simulate\nestimator = ODEProblem(dudt, u0, tspan, ps)\nsol_ = solve(estimator, Tsit5(), saveat = dt)\n\nplot(solution.t[:], solution[:,:]', color = :red, label = nothing) # hide\nplot!(sol_.t, sol_[:, :]', color = :green, label = \"Estimation\") # hide\nsavefig(\"iSINDy_cartpole_estimation.png\") # hide","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"(Image: )","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"Let's have a look at the equations recovered. They match up.","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"print_equations(Ψ)","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"Alternatively, we can also use the input as an extended state x.","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"@variables u[1:4] t x\npolys = Any[]\n# Lots of basis functions -> sindy pi can handle more than ADM()\nfor i ∈ 0:4\n    if i == 0\n        push!(polys, u[1]^0)\n    else\n        if i < 2\n            push!(polys, u.^i...)\n        else\n            push!(polys, u[3:4].^i...)\n        end\n        \n    end\nend\npush!(polys, sin.(u[1])...)\npush!(polys, cos.(u[1]))\npush!(polys, sin.(u[1]).*u[3:4]...)\npush!(polys, sin.(u[1]).*u[3:4].^2...)\npush!(polys, cos.(u[1]).^2...)\npush!(polys, sin.(u[1]).*cos.(u[1])...)\npush!(polys, sin.(u[1]).*cos.(u[1]).*u[3:4]...)\npush!(polys, sin.(u[1]).*cos.(u[1]).*u[3:4].^2...)\npush!(polys, x)\npush!(polys, x*cos(u[1]))\npush!(polys, x*sin(u[1]))\nbasis= Basis(polys, vcat(u, x), iv = t)","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"Now we include the input signal into the extended state array Xᵤ and perform a sparse regression.","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"U = -0.2 .+ 0.5*sin.(6*solution.t)\nXᵤ = vcat(X, U')\n\nλ = exp10.(-4:0.5:-1)\ng(x) = norm([1e-3; 10.0] .* x, 2)\nΨ = ISINDy(Xᵤ[:,:], DX[:, :], basis, λ, STRRidge(), maxiter = 100, normalize = false, t = solution.t, g = g)\nprint_equations(Ψ, show_parameter = true)","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"Currently, we can not generate an ODESystem out of the resulting equations, which is a work in progress.","category":"page"},{"location":"sparse_identification/isindy/#Functions-1","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Functions","text":"","category":"section"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"ISINDy","category":"page"},{"location":"koopman/koopman/#koopman_operator-1","page":"Koopman Operators","title":"Koopman Operators","text":"","category":"section"},{"location":"koopman/koopman/#","page":"Koopman Operators","title":"Koopman Operators","text":"LinearKoopman\nNonlinearKoopman","category":"page"},{"location":"koopman/koopman/#Functions-1","page":"Koopman Operators","title":"Functions","text":"","category":"section"},{"location":"koopman/koopman/#","page":"Koopman Operators","title":"Koopman Operators","text":"operator\ngenerator\ninputmap\noutputmap\nupdate!\nis_discrete\nis_continuous\nupdatable\nisstable\neigen\neigvals\neigvecs\nmodes\nfrequencies\nreduce_basis","category":"page"},{"location":"koopman/koopman/#DataDrivenDiffEq.operator","page":"Koopman Operators","title":"DataDrivenDiffEq.operator","text":"operator(k)\n\n\nReturn the approximation of the discrete Koopman operator stored in k.\n\n\n\n\n\n","category":"function"},{"location":"koopman/koopman/#DataDrivenDiffEq.generator","page":"Koopman Operators","title":"DataDrivenDiffEq.generator","text":"generator(k)\n\n\nReturn the approximation of the continuous Koopman generator stored in k.\n\n\n\n\n\n","category":"function"},{"location":"koopman/koopman/#DataDrivenDiffEq.outputmap","page":"Koopman Operators","title":"DataDrivenDiffEq.outputmap","text":"outputmap(k)\n\n\nReturn the array C, mapping the Koopman space back onto the state space.\n\n\n\n\n\n","category":"function"},{"location":"koopman/koopman/#DataDrivenDiffEq.update!","page":"Koopman Operators","title":"DataDrivenDiffEq.update!","text":"update!(k, X, Y; p, t, U, threshold)\n\n\nUpdate the Koopman k given new data X and Y. The operator is updated in place if the L2 error of the prediction exceeds the threshold.\n\np and t are the parameters of the basis and the vector of timepoints, if necessary.\n\n\n\n\n\n","category":"function"},{"location":"koopman/koopman/#DataDrivenDiffEq.is_discrete","page":"Koopman Operators","title":"DataDrivenDiffEq.is_discrete","text":"is_discrete(k)\n\n\nReturns if the AbstractKoopmanOperator k is discrete in time.\n\n\n\n\n\n","category":"function"},{"location":"koopman/koopman/#DataDrivenDiffEq.is_continuous","page":"Koopman Operators","title":"DataDrivenDiffEq.is_continuous","text":"is_continuous(k)\n\n\nReturns if the AbstractKoopmanOperator k is continuous in time.\n\n\n\n\n\n","category":"function"},{"location":"koopman/koopman/#DataDrivenDiffEq.updatable","page":"Koopman Operators","title":"DataDrivenDiffEq.updatable","text":"updatable(k)\n\n\nReturns true if the AbstractKoopmanOperator is updatable.\n\n\n\n\n\n","category":"function"},{"location":"koopman/koopman/#DataDrivenDiffEq.modes","page":"Koopman Operators","title":"DataDrivenDiffEq.modes","text":"modes(k)\n\n\nReturn the eigenvectors of a continuous AbstractKoopmanOperator.\n\n\n\n\n\n","category":"function"},{"location":"koopman/koopman/#DataDrivenDiffEq.frequencies","page":"Koopman Operators","title":"DataDrivenDiffEq.frequencies","text":"frequencies(k)\n\n\nReturn the eigenvalues of a continuous AbstractKoopmanOperator.\n\n\n\n\n\n","category":"function"},{"location":"utils/#Basis-Generators-1","page":"Basis Generators","title":"Basis Generators","text":"","category":"section"},{"location":"utils/#","page":"Basis Generators","title":"Basis Generators","text":"monomial_basis\npolynomial_basis\nchebyshev_basis\nsin_basis\ncos_basis\nfourier_basis","category":"page"},{"location":"utils/#DataDrivenDiffEq.monomial_basis","page":"Basis Generators","title":"DataDrivenDiffEq.monomial_basis","text":"monomial_basis(x, c)\n\nConstructs an array containing monomial basis in the variables x up to degree c of the form [x₁, x₁^2, ... , x₁^c, x₂, x₂^2, ...].\n\n\n\n\n\n","category":"function"},{"location":"utils/#DataDrivenDiffEq.polynomial_basis","page":"Basis Generators","title":"DataDrivenDiffEq.polynomial_basis","text":"polynomial_basis(x, c)\n\nConstructs an array containing a polynomial basis in the variables x up to degree c of the form [x₁, x₂, x₃, ..., x₁^1 * x₂^(c-1)]. Mixed terms are included.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DataDrivenDiffEq.chebyshev_basis","page":"Basis Generators","title":"DataDrivenDiffEq.chebyshev_basis","text":"chebyshev_basis(x, c)\n\nConstructs an array containing a Chebyshev basis in the variables x with coefficients c. If c is an Int returns all coefficients from 1 to c.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DataDrivenDiffEq.sin_basis","page":"Basis Generators","title":"DataDrivenDiffEq.sin_basis","text":"sin_basis(x, c)\n\nConstructs an array containing a Sine basis in the variables x with coefficients c. If c is an Int returns all coefficients from 1 to c.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DataDrivenDiffEq.cos_basis","page":"Basis Generators","title":"DataDrivenDiffEq.cos_basis","text":"cos_basis(x, c)\n\nConstructs an array containing a Cosine basis in the variables x with coefficients c. If c is an Int returns all coefficients from 1 to c.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DataDrivenDiffEq.fourier_basis","page":"Basis Generators","title":"DataDrivenDiffEq.fourier_basis","text":"fourier_basis(x, c)\n\nConstructs an array containing a Fourier basis in the variables x with (integer) coefficients c. If c is an Int returns all coefficients from 1 to c.\n\n\n\n\n\n","category":"function"},{"location":"utils/#Utility-Functions-1","page":"Basis Generators","title":"Utility Functions","text":"","category":"section"},{"location":"utils/#","page":"Basis Generators","title":"Basis Generators","text":"AIC\nAICC\nBIC\noptimal_shrinkage\nburst_sampling\nsubsample","category":"page"},{"location":"utils/#DataDrivenDiffEq.AIC","page":"Basis Generators","title":"DataDrivenDiffEq.AIC","text":"AIC(k, X, Y; likelihood = (X, Y) = sum(abs2, X-Y))\n\nComputes the Akaike Information Criterion (AIC) given the free parameters k for the data X and its estimate Y of the model. likelihood can be any function of X and Y.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DataDrivenDiffEq.AICC","page":"Basis Generators","title":"DataDrivenDiffEq.AICC","text":"AICC(k, X, Y; likelihood = (X, Y) = sum(abs2, X-Y))\n\nComputes the Akaike Information Criterion compensated for finite samples (AICC) given the free parameters k for the data X and its estimate Y of the model. likelihood can be any function of X and Y.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DataDrivenDiffEq.BIC","page":"Basis Generators","title":"DataDrivenDiffEq.BIC","text":"BIC(k, X, Y; likelihood = (X, Y) = sum(abs2, X-Y))\n\nComputes Bayes Information Criterion (BIC) given the free parameters k for the data X and its estimate Y of the model. likelihood can be any function of X and Y.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DataDrivenDiffEq.optimal_shrinkage","page":"Basis Generators","title":"DataDrivenDiffEq.optimal_shrinkage","text":"optimal_shrinkage(X)\noptimal_shrinkage!(X)\n\nCompute a feature reduced version of the data array X via thresholding the singular values by computing the optimal threshold for singular values.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DataDrivenDiffEq.burst_sampling","page":"Basis Generators","title":"DataDrivenDiffEq.burst_sampling","text":"burst_sampling(X, samplesize, n)\n\nRandomly selects n bursts of data with size samplesize from the data X.\n\n\n\n\n\nburst_sampling(X, Y, samplesize, n)\n\nRandomly selects n bursts of data with size samplesize from the data X and Y.\n\n\n\n\n\nburst_sampling(X, t, period, n)\n\nRandomly selects n bursts of data within a time window period from the data X. The time information has to be provided in t.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DataDrivenDiffEq.subsample","page":"Basis Generators","title":"DataDrivenDiffEq.subsample","text":"subsample(X, n)\n\nReturns the subsampled X with only every n-th entry.\n\n\n\n\n\nsubsample(X, t, dt)\n\nReturns the subsampled X with a a minimum period of dt between two data points. t provides the time information.\n\n\n\n\n\n","category":"function"},{"location":"sparse_identification/optimizers/#Optimizer-1","page":"Optimizer","title":"Optimizer","text":"","category":"section"},{"location":"sparse_identification/optimizers/#","page":"Optimizer","title":"Optimizer","text":"DataDrivenDiffEq comes with some implementations for sparse regression included. All of these are stored inside the DataDrivenDiffEq.Optimize package and extend the AbstractOptimizer, if an explicit optimization is needed or the AbstractSubspaceOptimizer for an implicit problem (where the solution is within the nullspace).","category":"page"},{"location":"sparse_identification/optimizers/#Functions-1","page":"Optimizer","title":"Functions","text":"","category":"section"},{"location":"sparse_identification/optimizers/#","page":"Optimizer","title":"Optimizer","text":"STRRidge\nADMM\nSR3\nDataDrivenDiffEq.Optimize.ADM","category":"page"},{"location":"sparse_identification/optimizers/#DataDrivenDiffEq.Optimize.ADMM","page":"Optimizer","title":"DataDrivenDiffEq.Optimize.ADMM","text":"mutable struct ADMM{T, R} <: DataDrivenDiffEq.Optimize.AbstractOptimizer{T}\n\nADMM is an implementation of Lasso using the alternating direction methods of multipliers and loosely based on this implementation. It solves the following problem\n\nargmin_x frac12  Ax-b_2 + lambda x_1\n\nFields\n\nλ\nSparsity threshold\nρ\nAugmented Lagrangian parameter\n\nExample\n\nopt = ADMM()\nopt = ADMM(1e-1, 2.0)\n\n\n\n\n\n","category":"type"},{"location":"sparse_identification/optimizers/#DataDrivenDiffEq.Optimize.SR3","page":"Optimizer","title":"DataDrivenDiffEq.Optimize.SR3","text":"mutable struct SR3{T, V, P<:DataDrivenDiffEq.Optimize.AbstractProximalOperator} <: DataDrivenDiffEq.Optimize.AbstractOptimizer{T}\n\nSR3 is an optimizer framework introduced by Zheng et. al., 2018 and used within Champion et. al., 2019. SR3 contains a sparsification parameter λ, a relaxation ν. It solves the following problem\n\nargmin_x w frac12  Ax-b_2 + lambda R(w) + fracnu2x-w_2\n\nWhere R is a proximal operator and the result is given by w.\n\nFields\n\nλ\nSparsity threshold\nν\nRelaxation parameter\nR\nProximal operator\n\nExample\n\nopt = SR3()\nopt = SR3(1e-2)\nopt = SR3(1e-3, 1.0)\nopt = SR3(1e-3, 1.0, SoftThreshold())\n\nNote\n\nOpposed to the original formulation, we use ν as a relaxation parameter, as given in Champion et. al., 2019. In the standard case of hard thresholding the sparsity is interpreted as λ = threshold^2 / 2, otherwise λ = threshold.\n\n\n\n\n\n","category":"type"},{"location":"sparse_identification/optimizers/#DataDrivenDiffEq.Optimize.ADM","page":"Optimizer","title":"DataDrivenDiffEq.Optimize.ADM","text":"mutable struct ADM{T} <: DataDrivenDiffEq.Optimize.AbstractSubspaceOptimizer{T}\n\nOptimizer for finding a sparse basis vector in a subspace based on this paper. It solves the following problem\n\nargmin_x x_0 stAx= 0\n\nFields\n\nλ\nSparsity threshold\n\nExample\n\nADM()\nADM(λ = 0.1)\n\nNote\n\nWhile useable for implicit problems, a better choice in general is given by the ImplicitOptimizer which tends to be more robust.\n\n\n\n\n\n","category":"type"},{"location":"sparse_identification/optimizers/#Implementing-New-Optimizer-1","page":"Optimizer","title":"Implementing New Optimizer","text":"","category":"section"},{"location":"sparse_identification/optimizers/#","page":"Optimizer","title":"Optimizer","text":"Similarly to Algorithms for Estimation, the extension of optimizers is more or less straightforward. Suppose you want to define a new optimizer MyOpt, which should solve AX = Y for a sparse X.","category":"page"},{"location":"sparse_identification/optimizers/#","page":"Optimizer","title":"Optimizer","text":"mutable struct MyOpt <: DataDrivenDiffEq.Optimize.AbstractOptimizer\n    threshold\nend","category":"page"},{"location":"sparse_identification/optimizers/#","page":"Optimizer","title":"Optimizer","text":"To use MyOpt within SINDy, an init! function has to be implemented.","category":"page"},{"location":"sparse_identification/optimizers/#","page":"Optimizer","title":"Optimizer","text":"function init!(X::AbstractArray, o::MyOpt, A::AbstractArray, Y::AbstractArray)\n    X .=  A \\ Y\nend","category":"page"},{"location":"sparse_identification/optimizers/#","page":"Optimizer","title":"Optimizer","text":"To perform thresholding - and use maybe for searching the right threshold - a setter and getter is required:","category":"page"},{"location":"sparse_identification/optimizers/#","page":"Optimizer","title":"Optimizer","text":"set_threshold!(opt::MyOpt, threshold) = opt.threshold .= threshold\n\nget_threshold(opt::MyOpt) = opt.threshold","category":"page"},{"location":"sparse_identification/optimizers/#","page":"Optimizer","title":"Optimizer","text":"And, at last, the method which fits the data and returns the iterations needed:","category":"page"},{"location":"sparse_identification/optimizers/#","page":"Optimizer","title":"Optimizer","text":"function fit!(X::AbstractArray, A::AbstractArray, Y::AbstractArray, opt::MyOpt; maxiter, convergence_error)\n    # Compute awesome stuff here\n    return iterations\nend","category":"page"},{"location":"koopman/edmd/#Extended-Dynamic-Mode-Decomposition-1","page":"Extended Dynamic Mode Decomposition","title":"Extended Dynamic Mode Decomposition","text":"","category":"section"},{"location":"koopman/edmd/#","page":"Extended Dynamic Mode Decomposition","title":"Extended Dynamic Mode Decomposition","text":"Extended Dynamic Mode Decomposition is a method for generating an approximating linear differential equation in a chosen basis of observables. If X and Y are data matrices containing points of the same trajectory and Ψ is a basis, then EDMD approximates","category":"page"},{"location":"koopman/edmd/#","page":"Extended Dynamic Mode Decomposition","title":"Extended Dynamic Mode Decomposition","text":"K = Ψ(Y)Ψ(X)^dagger","category":"page"},{"location":"koopman/edmd/#","page":"Extended Dynamic Mode Decomposition","title":"Extended Dynamic Mode Decomposition","text":"where dagger denotes the Moore-Penrose pseudoinverse and K is the approximation of the Koopman Operator.","category":"page"},{"location":"koopman/edmd/#","page":"Extended Dynamic Mode Decomposition","title":"Extended Dynamic Mode Decomposition","text":"EDMD approximates discrete time systems of the form","category":"page"},{"location":"koopman/edmd/#","page":"Extended Dynamic Mode Decomposition","title":"Extended Dynamic Mode Decomposition","text":"Psi(u_i+1) = K  Psi(u_i) \nu_i+1 = CPsi(u_i)","category":"page"},{"location":"koopman/edmd/#","page":"Extended Dynamic Mode Decomposition","title":"Extended Dynamic Mode Decomposition","text":"gEDMD approximates continuous time systems of the form","category":"page"},{"location":"koopman/edmd/#","page":"Extended Dynamic Mode Decomposition","title":"Extended Dynamic Mode Decomposition","text":"fracddtPsi(u) =  K_G  Psi(u) \nfracddtu = CfracddtPsi(u)","category":"page"},{"location":"koopman/edmd/#","page":"Extended Dynamic Mode Decomposition","title":"Extended Dynamic Mode Decomposition","text":"where K_G is the generator of the Koopman Operator. C is a matrix mapping from the observations back onto the states or differential states.","category":"page"},{"location":"koopman/edmd/#Functions-1","page":"Extended Dynamic Mode Decomposition","title":"Functions","text":"","category":"section"},{"location":"koopman/edmd/#","page":"Extended Dynamic Mode Decomposition","title":"Extended Dynamic Mode Decomposition","text":"EDMD\ngEDMD","category":"page"},{"location":"extended_examples/#Multiple-Trajectories-for-Koopman-Approximation-1","page":"Multiple Trajectories for Koopman Approximation","title":"Multiple Trajectories for Koopman Approximation","text":"","category":"section"},{"location":"extended_examples/#","page":"Multiple Trajectories for Koopman Approximation","title":"Multiple Trajectories for Koopman Approximation","text":"Lets consider the case of approximating a Koopman Operator based on multiple trajectories. We assume pairs (x_i dotx_i) of the measured state space trajectory and its time derivative where i denotes a single measurement. ","category":"page"},{"location":"extended_examples/#","page":"Multiple Trajectories for Koopman Approximation","title":"Multiple Trajectories for Koopman Approximation","text":"Lets create our artificial measurements for a system with a slow and fast manifold, for which there exists an analytical solution of this problem.","category":"page"},{"location":"extended_examples/#","page":"Multiple Trajectories for Koopman Approximation","title":"Multiple Trajectories for Koopman Approximation","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing OrdinaryDiffEq\nusing LinearAlgebra\nusing Plots\ngr()\n\n\nfunction slow_manifold(du, u, p, t)\n    du[1] = p[1]*u[1]\n    du[2] = p[2]*(u[2]-u[1]^2)\nend\n  \nu0 = [3.0; -2.0]\ntspan = (0.0, 3.0)\np = [-0.05, -1.0]\n\nproblem = ODEProblem(slow_manifold, u0, (0f0, 3f0), p)\nsol_1= solve(problem, Tsit5(), saveat = 0.3)\nX_1 = Array(sol_1)\nDX_1 = sol_1(sol_1.t, Val{1})[:,:]\n\nproblem = ODEProblem(slow_manifold, 2f0*u0, (0f0, 2f0), p)\nsol_2 = solve(problem, Tsit5(), saveat = 0.1)\nX_2 = Array(sol_2)\nDX_2 = sol_2(sol_2.t, Val{1})[:,:]\n\nscatter(X_1[1,:], X_1[2,:], legend = false, label = \"Trajectory 1\") #hide\nscatter!(X_2[1,:], X_2[2,:], legend = true, label = \"Trajectory 2\") #hide\nsavefig(\"multiple_koopman_trajectories.png\") #hide","category":"page"},{"location":"extended_examples/#","page":"Multiple Trajectories for Koopman Approximation","title":"Multiple Trajectories for Koopman Approximation","text":"Note that we varied the inital conditions and the measurement time. The resulting trajectories are shown below.","category":"page"},{"location":"extended_examples/#","page":"Multiple Trajectories for Koopman Approximation","title":"Multiple Trajectories for Koopman Approximation","text":"(Image: )","category":"page"},{"location":"extended_examples/#","page":"Multiple Trajectories for Koopman Approximation","title":"Multiple Trajectories for Koopman Approximation","text":"In this paper on the Dynamic Mode Decomposition its pointed out that the overall ordering of the snapshots does not matter, as long as the specific pair is consistent. This means we can simply append the trajectories and use the new array to derive the approximation.","category":"page"},{"location":"extended_examples/#","page":"Multiple Trajectories for Koopman Approximation","title":"Multiple Trajectories for Koopman Approximation","text":"X = hcat(X_1, X_2)\nDX = hcat(DX_1, DX_2)","category":"page"},{"location":"extended_examples/#","page":"Multiple Trajectories for Koopman Approximation","title":"Multiple Trajectories for Koopman Approximation","text":"In the next steps, we simply create a basis for the approximation and proceed as usual. At first we create the basis and afterwards feed it to the function for approximating the Koopman generator.","category":"page"},{"location":"extended_examples/#","page":"Multiple Trajectories for Koopman Approximation","title":"Multiple Trajectories for Koopman Approximation","text":"@variables u[1:2]\n\nobservables = [u; u[1]^2]\n\nbasis = Basis(observables, u)\n\napproximation = gEDMD(X, DX, basis)\n\nscatter(eigvals(approximation), label = \"Estimate\") # hide\nscatter!(eigvals([p[1] 0 0; 0 p[2] -p[2]; 0 0 2*p[1]]), label = \"True\", legend = :bottomright) #hide\nsavefig(\"eigenvalue_slowmanifold_multiple_trajectories.png\") #hide","category":"page"},{"location":"extended_examples/#","page":"Multiple Trajectories for Koopman Approximation","title":"Multiple Trajectories for Koopman Approximation","text":"Which results in the following eigenvalues of the system and its approximation.","category":"page"},{"location":"extended_examples/#","page":"Multiple Trajectories for Koopman Approximation","title":"Multiple Trajectories for Koopman Approximation","text":"(Image: )","category":"page"},{"location":"extended_examples/#","page":"Multiple Trajectories for Koopman Approximation","title":"Multiple Trajectories for Koopman Approximation","text":"This procedure works for all methods which take two snapshot matrices as input arguments. ","category":"page"},{"location":"quickstart/#Quickstart-1","page":"Quickstart","title":"Quickstart","text":"","category":"section"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"In the following, we will use some of the techniques provided by DataDrivenDiffEq to infer some models.","category":"page"},{"location":"quickstart/#Nonlinear-Systems-Sparse-Identification-of-Nonlinear-Dynamics-1","page":"Quickstart","title":"Nonlinear Systems - Sparse Identification of Nonlinear Dynamics","text":"","category":"section"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"Okay, so far we can fit linear models via DMD and nonlinear models via EDMD. But what if we want to find a model of a nonlinear system without moving to Koopman space? Simple, we use Sparse Identification of Nonlinear Dynamics or SINDy.","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"As the name suggests, SINDy finds the sparsest basis of functions which build the observed trajectory. Again, we will start with a nonlinear system","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing ModelingToolkit\nusing Plots\nusing OrdinaryDiffEq\nusing DataDrivenDiffEq.Optimize\n\n# Create a nonlinear pendulum\nfunction pendulum(u, p, t)\n    x = u[2]\n    y = -9.81sin(u[1]) - 0.3u[2]^3 -3.0*cos(u[1]) - 10.0*exp(-((t-5.0)/5.0)^2)\n    return [x;y]\nend\n\nu0 = [0.99π; -1.0]\ntspan = (0.0, 15.0)\nprob = ODEProblem(pendulum, u0, tspan)\nsol = solve(prob, Tsit5(), saveat = 0.1)\n\n# Create the data\nX = sol[:,:] .+ 0.2*randn(size(sol)...)\nDX = similar(sol[:,:])\nfor (i, xi) in enumerate(eachcol(sol[:,:]))\n    DX[:,i] = pendulum(xi, [], sol.t[i])\nend\nts = sol.t","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"To estimate the system, we first create a DataDrivenProblem via feeding in the measurement data. Using different collocation techniques, it automatically provides the derivative. Additional control signals can be passed in as a function (u,p,t)->control or an array of measurements.","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"prob = ContinuousDataDrivenProblem(X, ts, GaussianKernel(),U = (u,p,t)->[exp(-((t-5.0)/5.0)^2)],p = ones(2))\np1 = scatter(ts, X', label = [\"True\" nothing], color = :black, legend = :bottomleft, ylabel =\"Measurement\") # hide\nplot!(ts, prob.X', label = [\"Smoothed\" nothing], color = :red) # hide\np2 = plot(ts, prob.DX', label = nothing, color = :red, ylabel = \"Derivative\") # hide\nscatter!(ts, DX', label = nothing, color = :black) # hide\np3 = plot(ts, prob.U', label = nothing, color = :red, xlabel = \"Time [s]\", ylabel = \"Control\") # hide\nplot(p1,p2,p3, layout = (3,1), size = (600,600)) # hide\nsavefig(\"SINDy_Example_Data.png\") # hide","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"(Image: )","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"Now we infer the systems structure. First we define a Basis which collects all possible candidate terms. Since we want to use SINDy, we call solve with an Optimizer, in this case ADMM which iterates different sparsity thresholds and returns a pareto optimal solution. Note that we include the control signal in the basis as an additional variable c.","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"@variables u[1:2] c[1:1]\n@parameters w[1:2]\nh = Num[sin(w[1]*u[1]);cos(w[2]*u[1]); polynomial_basis(u, 5); c]\nbasis = Basis(h, u, parameters = w, controls = c)\nλs = exp10.(-10:1:10)\nopt = ADMM(λs)\nres = solve(prob, basis, opt, progress = false, denoise = false, normalize = true, maxiter = 5000)\nprintln(res.res) # hide","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"which is the simple nonlinear pendulum with damping.","category":"page"},{"location":"sparse_identification/sindy/#Sparse-Identification-of-Nonlinear-Dynamics-1","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"","category":"section"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"Sparse Identification of Nonlinear Dynamics - or SINDy - identifies the equations of motion of a system as the result of a sparse regression over a chosen basis. In particular, it tries to find coefficients Xi such that:","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"Xi = min  leftlVert Y^T - Theta(X p t)^T Xi rightrVert_2 + lambda  leftlVert Xi rightrVert_1","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"where, in most cases, Yis the data matrix containing the derivatives of the state data stored in X. Theta is a matrix containing candidate functions xi over the measurements in X.","category":"page"},{"location":"sparse_identification/sindy/#Example-1","page":"Sparse Identification of Nonlinear Dynamics","title":"Example","text":"","category":"section"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"As in the original paper, we will estimate the Lorenz System. First, let's create the necessary data and have a look at the trajectory.","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing OrdinaryDiffEq\n\nusing LinearAlgebra\nusing Plots\ngr()\n\n# Create a test problem\nfunction lorenz(u,p,t)\n    x, y, z = u\n    ẋ = 10.0*(y - x)\n    ẏ = x*(28.0-z) - y\n    ż = x*y - (8/3)*z\n    return [ẋ, ẏ, ż]\nend\n\nu0 = [-8.0; 7.0; 27.0]\np = [10.0; -10.0; 28.0; -1.0; -1.0; 1.0; -8/3]\ntspan = (0.0,100.0)\ndt = 0.001\nproblem = ODEProblem(lorenz,u0,tspan)\nsolution = solve(problem, Tsit5(), saveat = dt, atol = 1e-7, rtol = 1e-8)\n\nplot(solution,vars=(1,2,3), legend = false) #hide\nsavefig(\"lorenz.png\") #hide","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"(Image: )","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"Additionally, we generate the ideal derivative data.","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"X = Array(solution)\nDX = similar(X)\nfor (i, xi) in enumerate(eachcol(X))\n    DX[:,i] = lorenz(xi, [], 0.0)\nend","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"To generate the symbolic equations, we need to define a Basis over the variables x y z. In this example, we will use all monomials up to degree of 4 and their products:","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"@variables x y z\nu = [x; y; z]\npolys = Any[]\nfor i ∈ 0:4\n    for j ∈ 0:i\n        for k ∈ 0:j\n            push!(polys, u[1]^i*u[2]^j*u[3]^k)\n            push!(polys, u[2]^i*u[3]^j*u[1]^k)\n            push!(polys, u[3]^i*u[1]^j*u[2]^k)\n        end\n    end\nend\n\nbasis = Basis(polys, u)\nnothing #hide","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"A Basis consists of unique functions, so duplicates will be included just once","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"To perform the sparse identification on our data, we need to define an Optimizer. Here, we will use STRRidge, which is described in the original paper. The threshold of the optimizer is set to 0.1. An overview of the different optimizers can be found below.","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"opt = STRRidge(0.1)\nΨ = SINDy(X, DX, basis, opt, maxiter = 100, normalize = true)","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"Ψ is a SINDyResult, which stores some about the regression. As we can see, we have 7 active terms inside the model. To look at the equations, simply type","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"print_equations(Ψ)","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"First, let's have a look at the L2-Error and Akaikes Information Criterion of the result","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"get_error(Ψ)","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"get_aicc(Ψ)","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"We can also access the coefficient matrix Xi directly via get_coefficients(Ψ).","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"To generate a numerical model usable in DifferentialEquations, we simply use the ODESystem function from ModelingToolkit. The resulting parameters used for the identification can be accessed via parameters(Ψ). The returned vector also includes the parameters of the original Basis used to generate the result.","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"ps = parameters(Ψ)\nsys = ODESystem(Ψ)\ndudt = ODEFunction(sys)\n\nprob = ODEProblem(dudt, u0, tspan, ps)\nsol = solve(prob, Tsit5(), saveat = solution.t, atol = 1e-7, rtol = 1e-8)\n\nϵ = norm.(eachcol(solution .- sol)) # hide\nplot(solution.t, ϵ .+ eps(), yaxis = :log, legend = false) # hide\nxlabel!(\"Time [s]\") # hide\nylabel!(\"L2 Error\") # hide\nsavefig(\"lorenz_error.png\") # hide\nplot(solution, vars = (0, 1), label = \"True\") # hide\nplot!(sol, vars = (0,1), label = \"Estimation\") # hide\nsavefig(\"lorenz_trajectory_estimate.png\") # hide","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"Let's have a look at the trajectory of u_1(t).","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"(Image: )","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"Finally, let's investigate the error of the chaotic equations:","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"(Image: )","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"which resembles the papers results. Next, we could use classical parameter estimation methods or use DiffEqFlux to fine-tune our result (if needed).","category":"page"},{"location":"sparse_identification/sindy/#Functions-1","page":"Sparse Identification of Nonlinear Dynamics","title":"Functions","text":"","category":"section"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"SINDy\nsparse_regression","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"SparseIdentificationResult\nget_sparsity\nget_error\nget_aicc\nget_coefficients","category":"page"},{"location":"#DataDrivenDiffEq.jl-1","page":"DataDrivenDiffEq.jl","title":"DataDrivenDiffEq.jl","text":"","category":"section"},{"location":"#","page":"DataDrivenDiffEq.jl","title":"DataDrivenDiffEq.jl","text":"DataDrivenDiffEq.jl is a package for estimating equation-free and equation-based models for discrete and continuous differential equations.","category":"page"},{"location":"#","page":"DataDrivenDiffEq.jl","title":"DataDrivenDiffEq.jl","text":"As opposed to parameter identification, these methods aim to find the governing equations of motion automatically from a given set of data. They do not require a known model as input. Instead, these methods take in data and return the differential equation model which generated the data.","category":"page"},{"location":"#","page":"DataDrivenDiffEq.jl","title":"DataDrivenDiffEq.jl","text":"There are various avenues in which structural estimation can occur. However, the main branches are: do you want to know the equations in a human-understandable manner, or is it sufficient to have a function that predicts the derivative and generates the correct time series? We will refer to methods which return symbolic forms of the differential equation as structural identification, while those which return functions only for prediction as structural estimation.","category":"page"},{"location":"#Package-Overview-1","page":"DataDrivenDiffEq.jl","title":"Package Overview","text":"","category":"section"},{"location":"#","page":"DataDrivenDiffEq.jl","title":"DataDrivenDiffEq.jl","text":"DataDrivenDiffEq currently implements the following algorithms for structural estimation:","category":"page"},{"location":"#","page":"DataDrivenDiffEq.jl","title":"DataDrivenDiffEq.jl","text":"Dynamic Mode Decomposition\nExtended Dynamic Mode Decomposition\nSparse Identification of Nonlinear Dynamics\nImplicit Sparse Identification of Nonlinear Dynamics","category":"page"},{"location":"#Installation-1","page":"DataDrivenDiffEq.jl","title":"Installation","text":"","category":"section"},{"location":"#","page":"DataDrivenDiffEq.jl","title":"DataDrivenDiffEq.jl","text":"To use 'DataDrivenDiffEq.jl', simply install it via:","category":"page"},{"location":"#","page":"DataDrivenDiffEq.jl","title":"DataDrivenDiffEq.jl","text":"]add DataDrivenDiffEq\nusing DataDrivenDiffEq","category":"page"}]
}
