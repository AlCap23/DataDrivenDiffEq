var documenterSearchIndex = {"docs":
[{"location":"koopman/dmdc/#Dynamic-Mode-Decomposition-with-control-1","page":"Dynamic Mode Decomposition with control","title":"Dynamic Mode Decomposition with control","text":"","category":"section"},{"location":"koopman/dmdc/#","page":"Dynamic Mode Decomposition with control","title":"Dynamic Mode Decomposition with control","text":"Dynamic Mode Decomposition with Control is a method for generating an approximating linear differential equation in a chosen basis of observables. If X and Y are data matrices containing points of the same trajectory and U containing the exogenous inputs acting on that trajectory, then DMDc approximates","category":"page"},{"location":"koopman/dmdc/#","page":"Dynamic Mode Decomposition with control","title":"Dynamic Mode Decomposition with control","text":"G = Yleft beginarrayc X  U endarray right^dagger = leftK B right","category":"page"},{"location":"koopman/dmdc/#","page":"Dynamic Mode Decomposition with control","title":"Dynamic Mode Decomposition with control","text":"where dagger denotes the Moore-Penrose pseudoinverse and K is the approximation of the Koopman Operator and B the linear input map.","category":"page"},{"location":"koopman/dmdc/#","page":"Dynamic Mode Decomposition with control","title":"Dynamic Mode Decomposition with control","text":"DMDc approximates discrete time systems with inputs z of the form","category":"page"},{"location":"koopman/dmdc/#","page":"Dynamic Mode Decomposition with control","title":"Dynamic Mode Decomposition with control","text":"u_i+1 = K  u_i + B  z_i","category":"page"},{"location":"koopman/dmdc/#","page":"Dynamic Mode Decomposition with control","title":"Dynamic Mode Decomposition with control","text":"gDMDc approximates continuous time systems with inputs z of the form","category":"page"},{"location":"koopman/dmdc/#","page":"Dynamic Mode Decomposition with control","title":"Dynamic Mode Decomposition with control","text":"fracddtu =  K_G  u + B  z","category":"page"},{"location":"koopman/dmdc/#","page":"Dynamic Mode Decomposition with control","title":"Dynamic Mode Decomposition with control","text":"where K_G is the generator of the Koopman Operator.","category":"page"},{"location":"koopman/dmdc/#Functions-1","page":"Dynamic Mode Decomposition with control","title":"Functions","text":"","category":"section"},{"location":"koopman/dmdc/#","page":"Dynamic Mode Decomposition with control","title":"Dynamic Mode Decomposition with control","text":"DMDc\ngDMDc","category":"page"},{"location":"koopman/dmdc/#DataDrivenDiffEq.DMDc","page":"Dynamic Mode Decomposition with control","title":"DataDrivenDiffEq.DMDc","text":"DMDc(X, U; B, alg)\nDMDc(X, Y, U; B, alg)\n\nApproximates a 'LinearKoopman' with the AbstractKoopmanAlgorithm 'alg' from the data matrices X and U or X, U and Y respectively. If only X is given, the data is split into X[:, 1:end-1] and X[:, 2:end]. B represents the matrix mapping the input onto Y, which may be known a priori.\n\nExample\n\nalg = DMDPINV()\nkoopman = DMDc(X, U, alg = alg)\n\nkoopman = DMD(X[:, 1:end-1], X[:, 2:end], U, alg = alg)\n\n\n\n\n\n","category":"function"},{"location":"koopman/dmdc/#DataDrivenDiffEq.gDMDc","page":"Dynamic Mode Decomposition with control","title":"DataDrivenDiffEq.gDMDc","text":"gDMDc(X, Y, U; B, alg)\ngDMDc(t, X, U; B, dt, alg, fdm, itp)\n\nApproximates a 'LinearKoopman' with the AbstractKoopmanAlgorithm 'alg' from the data matrices X and U or X, U and Y, respectively. X should contain the state trajectory and Y the differential state trajectory.B represents the matrix mapping the input onto Y, which may be known a priori.\n\nIf no measurements of the differential state are available, gDMDc can be called with measurement time points t as the first argument. It will then create an interpolation using the interpolation method from DataInterpolations.jl defined in itp. The trajectory will then be resampled to equidistant measurements over time corresponding to the mean of diff(t) or dt, if given. The differential state measurements will be computed via 'FiniteDifferences.jl', given a FiniteDifferenceMethod in fdm.\n\nExample\n\nkoopman = gDMDc(X, Y, U)\n\nfdm = backward_fdm(5,1)\nitp = CubicSpline\nkoopman = gDMD(t, X, U, fdm = fdm, itp = itp)\n\n\n\n\n\n","category":"function"},{"location":"contributions/#Contributions-1","page":"Contributing","title":"Contributions","text":"","category":"section"},{"location":"contributions/#","page":"Contributing","title":"Contributing","text":"Contributions are welcome! To help, please:","category":"page"},{"location":"contributions/#","page":"Contributing","title":"Contributing","text":"Open (or solve) an issue\nReview pull requests\nAdapt code to be more efficient\nWrite new optimizers or algorithms\nWrite tutorials or adapt the docs","category":"page"},{"location":"contributions/#","page":"Contributing","title":"Contributing","text":"Feel free to write a private message to @AlCap23 for further discussion.","category":"page"},{"location":"koopman/dmd/#Dynamic-Mode-Decomposition-1","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"","category":"section"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"The (Exact) Dynamic Mode Decomposition is a method for generating an approximating linear differential equation directly from the observed data. If X and Y are data matrices containing points of the same trajectory, than DMD approximates","category":"page"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"K = YX^dagger","category":"page"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"where dagger denotes the Moore-Penrose pseudoinverse and K is the approximation of the Koopman Operator.","category":"page"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"DMD approximates discrete time systems of the form","category":"page"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"u_i+1 = K  u_i","category":"page"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"gDMD approximates continuous time systems of the form","category":"page"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"fracddtu =  K_G  u","category":"page"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"where K_G is the generator of the Koopman Operator.","category":"page"},{"location":"koopman/dmd/#Functions-1","page":"Dynamic Mode Decomposition","title":"Functions","text":"","category":"section"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"DMD\ngDMD","category":"page"},{"location":"koopman/dmd/#DataDrivenDiffEq.DMD","page":"Dynamic Mode Decomposition","title":"DataDrivenDiffEq.DMD","text":"DMD(X; alg)\nDMD(X, Y; alg)\n\nApproximates a 'LinearKoopman' with the AbstractKoopmanAlgorithm 'alg' from the data matrices X or X and Y, respectively. If only X is given, the data is split into X[:, 1:end-1] and X[:, 2:end].\n\nExample\n\nalg = DMDPINV()\nkoopman = DMD(X, alg = alg)\n\nkoopman = DMD(X[:, 1:end-1], X[:, 2:end], alg = alg)\n\n\n\n\n\n","category":"function"},{"location":"koopman/dmd/#DataDrivenDiffEq.gDMD","page":"Dynamic Mode Decomposition","title":"DataDrivenDiffEq.gDMD","text":"gDMD(X, Y; alg)\ngDMD(t, X ; dt, alg, fdm, itp)\n\nApproximates a 'LinearKoopman' with the AbstractKoopmanAlgorithm 'alg' from the data matrices X and Y. X should contain the state trajectory and Y the differential state trajectory.\n\nIf no measurements of the differential state are available, gDMD can be called with measurement time points t as the first argument. It will then create an interpolation using the interpolation method from DataInterpolations.jl defined in itp. The trajectory will then be resampled to equidistant measurements over time corresponding to the mean of diff(t) or dt, if given. The differential state measurements will be computed via 'FiniteDifferences.jl', given a FiniteDifferenceMethod in fdm.\n\nExample\n\nkoopman = gDMD(X, Y)\n\nfdm = backward_fdm(5,1)\nitp = CubicSpline\nkoopman = gDMD(t, X, fdm = fdm, itp = itp)\n\n\n\n\n\n","category":"function"},{"location":"koopman/dmd/#Examples-1","page":"Dynamic Mode Decomposition","title":"Examples","text":"","category":"section"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"using DataDrivenDiffEq\nusing OrdinaryDiffEq\nusing LinearAlgebra\nusing Plots\ngr()\n\nfunction linear_discrete(du, u, p, t)\n    du[1] = 0.9u[1]\n    du[2] = 0.05u[2] + 0.1u[1]\nend\n\nu0 = [10.0; -2.0]\ntspan = (0.0, 20.0)\nproblem = DiscreteProblem(linear_discrete, u0, tspan)\nsolution = solve(problem, FunctionMap())","category":"page"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"X = Array(solution)\n\napprox = DMD(X[:,1:3])\n\nprob_approx = DiscreteProblem(approx, u0, tspan)\napprox_sol = solve(prob_approx, FunctionMap())\n\nplot(approx_sol, label = [\"u[1]\" \"u[2]\"]) #hide\nplot!(solution, label = [\"True u[1]\" \"True u[2]\"]) #hide\nsavefig(\"dmd_example_1.png\") #hide","category":"page"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"(Image: )","category":"page"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"\nfunction linear_discrete_2(du, u, p, t)\n    du[1] = 0.9u[1] + 0.05u[2]\n    du[2] = 0.1u[1]\nend\n\nproblem = DiscreteProblem(linear_discrete_2, u0, tspan)\nsolution = solve(problem, FunctionMap())\n\nX = Array(solution)\n\nupdate!(approx, X[:, 4:end-1], X[:, 5:end])\n\nprob_approx = DiscreteProblem(approx, u0, tspan)\napprox_sol = solve(prob_approx, FunctionMap())\n\n# Show solutions\nplot(approx_sol, label = [\"u[1]\" \"u[2]\"]) #hide\nplot!(solution, label = [\"True u[1]\" \"True u[2]\"]) #hide\nsavefig(\"dmd_example_2.png\") #hide","category":"page"},{"location":"koopman/dmd/#","page":"Dynamic Mode Decomposition","title":"Dynamic Mode Decomposition","text":"(Image: )","category":"page"},{"location":"koopman/algorithms/#Algorithms-for-Estimation-1","page":"Algorithms for Estimation","title":"Algorithms for Estimation","text":"","category":"section"},{"location":"koopman/algorithms/#","page":"Algorithms for Estimation","title":"Algorithms for Estimation","text":"There are different variants of estimation of the Koopman Operator, see e.g., here, here or here.","category":"page"},{"location":"koopman/algorithms/#","page":"Algorithms for Estimation","title":"Algorithms for Estimation","text":"Currently, DataDrivenDiffEq implements the following AbstractKoopmanAlgorithms to use with DMD, EDMD, and DMDc.","category":"page"},{"location":"koopman/algorithms/#Functions-1","page":"Algorithms for Estimation","title":"Functions","text":"","category":"section"},{"location":"koopman/algorithms/#","page":"Algorithms for Estimation","title":"Algorithms for Estimation","text":"DMDPINV\nDMDSVD\nTOTALDMD","category":"page"},{"location":"koopman/algorithms/#DataDrivenDiffEq.DMDPINV","page":"Algorithms for Estimation","title":"DataDrivenDiffEq.DMDPINV","text":"DMDPINV()\n\nApproximates the Koopman operator K based on\n\nK = Y / X\n\nwhere Y and X are data matrices.\n\n\n\n\n\n","category":"type"},{"location":"koopman/algorithms/#DataDrivenDiffEq.DMDSVD","page":"Algorithms for Estimation","title":"DataDrivenDiffEq.DMDSVD","text":"DMDSVD(rtol)\n\nApproximates the Koopman operator K based on the singular value decomposition of X such that:\n\nK = Y*V*Σ*U'\n\nwhere Y and X = U*Σ*V' are data matrices. If rtol ∈ (0, 1) is given, the singular value decomposition is reduced to include only entries bigger than rtol*maximum(Σ). If rtol is an integer, the reduced SVD up to rtol is used for computation.\n\n\n\n\n\n","category":"type"},{"location":"koopman/algorithms/#DataDrivenDiffEq.TOTALDMD","page":"Algorithms for Estimation","title":"DataDrivenDiffEq.TOTALDMD","text":"TOTALDMD(rtol, alg)\n\nApproximates the Koopman operator K with the algorithm alg over the rank-reduced data matrices Xᵣ = X Qᵣ and Yᵣ = Y Qᵣ, where Qᵣ originates from the singular value decomposition of the joint data Z = [X; Y]. Based on this paper.\n\nIf rtol ∈ (0, 1) is given, the singular value decomposition is reduced to include only entries bigger than rtol*maximum(Σ). If rtol is an integer, the reduced SVD up to rtol is used for computation.\n\n\n\n\n\n","category":"type"},{"location":"koopman/algorithms/#Implementing-New-Algorithms-1","page":"Algorithms for Estimation","title":"Implementing New Algorithms","text":"","category":"section"},{"location":"koopman/algorithms/#","page":"Algorithms for Estimation","title":"Algorithms for Estimation","text":"Is pretty straightforward. The implementation of DMDPINV looks like:","category":"page"},{"location":"koopman/algorithms/#","page":"Algorithms for Estimation","title":"Algorithms for Estimation","text":"\nmutable struct DMDPINV <: AbstractKoopmanAlgorithm end;\n\n(x::DMDPINV)(X::AbstractArray, Y::AbstractArray) = Y / X\n","category":"page"},{"location":"koopman/algorithms/#","page":"Algorithms for Estimation","title":"Algorithms for Estimation","text":"So, right now, all you have to do is to implement a struct which is callable with the data matrices X and Y. Possible Parameters should be stored in the fields of the algorithm.","category":"page"},{"location":"basis/#Basis-1","page":"Basis","title":"Basis","text":"","category":"section"},{"location":"basis/#","page":"Basis","title":"Basis","text":"Many of the methods require the definition of a Basis on observables or functional forms. A Basis is generated via:","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"Basis(h, u, parameters = [], iv = nothing)","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"where h is either a vector of ModelingToolkit Operations for the valid functional forms or a general function with the typical DiffEq signature h(u,p,t), which can be used with an  Operation or vector of Operation. u are the ModelingToolkit Variables used to describe the Basis, and parameters are the optional ModelingToolkit Variables used to describe the parameters in the basis elements. iv represents the independent variable of the system - the time.","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"Basis","category":"page"},{"location":"basis/#DataDrivenDiffEq.Basis","page":"Basis","title":"DataDrivenDiffEq.Basis","text":"Basis(f, u; p, iv, eval_expression)\n\nA basis over the variables u with parameters p and independent variable iv. f can either be a Julia function which is able to use ModelingToolkit variables or a vector of Operation. It can be called with the typical DiffEq signature, meaning out of place with f(u,p,t) or in place with f(du, u, p, t).\n\nExample\n\nusing ModelingToolkit\nusing DataDrivenDiffEq\n\n@parameters w[1:2] t\n@variables u[1:2]\n\nΨ = Basis([u; sin.(w.*u)], u, parameters = p, iv = t)\n\nNote\n\nThe keyword argument eval_expression controls the function creation behavior. eval_expression=true means that eval is used, so normal world-age behavior applies (i.e. the functions cannot be called from the function that generates them). If eval_expression=false, then construction via GeneralizedGenerated.jl is utilized to allow for same world-age evaluation. However, this can cause Julia to segfault on sufficiently large basis functions. By default eval_expression=false.\n\n\n\n\n\n","category":"type"},{"location":"basis/#Example-1","page":"Basis","title":"Example","text":"","category":"section"},{"location":"basis/#","page":"Basis","title":"Basis","text":"We start by crearting some Variables and Parameters using ModelingToolkit.","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"using LinearAlgebra\nusing DataDrivenDiffEq\nusing Plots\nusing ModelingToolkit\n\n@variables u[1:3]\n@parameters w[1:2]","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"To define a basis, simply write down the equations you want to be included as a Vector{Operation}. Possible used parameters have to be given to the constructor.","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"h = [u[1]; u[2]; cos(w[1]*u[2]+w[2]*u[3])]\nb = Basis(h, u, parameters = w)","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"What can a Basis do? Can it do stuff? Let's find out!","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"Basis are callable with the signature of functions to be used in DifferentialEquations. So, the function value at a single point looks like:","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"x = b([1;2;3])","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"Or, in place","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"dx = similar(x)\nb(dx, [1;2;3])","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"Notice that since we did not use any numerical values for the parameters, the basis uses the symbolic values in the result.","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"To use numerical values, simply pass this on in the function call. Here, we evaluate over a trajectory with two parameters and 40 timestamps.","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"X = randn(3, 40)\nY = b(X, [2;4], 0:39)\nnothing # hide","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"Suppose we want to add another equation, say sin(u[1]). A Basis behaves like an array, so we can simply","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"push!(b, sin(u[1]))\nsize(b)","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"To ensure that a basis is well-behaved, functions already present are not included again.","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"push!(b, sin(u[1]))\nsize(b)","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"We can also define functions of time and add them","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"t = independent_variable(b)\npush!(b, cos(t*π))\nprintln(b)","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"Additionally, we can iterate over a Basis using [eq for eq in basis] or index specific equations, like basis[2].","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"We can also chain Basis via just using it in the constructor","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"@variables x[1:2]\ny = [sin(x[1]); cos(x[1]); x[2]]\nt = independent_variable(b)\nb2 = Basis(b(y, parameters(b), t), x, parameters = w, iv = t)\nprintln(b2)","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"You can also use merge to create the union of two Basis:","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"b3 = merge(b, b2)\nprintln(b3)","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"which combines all the used variables and parameters ( and assumes the same independent_variable ):","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"variables(b)","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"parameters(b)","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"If you have a function already defined as pure code, you can use this also to create a Basis. Only the signature has to be consistent, so use f(u,p,t).","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"f(u, p, t) = [u[1]; u[2]; cos(p[1]*u[2]+p[2]*u[3])]\nb_f = Basis(f, u, parameters = w)\nprintln(b_f)","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"This works for every function defined over Operations. So to create a Basis from a Flux model, simply extend the activations used:","category":"page"},{"location":"basis/#","page":"Basis","title":"Basis","text":"using Flux\nNNlib.σ(x::Operation) = 1 / (1+exp(-x))\n\nc = Chain(Dense(3,2,σ), Dense(2, 1, σ))\nps, re = Flux.destructure(c)\n\n@parameters p[1:length(ps)]\n\ng(u, p, t) = re(p)(u)\nb = Basis(g, u, parameters = p)","category":"page"},{"location":"basis/#Functions-1","page":"Basis","title":"Functions","text":"","category":"section"},{"location":"basis/#","page":"Basis","title":"Basis","text":"parameters\nvariables\nDataDrivenDiffEq.independent_variable\njacobian\ndynamics\npush!\ndeleteat!\nmerge\nmerge!","category":"page"},{"location":"basis/#ModelingToolkit.parameters","page":"Basis","title":"ModelingToolkit.parameters","text":"parameters(basis)\n\nReturns the parameters of the basis.\n\n\n\n\n\n","category":"function"},{"location":"basis/#DataDrivenDiffEq.variables","page":"Basis","title":"DataDrivenDiffEq.variables","text":"variables(basis)\n\nReturns the dependent variables of the basis.\n\n\n\n\n\n","category":"function"},{"location":"basis/#ModelingToolkit.independent_variable","page":"Basis","title":"ModelingToolkit.independent_variable","text":"independent_variable(basis)\n\nReturns the independent_variable of the basis.\n\n\n\n\n\n","category":"function"},{"location":"basis/#DataDrivenDiffEq.jacobian","page":"Basis","title":"DataDrivenDiffEq.jacobian","text":"jacobian(basis)\n\nReturns a function representing the jacobian matrix / gradient of the `Basis` with respect to the\ndependent variables as a function with the common signature `f(u,p,t)` for out of place and `f(du, u, p, t)` for in place computation.\n\n\n\n\n\n","category":"function"},{"location":"basis/#DataDrivenDiffEq.dynamics","page":"Basis","title":"DataDrivenDiffEq.dynamics","text":"dynamics(basis)\n\nReturns the internal function representing the dynamics of the `Basis`.\n\n\n\n\n\n","category":"function"},{"location":"basis/#Base.push!","page":"Basis","title":"Base.push!","text":"push!(basis, op)\n\nPush the operation(s) in `op` into the basis and update all internal fields accordingly.\n`op` can either be a single `Operation` or an Array of `Operation`s.\n\n\n\n\n\n","category":"function"},{"location":"basis/#Base.deleteat!","page":"Basis","title":"Base.deleteat!","text":"deleteat!(basis, inds)\n\nDelete the entries specified by `inds` and update the `Basis` accordingly.\n\n\n\n\n\n","category":"function"},{"location":"basis/#Base.merge","page":"Basis","title":"Base.merge","text":"merge(basis_a, basis_b)\n\nReturn a new `Basis`, which is defined via the union of both bases.\n\n\n\n\n\n","category":"function"},{"location":"basis/#Base.merge!","page":"Basis","title":"Base.merge!","text":"merge!(basis_a, basis_b)\n\nUpdates the `Basis` to include the union of both bases.\n\n\n\n\n\n","category":"function"},{"location":"sparse_identification/isindy/#Implicit-Sparse-Identification-of-Nonlinear-Dynamics-1","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"","category":"section"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"While SINDy works well for ODEs, some systems take the form of DAEs. A common form is f(x, p, t) - g(x, p, t)*dx = 0. These can be inferred via ISINDy, which extends SINDy for Implicit problems. In particular, it solves","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"Xi = min  leftlVert Theta(X p t)^T Xi rightrVert_2 + lambda  leftlVert Xi rightrVert_1","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"where Xi lies in the nullspace of Theta.","category":"page"},{"location":"sparse_identification/isindy/#Example-:-Michaelis-Menten-Kinetics-1","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Example : Michaelis-Menten Kinetics","text":"","category":"section"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"Let's try to infer the Michaelis-Menten Kinetics, like in the corresponding paper. We start by generating the corresponding data.","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing OrdinaryDiffEq\nusing LinearAlgebra\nusing Plots\ngr()\n\nfunction michaelis_menten(u, p, t)\n    [0.6 - 1.5u[1]/(0.3+u[1])]\nend\n\nu0 = [0.5]\ntspan = (0.0, 5.0)\nproblem = ODEProblem(michaelis_menten, u0, tspan)\n\nsolution = solve(problem, Tsit5(), saveat = 0.1, atol = 1e-7, rtol = 1e-7)\n    \nplot(solution) # hide\nsavefig(\"iSINDy_example.png\")","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"(Image: )","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"X = solution[:,:]\nDX = similar(X)\nfor (i, xi) in enumerate(eachcol(X))\n    DX[:, i] = michaelis_menten(xi, [], 0.0)\nend\n\n@variables u\nbasis= Basis([u^i for i in 0:4], [u])","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"The signature of ISINDy is equal to SINDy, but requires an AbstractSubspaceOptimizer. Currently, DataDrivenDiffEq just implements ADM() based on alternating directions. rtol gets passed into the derivation of the nullspace via LinearAlgebra.","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"opt = ADM(1.1e-1)","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"Since ADM() returns sparsified columns of the nullspace we need to find a pareto optimal solution. To achieve this, we provide a sufficient cost function g to ISINDy. This allows us to evaluate each individual column of the sparse matrix on its 0-norm (sparsity) and the 2-norm of the matrix vector product of Theta^T xi (nullspace). This is a default setting which can be changed by providing a function f which maps the coefficients and the library onto a feature space. Here, we want to set the focus on the the magnitude of the deviation from the nullspace.","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"Ψ = ISINDy(X, DX, basis, opt, g = x->norm([1e-1*x[1]; x[2]]), maxiter = 1000, rtol = 0.99)\nnothing #hide","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"The function call returns a SparseIdentificationResult. As in Sparse Identification of Nonlinear Dynamics, we can transform the SparseIdentificationResult into an ODESystem.","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"# Transform into ODE System\nsys = ODESystem(Ψ)\ndudt = ODEFunction(sys)\nps = parameters(Ψ)\n\nestimator = ODEProblem(dudt, u0, tspan, ps)\nestimation = solve(estimator, Tsit5(), saveat = 0.1)\n\nplot(solution, color = :red, label = \"True\") # hide\nplot!(estimation, color = :green, label = \"Estimation\") # hide\nsavefig(\"iSINDy_example_final.png\") # hide","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"(Image: )","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"The model recovered by ISINDy is  correct","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"print_equations(Ψ)","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"The parameters are off a little, but, as before, we can use DiffEqFlux to tune them.","category":"page"},{"location":"sparse_identification/isindy/#Example-:-Cart-Pole-with-Time-Dependent-Control-1","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Example : Cart-Pole with Time-Dependent Control","text":"","category":"section"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"Implicit dynamics can also be reformulated as an explicit problem as stated in this paper. The algorithm searches the correct equations by trying out all candidate functions as a right hand side and performing a sparse regression onto the remaining set of candidates. Let's start by defining the problem and generate the data:","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"\nusing DataDrivenDiffEq\nusing ModelingToolkit\nusing OrdinaryDiffEq\nusing LinearAlgebra\nusing Plots\ngr()\n\nfunction cart_pole(u, p, t)\n    du = similar(u)\n    F = -0.2 + 0.5*sin(6*t) # the input\n    du[1] = u[3]\n    du[2] = u[4]\n    du[3] = -(19.62*sin(u[1])+sin(u[1])*cos(u[1])*u[3]^2+F*cos(u[1]))/(2-cos(u[1])^2)\n    du[4] = -(sin(u[1])*u[3]^2 + 9.81*sin(u[1])*cos(u[1])+F)/(2-cos(u[1])^2)\n    return du\nend\n\nu0 = [0.3; 0; 1.0; 0]\ntspan = (0.0, 16.0)\ndt = 0.001\ncart_pole_prob = ODEProblem(cart_pole, u0, tspan)\nsolution = solve(cart_pole_prob, Tsit5(), saveat = dt)\n\n# Create the differential data\nX = solution[:,:]\nDX = similar(X)\nfor (i, xi) in enumerate(eachcol(X))\n    DX[:, i] = cart_pole(xi, [], solution.t[i])\nend\n\nplot(solution) # hide\nsavefig(\"iSINDy_cartpole_data.png\") # hide\n","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"(Image: )","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"We see that we include a forcing term F inside the model which is depending on t. As before, we will also need a Basis to derive our equations from:","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"@variables u[1:4] t\npolys = Operation[]\nfor i ∈ 0:4\n    if i == 0\n        push!(polys, u[1]^0)\n    else\n        if i < 2\n            push!(polys, u.^i...)\n        else\n            push!(polys, u[3:4].^i...)\n        end\n        \n    end\nend\npush!(polys, sin.(u[1])...)\npush!(polys, cos.(u[1]))\npush!(polys, sin.(u[1]).*u[3:4]...)\npush!(polys, sin.(u[1]).*u[3:4].^2...)\npush!(polys, cos.(u[1]).^2...)\npush!(polys, sin.(u[1]).*cos.(u[1])...)\npush!(polys, sin.(u[1]).*cos.(u[1]).*u[3:4]...)\npush!(polys, sin.(u[1]).*cos.(u[1]).*u[3:4].^2...)\npush!(polys, -0.2+0.5*sin(6*t))\npush!(polys, (-0.2+0.5*sin(6*t))*cos(u[1]))\npush!(polys, (-0.2+0.5*sin(6*t))*sin(u[1]))\nbasis= Basis(polys, u, iv = t)","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"We added the time dependent input directly into the basis to account for its influence.","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"NOTE : Including input signals may change in future releases!","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"Like for a SINDy, we can use any AbstractOptimizer with a pareto front optimization over different thresholds. ","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"λ = exp10.(-4:0.1:-1)\ng(x) = norm([1e-3; 10.0] .* x, 2)\nΨ = ISINDy(X[:,:], DX[:, :], basis, λ, STRRidge(), maxiter = 100, normalize = false, t = solution.t, g = g)\n\n# Transform into ODE System\nsys = ODESystem(Ψ)\ndudt = ODEFunction(sys)\nps = parameters(Ψ)\n\n# Simulate\nestimator = ODEProblem(dudt, u0, tspan, ps)\nsol_ = solve(estimator, Tsit5(), saveat = dt)\n\nplot(solution.t[:], solution[:,:]', color = :red, label = nothing) # hide\nplot!(sol_.t, sol_[:, :]', color = :green, label = \"Estimation\") # hide\nsavefig(\"iSINDy_cartpole_estimation.png\") # hide","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"(Image: )","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"Let's have a look at the equations recovered. They match up.","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"print_equations(Ψ)","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"Alternatively, we can also use the input as an extended state x.","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"@variables u[1:4] t x\npolys = Operation[]\n# Lots of basis functions -> sindy pi can handle more than ADM()\nfor i ∈ 0:4\n    if i == 0\n        push!(polys, u[1]^0)\n    else\n        if i < 2\n            push!(polys, u.^i...)\n        else\n            push!(polys, u[3:4].^i...)\n        end\n        \n    end\nend\npush!(polys, sin.(u[1])...)\npush!(polys, cos.(u[1]))\npush!(polys, sin.(u[1]).*u[3:4]...)\npush!(polys, sin.(u[1]).*u[3:4].^2...)\npush!(polys, cos.(u[1]).^2...)\npush!(polys, sin.(u[1]).*cos.(u[1])...)\npush!(polys, sin.(u[1]).*cos.(u[1]).*u[3:4]...)\npush!(polys, sin.(u[1]).*cos.(u[1]).*u[3:4].^2...)\npush!(polys, x)\npush!(polys, x*cos(u[1]))\npush!(polys, x*sin(u[1]))\nbasis= Basis(polys, vcat(u, x), iv = t)","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"Now we include the input signal into the extended state array Xᵤ and perform a sparse regression.","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"U = -0.2 .+ 0.5*sin.(6*solution.t)\nXᵤ = vcat(X, U')\n\nλ = exp10.(-4:0.5:-1)\ng(x) = norm([1e-3; 10.0] .* x, 2)\nΨ = ISINDy(Xᵤ[:,:], DX[:, :], basis, λ, STRRidge(), maxiter = 100, normalize = false, t = solution.t, g = g)\nprint_equations(Ψ, show_parameter = true)","category":"page"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"Currently, we can not generate an ODESystem out of the resulting equations, which is a work in progress.","category":"page"},{"location":"sparse_identification/isindy/#Functions-1","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Functions","text":"","category":"section"},{"location":"sparse_identification/isindy/#","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"Implicit Sparse Identification of Nonlinear Dynamics","text":"ISINDy","category":"page"},{"location":"sparse_identification/isindy/#DataDrivenDiffEq.ISINDy","page":"Implicit Sparse Identification of Nonlinear Dynamics","title":"DataDrivenDiffEq.ISINDy","text":"ISINDy(X, Y, Ψ, opt = ADM(); f, g, maxiter, rtol, p, t, convergence_error)\nISINDy(X, Y, Ψ, opt; f, g, maxiter, rtol, p, t, convergence_error, normalize, denoise)\nISINDy(X, Y, Ψ, lamdas, opt; f, g, maxiter, rtol, p, t, convergence_error, normalize, denoise)\n\nPerforms an implicit sparse identification of nonlinear dynamics given the data matrices X and Y via the AbstractBasis basis. Keyworded arguments include the parameter (values) of the basis p and the timepoints t, which are passed in optionally. Tries to find a sparse vector inside the nullspace if opt is an AbstractSubspaceOptimizer or performs parallel implicit search if opt is a AbstractOptimizer. maxiter denote the maximum iterations to perform and convergence_error the bound which causes the optimizer to stop. denoise defines if the matrix holding candidate trajectories should be thresholded via the optimal threshold for singular values. normalize normalizes the matrix holding candidate trajectories via the L2-Norm over each function.\n\nTypically X represent the state measurements and Y the measurements of the differential state. Since only the number of measurements (column dimension of the matrices) have to be equal, it is possible to augment X with additional data, e.g. external forcing or inputs.\n\nIf ISINDy is called with an additional array of thresholds contained in lambdas, it performs a multi objective optimization over all thresholds. The best vectors of the sparse nullspace are selected via multi-objective optimization. The best candidate is determined via the mapping onto a feature space f and an (scalar, positive definite) evaluation g. The signature of should be f(xi, theta) where xi are the coefficients of the sparse optimization and theta is the evaluated candidate library. rtol gets directly passed into the computation of the nullspace.\n\nCurrently ISINDy supports functions of the form g(u, p, t)*du - f(u, p, t) = 0.\n\nReturns a SparseIdentificationResult.\n\n\n\n\n\n","category":"function"},{"location":"koopman/koopman/#koopman_operator-1","page":"Koopman Operators","title":"Koopman Operators","text":"","category":"section"},{"location":"koopman/koopman/#","page":"Koopman Operators","title":"Koopman Operators","text":"LinearKoopman\nNonlinearKoopman","category":"page"},{"location":"koopman/koopman/#DataDrivenDiffEq.LinearKoopman","page":"Koopman Operators","title":"DataDrivenDiffEq.LinearKoopman","text":"LinearKoopman(K, B, Q, P, discrete)\n\nAn approximation of the Koopman operator which is linear in the states.\n\nK is the array representing the operator, B is the (possible present) array representing the influence of exogenous inputs on the evolution.\n\nQ and P are matrices used for updating the operator with new measurements. discrete indicates if the operator is discrete or continuous.\n\nThe Koopman operator is callable with the typical signature of f(u,p,t) and f(du,u,p,t), respectively.\n\nExample\n\nk = LinearKoopman([1.0 0; 0 0.3], [], [], [], true)\n\nu = k([2.0; 0.5], nothing, nothing)\ndu = similar(u)\nk(du, u, nothing, nothing)\n\n\n\n\n\n","category":"type"},{"location":"koopman/koopman/#DataDrivenDiffEq.NonlinearKoopman","page":"Koopman Operators","title":"DataDrivenDiffEq.NonlinearKoopman","text":"NonlinearKoopman(K, B, C, basis, Q, P, discrete)\n\nAn approximation of the Koopman operator which is nonlinear in the states.\n\nK is the array representing the operator, B is the (possible present) array representing the influence of exogenous inputs on the evolution. C is the array mapping from the Koopman space to the original state space. basis is a [Basis]@ref(Basis), mapping the state space to the Koopman space.\n\nQ and P are matrices used for updating the operator with new measurements. discrete indicates if the operator is discrete or continuous.\n\nThe Koopman operator is callable with the typical signature of f(u,p,t) and f(du,u,p,t), respectively.\n\nExample\n\nk = EDMD(X, basis)\n\nu = k([2.0; 0.5], nothing, nothing)\ndu = similar(u)\nk(du, u, nothing, nothing)\n\n\n\n\n\n","category":"type"},{"location":"koopman/koopman/#Functions-1","page":"Koopman Operators","title":"Functions","text":"","category":"section"},{"location":"koopman/koopman/#","page":"Koopman Operators","title":"Koopman Operators","text":"operator\ngenerator\ninputmap\noutputmap\nupdate!\nis_discrete\nis_continuous\nupdatable\nisstable\neigen\neigvals\neigvecs\nmodes\nfrequencies\nreduce_basis","category":"page"},{"location":"koopman/koopman/#DataDrivenDiffEq.operator","page":"Koopman Operators","title":"DataDrivenDiffEq.operator","text":"operator(k)\n\nReturn the approximation of the discrete Koopman operator stored in `k`.\n\n\n\n\n\n","category":"function"},{"location":"koopman/koopman/#DataDrivenDiffEq.generator","page":"Koopman Operators","title":"DataDrivenDiffEq.generator","text":"generator(k)\n\nReturn the approximation of the continuous Koopman generator stored in `k`.\n\n\n\n\n\n","category":"function"},{"location":"koopman/koopman/#DataDrivenDiffEq.inputmap","page":"Koopman Operators","title":"DataDrivenDiffEq.inputmap","text":"inputmap(k)\n\nReturn the array `B`, mapping the exogenous inputs to the Koopman space.\n\n\n\n\n\n","category":"function"},{"location":"koopman/koopman/#DataDrivenDiffEq.outputmap","page":"Koopman Operators","title":"DataDrivenDiffEq.outputmap","text":"outputmap(k)\n\nReturn the array `C`, mapping the Koopman space back onto the state space.\n\n\n\n\n\n","category":"function"},{"location":"koopman/koopman/#DataDrivenDiffEq.update!","page":"Koopman Operators","title":"DataDrivenDiffEq.update!","text":"update!(k, X, Y; threshold = eps())\n\nUpdate the Koopman k given new data X and Y. The operator is updated in place if the L2 error of the prediction exceeds the threshold.\n\n\n\n\n\nupdate!(k, X, Y; p = [], t = [], threshold = eps())\n\nUpdate the Koopman k given new data X and Y. The operator is updated in place if the L2 error of the prediction exceeds the threshold.\n\np and t are the parameters of the basis and the vector of timepoints, if necessary.\n\n\n\n\n\n","category":"function"},{"location":"koopman/koopman/#DataDrivenDiffEq.is_discrete","page":"Koopman Operators","title":"DataDrivenDiffEq.is_discrete","text":"is_discrete(k)\n\nReturns if the AbstractKoopmanOperator k is discrete in time.\n\n\n\n\n\n","category":"function"},{"location":"koopman/koopman/#DataDrivenDiffEq.isstable","page":"Koopman Operators","title":"DataDrivenDiffEq.isstable","text":"isstable(k)\n\nReturns `true` if either:\n\n+ the Koopman operator has just eigenvalues with magnitude less than one or\n+ the Koopman generator has just eigenvalues with a negative real part\n\n\n\n\n\n","category":"function"},{"location":"koopman/koopman/#LinearAlgebra.eigen","page":"Koopman Operators","title":"LinearAlgebra.eigen","text":"eigen(k)\n\nReturn the eigendecomposition of the `AbstractKoopmanOperator`.\n\n\n\n\n\n","category":"function"},{"location":"koopman/koopman/#LinearAlgebra.eigvals","page":"Koopman Operators","title":"LinearAlgebra.eigvals","text":"eigevals(k)\n\nReturn the eigenvalues of the `AbstractKoopmanOperator`.\n\n\n\n\n\n","category":"function"},{"location":"koopman/koopman/#LinearAlgebra.eigvecs","page":"Koopman Operators","title":"LinearAlgebra.eigvecs","text":"eigvecs(k)\n\nReturn the eigenvectors of the `AbstractKoopmanOperator`.\n\n\n\n\n\n","category":"function"},{"location":"koopman/koopman/#DataDrivenDiffEq.modes","page":"Koopman Operators","title":"DataDrivenDiffEq.modes","text":"modes(k)\n\nReturn the eigenvectors of a continuous `AbstractKoopmanOperator`.\n\n\n\n\n\n","category":"function"},{"location":"koopman/koopman/#DataDrivenDiffEq.frequencies","page":"Koopman Operators","title":"DataDrivenDiffEq.frequencies","text":"frequencies(k)\n\nReturn the eigenvalues of a continuous `AbstractKoopmanOperator`.\n\n\n\n\n\n","category":"function"},{"location":"koopman/koopman/#DataDrivenDiffEq.reduce_basis","page":"Koopman Operators","title":"DataDrivenDiffEq.reduce_basis","text":"reduce_basis(k; threshold)\n\nReduces the basis of the nonlinear Koopman using the 1-norm of each row of the matrix C*K. Rows where the threshold is not reached are deleted.\n\n\n\n\n\n","category":"function"},{"location":"utils/#Utility-Functions-1","page":"Utilities","title":"Utility Functions","text":"","category":"section"},{"location":"utils/#","page":"Utilities","title":"Utilities","text":"AIC\nAICC\nBIC\noptimal_shrinkage\nsavitzky_golay\nburst_sampling\nsubsample","category":"page"},{"location":"utils/#DataDrivenDiffEq.AIC","page":"Utilities","title":"DataDrivenDiffEq.AIC","text":"AIC(k, X, Y; likelihood = (X, Y) = sum(abs2, X-Y))\n\nComputes the Akaike Information Criterion (AIC) given the free parameters k for the data X and its estimate Y of the model. likelihood can be any function of X and Y.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DataDrivenDiffEq.AICC","page":"Utilities","title":"DataDrivenDiffEq.AICC","text":"AICC(k, X, Y; likelihood = (X, Y) = sum(abs2, X-Y))\n\nComputes the Akaike Information Criterion compensated for finite samples (AICC) given the free parameters k for the data X and its estimate Y of the model. likelihood can be any function of X and Y.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DataDrivenDiffEq.BIC","page":"Utilities","title":"DataDrivenDiffEq.BIC","text":"BIC(k, X, Y; likelihood = (X, Y) = sum(abs2, X-Y))\n\nComputes Bayes Information Criterion (BIC) given the free parameters k for the data X and its estimate Y of the model. likelihood can be any function of X and Y.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DataDrivenDiffEq.optimal_shrinkage","page":"Utilities","title":"DataDrivenDiffEq.optimal_shrinkage","text":"optimal_shrinkage(X)\noptimal_shrinkage!(X)\n\nCompute a feature reduced version of the data array X via thresholding the singular values by computing the optimal threshold for singular values.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DataDrivenDiffEq.savitzky_golay","page":"Utilities","title":"DataDrivenDiffEq.savitzky_golay","text":"savitzky_golay(X, windowSize, polyOrder; deriv, dt, crop)\n\nEstimate the time derivative via the savitzky_golay filter. X is the data matrix containing the trajectories, which is interpolated via polynomials of order polyOrder over windowSize points repeatedly. deriv defines the order of the derivative, dt the time step size. crop indicates if the original data should be returned cropped along the derivative approximation.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DataDrivenDiffEq.burst_sampling","page":"Utilities","title":"DataDrivenDiffEq.burst_sampling","text":"burst_sampling(X, samplesize, n)\n\nRandomly selects n bursts of data with size samplesize from the data X.\n\n\n\n\n\nburst_sampling(X, Y, samplesize, n)\n\nRandomly selects n bursts of data with size samplesize from the data X and Y.\n\n\n\n\n\nburst_sampling(X, t, period, n)\n\nRandomly selects n bursts of data within a time window period from the data X. The time information has to be provided in t.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DataDrivenDiffEq.subsample","page":"Utilities","title":"DataDrivenDiffEq.subsample","text":"subsample(X, n)\n\nReturns the subsampled X with only every n-th entry.\n\n\n\n\n\nsubsample(X, t, dt)\n\nReturns the subsampled X with a a minimum period of dt between two data points. t provides the time information.\n\n\n\n\n\n","category":"function"},{"location":"sparse_identification/optimizers/#Optimizer-1","page":"Optimizer","title":"Optimizer","text":"","category":"section"},{"location":"sparse_identification/optimizers/#","page":"Optimizer","title":"Optimizer","text":"DataDrivenDiffEq comes with some implementations for sparse regression included. All of these are stored inside the DataDrivenDiffEq.Optimize package and extend the AbstractOptimizer, if an explicit optimization is needed or the AbstractSubspaceOptimizer for an implicit problem (where the solution is within the nullspace).","category":"page"},{"location":"sparse_identification/optimizers/#Functions-1","page":"Optimizer","title":"Functions","text":"","category":"section"},{"location":"sparse_identification/optimizers/#","page":"Optimizer","title":"Optimizer","text":"STRRidge\nADMM\nSR3\nDataDrivenDiffEq.Optimize.ADM","category":"page"},{"location":"sparse_identification/optimizers/#DataDrivenDiffEq.Optimize.STRRidge","page":"Optimizer","title":"DataDrivenDiffEq.Optimize.STRRidge","text":"STRRidge(λ = 0.1)\n\nSTRRidge is taken from the original paper on SINDY and implements a sequentially thresholded least squares iteration. λ is the threshold of the iteration. It is based upon this matlab implementation.\n\nExample\n\nopt = STRRidge()\nopt = STRRidge(1e-1)\n\n\n\n\n\n","category":"type"},{"location":"sparse_identification/optimizers/#DataDrivenDiffEq.Optimize.ADMM","page":"Optimizer","title":"DataDrivenDiffEq.Optimize.ADMM","text":"ADMM()\nADMM(λ, ρ)\n\nADMM is an implementation of Lasso using the alternating direction methods of multipliers and loosely based on this implementation.\n\nλ is the sparsification parameter, ρ the augmented Lagrangian parameter.\n\nExample\n\nopt = ADMM()\nopt = ADMM(1e-1, 2.0)\n\n\n\n\n\n","category":"type"},{"location":"sparse_identification/optimizers/#DataDrivenDiffEq.Optimize.SR3","page":"Optimizer","title":"DataDrivenDiffEq.Optimize.SR3","text":"SR3(λ, ν, R)\nSR3(λ = 1e-1, ν = 1.0)\n\nSR3 is an optimizer framework introduced by Zheng et. al., 2018 and used within Champion et. al., 2019. SR3 contains a sparsification parameter λ, a relaxation ν, and a corresponding penalty function R, which should be taken from ProximalOperators.jl.\n\nExamples\n\nopt = SR3()\nopt = SR3(1e-2)\nopt = SR3(1e-3, 1.0)\n\n\n\n\n\n","category":"type"},{"location":"sparse_identification/optimizers/#DataDrivenDiffEq.Optimize.ADM","page":"Optimizer","title":"DataDrivenDiffEq.Optimize.ADM","text":"ADM()\nADM(λ = 0.1)\n\nOptimizer for finding a sparse basis vector in a subspace based on this paper. λ is the weight for the soft-thresholding operation.\n\n\n\n\n\n","category":"type"},{"location":"sparse_identification/optimizers/#Implementing-New-Optimizer-1","page":"Optimizer","title":"Implementing New Optimizer","text":"","category":"section"},{"location":"sparse_identification/optimizers/#","page":"Optimizer","title":"Optimizer","text":"Similarly to Algorithms for Estimation, the extension of optimizers is more or less straightforward. Suppose you want to define a new optimizer MyOpt, which should solve AX = Y for a sparse X.","category":"page"},{"location":"sparse_identification/optimizers/#","page":"Optimizer","title":"Optimizer","text":"mutable struct MyOpt <: DataDrivenDiffEq.Optimize.AbstractOptimizer\n    threshold\nend","category":"page"},{"location":"sparse_identification/optimizers/#","page":"Optimizer","title":"Optimizer","text":"To use MyOpt within SINDy, an init! function has to be implemented.","category":"page"},{"location":"sparse_identification/optimizers/#","page":"Optimizer","title":"Optimizer","text":"function init!(X::AbstractArray, o::MyOpt, A::AbstractArray, Y::AbstractArray)\n    X .=  A \\ Y\nend","category":"page"},{"location":"sparse_identification/optimizers/#","page":"Optimizer","title":"Optimizer","text":"To perform thresholding - and use maybe for searching the right threshold - a setter and getter is required:","category":"page"},{"location":"sparse_identification/optimizers/#","page":"Optimizer","title":"Optimizer","text":"set_threshold!(opt::MyOpt, threshold) = opt.threshold .= threshold\n\nget_threshold(opt::MyOpt) = opt.threshold","category":"page"},{"location":"sparse_identification/optimizers/#","page":"Optimizer","title":"Optimizer","text":"And, at last, the method which fits the data and returns the iterations needed:","category":"page"},{"location":"sparse_identification/optimizers/#","page":"Optimizer","title":"Optimizer","text":"function fit!(X::AbstractArray, A::AbstractArray, Y::AbstractArray, opt::MyOpt; maxiter, convergence_error)\n    # Compute awesome stuff here\n    return iterations\nend","category":"page"},{"location":"koopman/edmd/#Extended-Dynamic-Mode-Decomposition-1","page":"Extended Dynamic Mode Decomposition","title":"Extended Dynamic Mode Decomposition","text":"","category":"section"},{"location":"koopman/edmd/#","page":"Extended Dynamic Mode Decomposition","title":"Extended Dynamic Mode Decomposition","text":"Extended Dynamic Mode Decomposition is a method for generating an approximating linear differential equation in a chosen basis of observables. If X and Y are data matrices containing points of the same trajectory and Ψ is a basis, then EDMD approximates","category":"page"},{"location":"koopman/edmd/#","page":"Extended Dynamic Mode Decomposition","title":"Extended Dynamic Mode Decomposition","text":"K = Ψ(Y)Ψ(X)^dagger","category":"page"},{"location":"koopman/edmd/#","page":"Extended Dynamic Mode Decomposition","title":"Extended Dynamic Mode Decomposition","text":"where dagger denotes the Moore-Penrose pseudoinverse and K is the approximation of the Koopman Operator.","category":"page"},{"location":"koopman/edmd/#","page":"Extended Dynamic Mode Decomposition","title":"Extended Dynamic Mode Decomposition","text":"EDMD approximates discrete time systems of the form","category":"page"},{"location":"koopman/edmd/#","page":"Extended Dynamic Mode Decomposition","title":"Extended Dynamic Mode Decomposition","text":"Psi(u_i+1) = K  Psi(u_i) \nu_i+1 = CPsi(u_i)","category":"page"},{"location":"koopman/edmd/#","page":"Extended Dynamic Mode Decomposition","title":"Extended Dynamic Mode Decomposition","text":"gEDMD approximates continuous time systems of the form","category":"page"},{"location":"koopman/edmd/#","page":"Extended Dynamic Mode Decomposition","title":"Extended Dynamic Mode Decomposition","text":"fracddtPsi(u) =  K_G  Psi(u) \nfracddtu = CfracddtPsi(u)","category":"page"},{"location":"koopman/edmd/#","page":"Extended Dynamic Mode Decomposition","title":"Extended Dynamic Mode Decomposition","text":"where K_G is the generator of the Koopman Operator. C is a matrix mapping from the observations back onto the states or differential states.","category":"page"},{"location":"koopman/edmd/#Functions-1","page":"Extended Dynamic Mode Decomposition","title":"Functions","text":"","category":"section"},{"location":"koopman/edmd/#","page":"Extended Dynamic Mode Decomposition","title":"Extended Dynamic Mode Decomposition","text":"EDMD\ngEDMD","category":"page"},{"location":"koopman/edmd/#DataDrivenDiffEq.EDMD","page":"Extended Dynamic Mode Decomposition","title":"DataDrivenDiffEq.EDMD","text":"EDMD(X, basis; alg, p, t, C)\nEDMD(X, Y, basis; alg, p, t, C)\n\nApproximates a 'NonlinearKoopman' with the AbstractKoopmanAlgorithm 'alg' from the data matrices X or X and Y, respectively. If only X is given, the data is split into X[:, 1:end-1] and X[:, 2:end].\n\nAdditional keyworded arguments include p for the parameter of the basis and t for an array of time points. C is the matrix representing the mapping from the Koopman space into the state space.\n\nExample\n\n@parameters p[1] t\n@variables u[1:2]\nh = Operation[u; sin.(u); cos(p[1]*t)]\nbasis = Basis(h, u, parameters = p, iv = t)\nkoopman = EDMD(X, basis, p = [2.0], t = collect(0:0.2:10.0), C = Float64[1 0 0 0 0; 0 1 0 0 0])\n\n\n\n\n\n","category":"function"},{"location":"koopman/edmd/#DataDrivenDiffEq.gEDMD","page":"Extended Dynamic Mode Decomposition","title":"DataDrivenDiffEq.gEDMD","text":"gEDMD(X, Y, basis; alg, p, t, C)\ngEDMD(t, X, basis; dt, p, C, alg, fdm, itp)\n\nApproximates a 'NonlinearKoopman' with the AbstractKoopmanAlgorithm 'alg' from the data matrices X and Y. X should contain the state trajectory and Y the differential state trajectory.\n\nIf no measurements of the differential state are available, gEDMD can be called with measurement time points t as the first argument. It will then create an interpolation using the interpolation method from DataInterpolations.jl defined in itp. The trajectory will then be resampled to equidistant measurements over time corresponding to the mean of diff(t) or dt, if given. The differential state measurements will be computed via 'FiniteDifferences.jl', given a FiniteDifferenceMethod in fdm.\n\nExample\n\nkoopman = gEDMD(X, Y, basis)\n\nfdm = backward_fdm(5,1)\nitp = CubicSpline\nkoopman = gEDMD(t, X, basis, fdm = fdm, itp = itp)\n\n\n\n\n\n","category":"function"},{"location":"quickstart/#Quickstart-1","page":"Getting Started","title":"Quickstart","text":"","category":"section"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"In the following, we will use some of the techniques provided by DataDrivenDiffEq to infer some models.","category":"page"},{"location":"quickstart/#Linear-Damped-Oscillator-Dynamic-Mode-Decomposition-1","page":"Getting Started","title":"Linear Damped Oscillator - Dynamic Mode Decomposition","text":"","category":"section"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"To begin, let's create our own data for the linear oscillator with damping.","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"using OrdinaryDiffEq\nusing Plots\ngr()\n\nusing DataDrivenDiffEq\nusing LinearAlgebra\n\nfunction linear!(du, u, p, t)\n  du[1] = u[2]\n  du[2] = -u[1] - 0.1*u[2]\nend\n\nu0 = Float64[0.99π; -0.3]\ntspan = (0.0, 40.0)\n\nproblem = ODEProblem(linear!, u0, tspan)\nsolution = solve(problem, Tsit5(), saveat = 1.0)\n\nplot(solution)\nsavefig(\"linear_solution.png\") #hide","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"Let's assume we have just the trajectory data and let's call it X. Since we gathered the data at a fixed interval of one time unit, we will try to fit a linear model. And, of course, we use a subset of the data for training and the rest for testing.","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"\nX = Array(solution)\n\napproximation = DMD(X[:, 1:20])\n\napprox_prob = DiscreteProblem(approximation, u0, tspan)\napprox_sol = solve(approx_prob, FunctionMap())\n\nplot(approx_sol, label = [\"u[1]\" \"u[2]\"]) #hide\nscatter!(solution, label = [\"True u[1]\" \"True u[2]\"]) #hide\nsavefig(\"pendulum_approximation.png\") #hide","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"Yeah! The model fits! But what exactly did we do?","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"DMD is short for Dynamic Mode Decomposition, a technique which generates a linear model from data. So, given the data matrix X, we simply divided it up into two data sets and performed a linear fitting between those.","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"Note that we fitted a discrete model, which fits our continuous data. This is possible because:","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"The measurements were taken at an interval of 1.0\nThe original, unknown model has a discrete, linear solution","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"To check this, we can compare the operator of our linear fit with the matrix exponential of the original model.","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"dt = 1.0\nK = operator(approximation)\nnorm(K - exp(dt*[0.0 1.0; -1.0 -0.1]), 2)","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"The reason for using operator as a function to get the corresponding matrix of the approximation is the connection of Dynamic Mode Decomposition to the Koopman Operator. You might have noticed that the return value of DMD is a LinearKoopman.","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"The LinearKoopman overloads some useful functions from LinearAlgebra to perform analysis. Let's have a look at the eigenvalues of the operator:","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"scatter(eigvals(approximation))\n\n# Add the stability margin\nϕ = 0:0.01π:2π\nplot!(cos.(ϕ), sin.(ϕ),\n  color = :red, linestyle = :dot,\n  label = \"Stability Margin\",\n  xlim = (-1,1), ylim = (-1,1), legend = :bottomleft)\n\nsavefig(\"eigenvalue_lineardamped.png\") #hide","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"For more information on the LinearKoopman, have a look at the corresponding documentation.","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"But wait! We want a continuous model. There is also a corresponding algorithm for this : gDMD ! As opposed to DMD, which provides a discrete model based on the direct measurements X, gDMD estimates the generator of the dynamical system given X and the differential states DX. Since we did not measure any differential states, we can just provide a vector of time measurements. gDMD will automatically interpolate using DataInterpolations.jl and perform numerical differentiation using FiniteDifferences.jl.","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"Here, we will provide gDMD with the measurement data and use a new sample time of 0.1","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"t = solution.t\nX = Array(solution)\n\ngenerator_approximation = gDMD(t[1:20], X[:, 1:20], dt = 0.1)\n\ngenerator_prob = ODEProblem(generator_approximation, u0 , tspan)\ngenerator_sol = solve(generator_prob, Tsit5())\n\nplot(generator_sol, label = [\"u[1]\" \"u[2]\"]) #hide\nscatter!(solution, label = [\"True u[1]\" \"True u[2]\"]) #hide\nsavefig(\"linear_approximation_cont.png\") #hide","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"Since we have a continuous estimation, let's look at the generator of the estimation","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"G = generator(generator_approximation)\nnorm(G-[0.0 1.0; -1.0 -0.1], 2)","category":"page"},{"location":"quickstart/#Nonlinear-Systems-Extended-Dynamic-Mode-Decomposition-1","page":"Getting Started","title":"Nonlinear Systems - Extended Dynamic Mode Decomposition","text":"","category":"section"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"But what about nonlinear systems? Even though Dynamic Mode Decomposition will help us to figure out the best linear fit, we are interested in figuring out all the nonlinear parts of the equations. Luckily, Koopman theory covers this! To put it very (very very) simply : If you spread out your information in many observable functions, you will end up with a linear system in those observables. So you might end up with a trade-off between a huge system which is linear in the observables vs a small, nonlinear system.","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"But how can we leverage this? We use the Extended Dynamic Mode Decomposition, or EDMD for short. EDMD does more or less the exact same thing like DMD, but in the new Basis of nonlinear observables. We will investigate now a fairly standard system, with a slow and fast manifold, for which there exists an analytical solution of this problem.","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"using OrdinaryDiffEq\nusing Plots\ngr()\n\nusing DataDrivenDiffEq\nusing LinearAlgebra\nusing ModelingToolkit\n\nfunction slow_manifold(du, u, p, t)\n  du[1] = p[1]*u[1]\n  du[2] = p[2]*(u[2]-u[1]^2)\nend\n\nu0 = [3.0; -2.0]\ntspan = (0.0, 10.0)\np = [-0.05, -1.0]\n\nproblem = ODEProblem(slow_manifold, u0, tspan, p)\nsolution = solve(problem, Tsit5(), saveat = 0.2)\n\nX = Array(solution)\nDX = solution(solution.t, Val{1})\n\nplot(solution) # hide\nsavefig(\"slow_manifold.png\") # hide","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"Since we want to estimate the continuous system, we also capture the trajectory of the differential states. Now, we will create our nonlinear observables, which is represented as a Basis in DataDrivenDiffEq.jl.","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"@variables u[1:2]\n\nobservables = [u; u[1]^2]\n\nbasis = Basis(observables, u)","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"A Basis captures a bunch of functions defined over some variables provided via ModelingToolkit.jl. Here, we included the state and u[1]^2. Now, we simply call gEDMD, which will compute the generator of the Koopman Operator associated with the model.","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"approximation = gEDMD(X, DX, basis)\n\napproximation_problem = ODEProblem(approximation, u0, tspan)\ngenerator_sol = solve(approximation_problem, Tsit5(), saveat = solution.t)\n\nplot(generator_sol, label = [\"u[1]\" \"u[2]\"]) #hide\nscatter!(solution, label = [\"True u[1]\" \"True u[2]\"]) #hide\nsavefig(\"slow_approximation_cont.png\") #hide\nscatter(eigvals(approximation), label = \"Estimate\") # hide\nscatter!(eigvals([p[1] 0 0; 0 p[2] -p[2]; 0 0 2*p[1]]), label = \"True\", legend = :bottomright) #hide\nsavefig(\"eigenvalue_slowmanifold.png\") #hide\n","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"Looking at the eigenvalues of the system, we see that the estimated eigenvalues of the linear system are close to the true values.","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"quickstart/#Nonlinear-Systems-Sparse-Identification-of-Nonlinear-Dynamics-1","page":"Getting Started","title":"Nonlinear Systems - Sparse Identification of Nonlinear Dynamics","text":"","category":"section"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"Okay, so far we can fit linear models via DMD and nonlinear models via EDMD. But what if we want to find a model of a nonlinear system without moving to Koopman space? Simple, we use Sparse Identification of Nonlinear Dynamics or SINDy.","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"As the name suggests, SINDy finds the sparsest basis of functions which build the observed trajectory. Again, we will start with a nonlinear system","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing OrdinaryDiffEq\nusing LinearAlgebra\nusing Plots\ngr()\n\nfunction pendulum(u, p, t)\n    x = u[2]\n    y = -9.81sin(u[1]) - 0.1u[2]\n    return [x;y]\nend\n\nu0 = [0.4π; 1.0]\ntspan = (0.0, 20.0)\nproblem = ODEProblem(pendulum, u0, tspan)\nsolution = solve(problem, Tsit5(), atol = 1e-8, rtol = 1e-8, saveat = 0.001)\n\nX = Array(solution)\nDX = solution(solution.t, Val{1})\n\nplot(solution) # hide\nsavefig(\"nonlinear_pendulum.png\") # hide","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"which is the simple nonlinear pendulum with damping.","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"Suppose we are like John and know nothing about the system, we have just the data in front of us. To apply SINDy, we need three ingredients:","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"A Basis containing all possible candidate functions which might be in the model\nAn optimizer which is able to produce a sparse output\nA threshold for the optimizer","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"It might seem to you that the third point is more a parameter of the optimizer (which it is), but, nevertheless, it is a crucial decision where to cut off parameters.","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"So, let's create a bunch of basis functions for our problem first","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"\n@variables u[1:2]\n\nh = Operation[u; u.^2; u.^3; sin.(u); cos.(u); 1]\n\nbasis = Basis(h, u)\nnothing # hide","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"DataDrivenDiffEq comes with some optimizers to tackle sparse regression problems. Here, we will use SR3, used here and introduced here. We choose a threshold of 3.5e-1 and start the optimizer.","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"opt = SR3(3e-1, 1.0)\nΨ = SINDy(X[:, 1:1000], DX[:, 1:1000], basis, opt, maxiter = 10000, normalize = true)\nprint_equations(Ψ) # hide","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"We recovered the equations! Let's transform the SINDyResult into a performant piece of Julia Code using ODESystem","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"sys = ODESystem(Ψ)\np = parameters(Ψ)\n\ndudt = ODEFunction(sys)\n\nestimator = ODEProblem(dudt, u0, tspan, p)\nestimation = solve(estimator, Tsit5(), saveat = solution.t)\n\nplot(solution.t[1:1000], solution[:,1:1000]', color = :red, line = :dot, label = nothing) # hide\nplot!(solution.t[1000:end], solution[:,1000:end]', color = :blue, line = :dot,label = nothing) # hide\nplot!(estimation, color = :green, label = \"Estimation\") # hide\nsavefig(\"SINDy_estimation.png\") # hide","category":"page"},{"location":"quickstart/#","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"sparse_identification/sindy/#Sparse-Identification-of-Nonlinear-Dynamics-1","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"","category":"section"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"Sparse Identification of Nonlinear Dynamics - or SINDy - identifies the equations of motion of a system as the result of a sparse regression over a chosen basis. In particular, it tries to find coefficients Xi such that:","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"Xi = min  leftlVert Y^T - Theta(X p t)^T Xi rightrVert_2 + lambda  leftlVert Xi rightrVert_1","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"where, in most cases, Yis the data matrix containing the derivatives of the state data stored in X. Theta is a matrix containing candidate functions xi over the measurements in X.","category":"page"},{"location":"sparse_identification/sindy/#Example-1","page":"Sparse Identification of Nonlinear Dynamics","title":"Example","text":"","category":"section"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"As in the original paper, we will estimate the Lorenz System. First, let's create the necessary data and have a look at the trajectory.","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing OrdinaryDiffEq\n\nusing LinearAlgebra\nusing Plots\ngr()\n\n# Create a test problem\nfunction lorenz(u,p,t)\n    x, y, z = u\n    ẋ = 10.0*(y - x)\n    ẏ = x*(28.0-z) - y\n    ż = x*y - (8/3)*z\n    return [ẋ, ẏ, ż]\nend\n\nu0 = [-8.0; 7.0; 27.0]\np = [10.0; -10.0; 28.0; -1.0; -1.0; 1.0; -8/3]\ntspan = (0.0,100.0)\ndt = 0.001\nproblem = ODEProblem(lorenz,u0,tspan)\nsolution = solve(problem, Tsit5(), saveat = dt, atol = 1e-7, rtol = 1e-8)\n\nplot(solution,vars=(1,2,3), legend = false) #hide\nsavefig(\"lorenz.png\") #hide","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"(Image: )","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"Additionally, we generate the ideal derivative data.","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"X = Array(solution)\nDX = similar(X)\nfor (i, xi) in enumerate(eachcol(X))\n    DX[:,i] = lorenz(xi, [], 0.0)\nend","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"To generate the symbolic equations, we need to define a Basis over the variables x y z. In this example, we will use all monomials up to degree of 4 and their products:","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"@variables x y z\nu = Operation[x; y; z]\npolys = Operation[]\nfor i ∈ 0:4\n    for j ∈ 0:i\n        for k ∈ 0:j\n            push!(polys, u[1]^i*u[2]^j*u[3]^k)\n            push!(polys, u[2]^i*u[3]^j*u[1]^k)\n            push!(polys, u[3]^i*u[1]^j*u[2]^k)\n        end\n    end\nend\n\nbasis = Basis(polys, u)\nnothing #hide","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"A Basis consists of unique functions, so duplicates will be included just once","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"To perform the sparse identification on our data, we need to define an Optimizer. Here, we will use STRRidge, which is described in the original paper. The threshold of the optimizer is set to 0.1. An overview of the different optimizers can be found below.","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"opt = STRRidge(0.1)\nΨ = SINDy(X, DX, basis, opt, maxiter = 100, normalize = true)","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"Ψ is a SINDyResult, which stores some about the regression. As we can see, we have 7 active terms inside the model. To look at the equations, simply type","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"print_equations(Ψ)","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"First, let's have a look at the L2-Error and Akaikes Information Criterion of the result","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"get_error(Ψ)","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"get_aicc(Ψ)","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"We can also access the coefficient matrix Xi directly via get_coefficients(Ψ).","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"To generate a numerical model usable in DifferentialEquations, we simply use the ODESystem function from ModelingToolkit. The resulting parameters used for the identification can be accessed via parameters(Ψ). The returned vector also includes the parameters of the original Basis used to generate the result.","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"ps = parameters(Ψ)\nsys = ODESystem(Ψ)\ndudt = ODEFunction(sys)\n\nprob = ODEProblem(dudt, u0, tspan, ps)\nsol = solve(prob, Tsit5(), saveat = solution.t, atol = 1e-7, rtol = 1e-8)\n\nϵ = norm.(eachcol(solution .- sol)) # hide\nplot(solution.t, ϵ .+ eps(), yaxis = :log, legend = false) # hide\nxlabel!(\"Time [s]\") # hide\nylabel!(\"L2 Error\") # hide\nsavefig(\"lorenz_error.png\") # hide\nplot(solution, vars = (0, 1), label = \"True\") # hide\nplot!(sol, vars = (0,1), label = \"Estimation\") # hide\nsavefig(\"lorenz_trajectory_estimate.png\") # hide","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"Let's have a look at the trajectory of u_1(t).","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"(Image: )","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"Finally, let's investigate the error of the chaotic equations:","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"(Image: )","category":"page"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"which resembles the papers results. Next, we could use classical parameter estimation methods or use DiffEqFlux to fine-tune our result (if needed).","category":"page"},{"location":"sparse_identification/sindy/#Functions-1","page":"Sparse Identification of Nonlinear Dynamics","title":"Functions","text":"","category":"section"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"SINDy\nsparse_regression","category":"page"},{"location":"sparse_identification/sindy/#DataDrivenDiffEq.SINDy","page":"Sparse Identification of Nonlinear Dynamics","title":"DataDrivenDiffEq.SINDy","text":"SINDy(X, Y, basis, opt = STRRidge(); p, t, maxiter, convergence_error, denoise, normalize)\nSINDy(X, Y, basis, lambdas, opt = STRRidge(); f, g, p, t, opt, maxiter, convergence_error, denoise, normalize)\n\nPerforms Sparse Identification of Nonlinear Dynamics given the data matrices X and Y via the AbstractBasis basis. Keyworded arguments include the parameter (values) of the basis p and the timepoints t which are passed in optionally. opt is an AbstractOptimizer useable for sparse regression, maxiter the maximum iterations to perform and convergence_error the bound which causes the optimizer to stop. denoise defines if the matrix holding candidate trajectories should be thresholded via the optimal threshold for singular values. normalize normalizes the matrix holding candidate trajectories via the L2-Norm over each function.\n\nTypically X represent the state measurements and Y the measurements of the differential state. Since only the number of measurements (column dimension of the matrices) have to be equal, it is possible to augment X with additional data, e.g. external forcing or inputs.\n\nIf SINDy is called with an additional array of thresholds contained in lambdas, it performs a multi objective optimization over all thresholds. The best candidate is determined via the mapping onto a feature space f and an (scalar, positive definite) evaluation g. The signature of should be f(xi, theta, yi) where xi are the coefficients of the sparse optimization,theta is the evaluated candidate library and yi are the rows of the matrix Y. Returns a SINDyResult. If the pareto optimization is used, the result combines the best candidate for each row of Y.\n\n\n\n\n\n","category":"function"},{"location":"sparse_identification/sindy/#DataDrivenDiffEq.sparse_regression","page":"Sparse Identification of Nonlinear Dynamics","title":"DataDrivenDiffEq.sparse_regression","text":"sparse_regression(X, Y, basis, p, t, maxiter, opt, denoise, normalize, convergence_error)\nsparse_regression!(Xi, X, Y, basis, p, t, maxiter, opt, denoise, normalize, convergence_error)\nspares_regression!(Xi, Theta, Y, maxiter, opt, denoise, normalize, convergence_error)\n\nPerforms a sparse regression via the algorithm opt <: AbstractOptimizer. maxiter specifies the upper bound of the iterations of the optimizer, convergence_error the breaking condition due to convergence. denoise defines if the matrix holding candidate trajectories should be thresholded via the optimal threshold for singular values. normalize normalizes the matrix holding candidate trajectories via the L2-Norm over each function.\n\nIf the data matrices X, Y are given with a Basis basis and the additional information for parameters p and time points of the measurements t, it returns the coefficient matrix Xi and the iterations taken. This function is also available in place, which returns just the iterations.\n\nIf Xi, Theta and Y are given, the sparse regression will find the coefficients Xi, which minimize the objective and return the iterations needed.\n\nExample\n\nopt = STRRidge()\nmaxiter = 10\nc_error = 1e-3\n\nXi, iters = sparse_regression(X, Y, basis, [], [], maxiter, opt, false, false, c_error)\n\niters = sparse_regression!(Xi,X, Y, basis, [], [], maxiter, opt, false, false, c_error)\n\nXi2 = zeros(size(Y, 1), size(X, 1))\niters = sparse_regression!(Xi2, X, Y, maxiter, opt, false, false, c_error)\n\n\n\n\n\n","category":"function"},{"location":"sparse_identification/sindy/#","page":"Sparse Identification of Nonlinear Dynamics","title":"Sparse Identification of Nonlinear Dynamics","text":"SparseIdentificationResult\nget_sparsity\nget_error\nget_aicc\nget_coefficients","category":"page"},{"location":"sparse_identification/sindy/#DataDrivenDiffEq.SparseIdentificationResult","page":"Sparse Identification of Nonlinear Dynamics","title":"DataDrivenDiffEq.SparseIdentificationResult","text":"SparseIdentificationResult()\n\nContains the result of a sparse identification. Contains the coefficient matrix Ξ, the equations of motion, and its associated parameters. It also stores the optimizer, iteration counter, and convergence status.\n\nAdditionally, the model is evaluated over the training data and the L_2-error, Akaikes Information Criterion, and the L_0-Norm of the coefficients is stored.\n\n\n\n\n\n","category":"type"},{"location":"sparse_identification/sindy/#DataDrivenDiffEq.get_sparsity","page":"Sparse Identification of Nonlinear Dynamics","title":"DataDrivenDiffEq.get_sparsity","text":"get_sparsity(res)\n\nReturn the L_0-Norm of the SparseIdentificationResult\n\n\n\n\n\n","category":"function"},{"location":"sparse_identification/sindy/#DataDrivenDiffEq.get_error","page":"Sparse Identification of Nonlinear Dynamics","title":"DataDrivenDiffEq.get_error","text":"get_error(res)\n\nReturn the L_2-Error of the SparseIdentificationResult over the training data.\n\n\n\n\n\n","category":"function"},{"location":"sparse_identification/sindy/#DataDrivenDiffEq.get_aicc","page":"Sparse Identification of Nonlinear Dynamics","title":"DataDrivenDiffEq.get_aicc","text":"get_aicc(res)\n\nReturn Akaikakes Information Criterion of the SparseIdentificationResult over the training data.\n\n\n\n\n\n","category":"function"},{"location":"sparse_identification/sindy/#DataDrivenDiffEq.get_coefficients","page":"Sparse Identification of Nonlinear Dynamics","title":"DataDrivenDiffEq.get_coefficients","text":"get_coefficients(res)\n\nReturn the coefficient matrix Ξ of the SparseIdentificationResult.\n\n\n\n\n\n","category":"function"},{"location":"#DataDrivenDiffEq.jl-1","page":"Home","title":"DataDrivenDiffEq.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"DataDrivenDiffEq.jl is a package for estimating equation-free and equation-based models for discrete and continuous differential equations.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"As opposed to parameter identification, these methods aim to find the governing equations of motion automatically from a given set of data. They do not require a known model as input. Instead, these methods take in data and return the differential equation model which generated the data.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"There are various avenues in which structural estimation can occur. However, the main branches are: do you want to know the equations in a human-understandable manner, or is it sufficient to have a function that predicts the derivative and generates the correct time series? We will refer to methods which return symbolic forms of the differential equation as structural identification, while those which return functions only for prediction as structural estimation.","category":"page"},{"location":"#Package-Overview-1","page":"Home","title":"Package Overview","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"DataDrivenDiffEq currently implements the following algorithms for structural estimation:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Dynamic Mode Decomposition\nExtended Dynamic Mode Decomposition\nSparse Identification of Nonlinear Dynamics\nImplicit Sparse Identification of Nonlinear Dynamics","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"To use 'DataDrivenDiffEq.jl', simply install it via:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"]add DataDrivenDiffEq\nusing DataDrivenDiffEq","category":"page"}]
}
