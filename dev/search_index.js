var documenterSearchIndex = {"docs":
[{"location":"solvers/symbolic_regression/#symbolic_regression_api","page":"Symbolic Regression","title":"Symbolic Regression","text":"","category":"section"},{"location":"solvers/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"DataDrivenDiffEq includes the following symbolic regression algorithms.","category":"page"},{"location":"solvers/symbolic_regression/#SymbolicRegression.jl","page":"Symbolic Regression","title":"SymbolicRegression.jl","text":"","category":"section"},{"location":"solvers/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"warning: Warning\nThis feature requires the explicit loading of SymbolicRegression.jl in addition to DataDrivenDiffEq. It will only be useable if loaded like:using DataDrivenDiffEq\nusing SymbolicRegressionCurrently DataDrivenDiffEq supports version 0.6.14 up to 0.6.19.","category":"page"},{"location":"solvers/symbolic_regression/#Symbolic-Regression","page":"Symbolic Regression","title":"Symbolic Regression","text":"","category":"section"},{"location":"solvers/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"See the tutorial.","category":"page"},{"location":"solvers/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"EQSearch","category":"page"},{"location":"solvers/symbolic_regression/#DataDrivenDiffEq.EQSearch","page":"Symbolic Regression","title":"DataDrivenDiffEq.EQSearch","text":"struct EQSearch <: DataDrivenDiffEq.AbstractSymbolicRegression\n\nOptions for using SymbolicRegression.jl within the solve function. Automatically creates Options with the given specification. Sorts the operators stored in functions into unary and binary operators on conversion.\n\nFields\n\nfunctions\nOperators used for symbolic regression\nkwargs\nAdditionally keyworded arguments passed to SymbolicRegression.Options\n\n\n\n\n\n","category":"type"},{"location":"solvers/symbolic_regression/#occamnet_api","page":"Symbolic Regression","title":"OccamNet","text":"","category":"section"},{"location":"solvers/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"warning: Warning\nThis feature requires the explicit loading of Flux.jl in addition to DataDrivenDiffEq. It will only be useable if loaded like:using DataDrivenDiffEq\nusing Flux","category":"page"},{"location":"solvers/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"OccamNet\nOccamSR\nProbabilityLayer","category":"page"},{"location":"solvers/symbolic_regression/#DataDrivenDiffEq.OccamNet","page":"Symbolic Regression","title":"DataDrivenDiffEq.OccamNet","text":"mutable struct OccamNet{F, C, P} <: DataDrivenDiffEq.AbstractOccam\n\nDefines an OccamNet which learns symbolic expressions from data using a probabilistic approach. See Interpretable Neuroevolutionary Models for Learning Non-Differentiable Functions and Programs  for more details.\n\nIt get constructed via:\n\nnet = OccamNet(inp::Int, outp::Int, layers::Int, f::Vector{Function}, t::Real = 1.0; constants = typeof(t)[], parameters::Int = 0, skip::Bool = false, init_w = ones, init_p = Flux.glorot_uniform)\n\ninp describes the size of the input domain, outp the size of the output domain, layers the number of layers (including the input layer and excluding the linear output layer) and f the functions to be used. Optional is the temperature t which is set to 1.0 at the beginning.\n\nKeyworded arguments are constants, a vector of constants like π, ℯ which can concatenated to the input, the number of trainable parameters and if skip connections should be used. The constructors to the weights and parameters can be passed in via init_w and init_p.\n\nOccamNet is callable with and without a specific route, which can be sampled from the networks weights via rand(net).\n\nFields\n\nc\nThe Chain representing the network\nconstants\nAdditional constants added to the input which are not trainable.\nparameters\nAdditional parameters added to the input which are trainable.\n\n\n\n\n\n","category":"type"},{"location":"solvers/symbolic_regression/#DataDrivenDiffEq.OccamSR","page":"Symbolic Regression","title":"DataDrivenDiffEq.OccamSR","text":"struct OccamSR{F, C, T} <: DataDrivenDiffEq.AbstractSymbolicRegression\n\nOptions for using OccamNet within the solve function. Automatically creates a network with the given specification.\n\nFields\n\nfunctions\nFunctions used within the network\nconstants\nConstants added to the input\nlayers\nNumber of layers\nparameters\nNumber of parameters\nskip\nActivate skip connections\n\n\n\n\n\n","category":"type"},{"location":"solvers/symbolic_regression/#DataDrivenDiffEq.ProbabilityLayer","page":"Symbolic Regression","title":"DataDrivenDiffEq.ProbabilityLayer","text":"mutable struct ProbabilityLayer{F, W, T, A} <: DataDrivenDiffEq.AbstractProbabilityLayer\n\nDefines a basic ProbabilityLayer in which the parameters act as probabilities via the softmax function for an array of functions.\n\nThe layer is callable either via layer(x), using all weights to form the output or by layer(x, route) where route is the result of rand(layer) which samples the function arguments from the underlying distribution.\n\nFields\n\nop\nNonlinear functions forming the basis of the layer\nweight\nWeights\nt\nTemperature controlling the shape of the distribution\narieties\nArities of the functions\nskip\nSkip connection\n\n\n\n\n\n","category":"type"},{"location":"solvers/symbolic_regression/#Related-Functions","page":"Symbolic Regression","title":"Related Functions","text":"","category":"section"},{"location":"solvers/symbolic_regression/","page":"Symbolic Regression","title":"Symbolic Regression","text":"set_temp!\nprobability\nlogprobability\nprobabilities\nlogprobabilities","category":"page"},{"location":"solvers/symbolic_regression/#DataDrivenDiffEq.set_temp!","page":"Symbolic Regression","title":"DataDrivenDiffEq.set_temp!","text":"set_temp!(p, t)\n\n\nSet the temperature of the ProbabilityLayer or OccamNet.\n\n\n\n\n\n","category":"function"},{"location":"solvers/symbolic_regression/#DataDrivenDiffEq.probability","page":"Symbolic Regression","title":"DataDrivenDiffEq.probability","text":"probability(o, route)\n\n\nReturns the probability of the result of the OccamNet using the specific route.\n\n\n\n\n\n","category":"function"},{"location":"solvers/symbolic_regression/#DataDrivenDiffEq.logprobability","page":"Symbolic Regression","title":"DataDrivenDiffEq.logprobability","text":"logprobability(o, route)\n\n\nReturns the logprobability of the result of the OccamNet using the specific route.\n\n\n\n\n\n","category":"function"},{"location":"solvers/symbolic_regression/#DataDrivenDiffEq.probabilities","page":"Symbolic Regression","title":"DataDrivenDiffEq.probabilities","text":"probabilities(p)\n\n\nReturn the probability associated with the ProbabilityLayer or OccamNet by applying softmax on the weights.\n\n\n\n\n\n","category":"function"},{"location":"solvers/symbolic_regression/#DataDrivenDiffEq.logprobabilities","page":"Symbolic Regression","title":"DataDrivenDiffEq.logprobabilities","text":"logprobabilities(p)\n\n\nReturn the logprobability associated with the ProbabilityLayer or OccamNet by applying logsoftmax on the weights.\n\n\n\n\n\n","category":"function"},{"location":"contributions/#Contributions","page":"Contributing","title":"Contributions","text":"","category":"section"},{"location":"contributions/","page":"Contributing","title":"Contributing","text":"Contributions are welcome! To help, please:","category":"page"},{"location":"contributions/","page":"Contributing","title":"Contributing","text":"Open (or solve) an issue\nReview pull requests\nAdapt code to be more efficient\nWrite new optimizers or algorithms\nWrite tutorials or adapt the docs","category":"page"},{"location":"contributions/","page":"Contributing","title":"Contributing","text":"Feel free to write a private message to @AlCap23 for further discussion.","category":"page"},{"location":"citations/#Citing","page":"Citing","title":"Citing","text":"","category":"section"},{"location":"citations/","page":"Citing","title":"Citing","text":"If you are using DataDrivenDiffEq.jl for research, please cite","category":"page"},{"location":"citations/","page":"Citing","title":"Citing","text":"@software{datadrivendiffeq,\n  author       = {JuliusMartensen and\n                  Christopher Rackauckas and others},\n  title        = {DataDrivenDiffEq.jl},\n  month        = jul,\n  year         = 2021,\n  publisher    = {Zenodo},\n  doi          = {10.5281/zenodo.5083412},\n  url          = {https://doi.org/10.5281/zenodo.5083412}\n}","category":"page"},{"location":"citations/","page":"Citing","title":"Citing","text":"If you are using the SymbolicRegression.jl API, please cite","category":"page"},{"location":"citations/","page":"Citing","title":"Citing","text":"@software{pysr,\n  author       = {Miles Cranmer},\n  title        = {PySR: Fast \\& Parallelized Symbolic Regression in Python/Julia},\n  month        = sep,\n  year         = 2020,\n  publisher    = {Zenodo},\n  doi          = {10.5281/zenodo.4041459},\n  url          = {http://doi.org/10.5281/zenodo.4041459}\n}","category":"page"},{"location":"examples/0_getting_started/","page":"Getting Started","title":"Getting Started","text":"EditURL = \"https://github.com/SciML/DataDrivenDiffEq.jl/blob/master/docs/examples/0_getting_started.jl\"","category":"page"},{"location":"examples/0_getting_started/#getting_started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"examples/0_getting_started/","page":"Getting Started","title":"Getting Started","text":"The workflow for DataDrivenDiffEq.jl is similar to other SciML packages. You start by defining a DataDrivenProblem and then dispatch on the solve command to return a DataDrivenSolution.","category":"page"},{"location":"examples/0_getting_started/","page":"Getting Started","title":"Getting Started","text":"Here is an outline of the required elements and choices:","category":"page"},{"location":"examples/0_getting_started/","page":"Getting Started","title":"Getting Started","text":"Define a problem using your data.\nChoose a basis.\nThis is optional depending on which solver you choose.\nSolve the problem.","category":"page"},{"location":"examples/0_getting_started/","page":"Getting Started","title":"Getting Started","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing LinearAlgebra","category":"page"},{"location":"examples/0_getting_started/","page":"Getting Started","title":"Getting Started","text":"Generate a test problem","category":"page"},{"location":"examples/0_getting_started/","page":"Getting Started","title":"Getting Started","text":"f(u) = u.^2 .+ 2.0u .- 1.0\nX = randn(1, 100);\nY = reduce(hcat, map(f, eachcol(X)));\nnothing #hide","category":"page"},{"location":"examples/0_getting_started/","page":"Getting Started","title":"Getting Started","text":"Create a problem from the data","category":"page"},{"location":"examples/0_getting_started/","page":"Getting Started","title":"Getting Started","text":"problem = DirectDataDrivenProblem(X, Y, name = :Test)","category":"page"},{"location":"examples/0_getting_started/","page":"Getting Started","title":"Getting Started","text":"Choose a basis","category":"page"},{"location":"examples/0_getting_started/","page":"Getting Started","title":"Getting Started","text":"@variables u\nbasis = Basis(monomial_basis([u], 2), [u])\nprintln(basis)","category":"page"},{"location":"examples/0_getting_started/","page":"Getting Started","title":"Getting Started","text":"Solve the problem, using the solver of your choosing","category":"page"},{"location":"examples/0_getting_started/","page":"Getting Started","title":"Getting Started","text":"res = solve(problem, basis, STLSQ())\nprintln(res)\nprintln(result(res))","category":"page"},{"location":"examples/0_getting_started/#getting_started_code","page":"Getting Started","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"examples/0_getting_started/","page":"Getting Started","title":"Getting Started","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing LinearAlgebra\n\nf(u) = u.^2 .+ 2.0u .- 1.0\nX = randn(1, 100);\nY = reduce(hcat, map(f, eachcol(X)));\n\nproblem = DirectDataDrivenProblem(X, Y, name = :Test)\n\n@variables u\nbasis = Basis(monomial_basis([u], 2), [u])\nprintln(basis)\n\nres = solve(problem, basis, STLSQ())\nprintln(res)\nprintln(result(res))\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/0_getting_started/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"examples/0_getting_started/","page":"Getting Started","title":"Getting Started","text":"This page was generated using Literate.jl.","category":"page"},{"location":"solutions/#Solutions","page":"Solutions","title":"Solutions","text":"","category":"section"},{"location":"solutions/","page":"Solutions","title":"Solutions","text":"DataDrivenSolution","category":"page"},{"location":"solutions/#DataDrivenDiffEq.DataDrivenSolution","page":"Solutions","title":"DataDrivenDiffEq.DataDrivenSolution","text":"struct DataDrivenSolution{L, A, O} <: DataDrivenDiffEq.AbstractDataDrivenSolution\n\nThe solution to a DataDrivenProblem derived via a certain algorithm. The solution is represented via an AbstractBasis, which makes it callable.\n\nFields\n\nbasis\nThe basis representation of the solution\nparameters\nParameters of the solution\nretcode\nReturncode\nalg\nAlgorithm\nout\nOriginal output of the solution algorithm\nprob\nProblem\nl2_error\nL₂ norm error\naic\nAIC\nrsquared\nCoefficient of determinantion\n\nNote\n\nThe L₂ norm error, AIC and coefficient of determinantion get only computed, if eval_expression is set to true or if the solution can be interpreted as a linear regression result.\n\n\n\n\n\n","category":"type"},{"location":"solutions/#Functions","page":"Solutions","title":"Functions","text":"","category":"section"},{"location":"solutions/","page":"Solutions","title":"Solutions","text":"result\nget_problem\nmetrics\nparameters\nparameter_map\naic\nl2error\ndetermination\nalgorithm\noutput","category":"page"},{"location":"solutions/#DataDrivenDiffEq.result","page":"Solutions","title":"DataDrivenDiffEq.result","text":"result(r)\n\n\nReturns the Basis of the result.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#DataDrivenDiffEq.get_problem","page":"Solutions","title":"DataDrivenDiffEq.get_problem","text":"get_problem(r)\n\n\nReturns the original DataDrivenProblem.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#DataDrivenDiffEq.metrics","page":"Solutions","title":"DataDrivenDiffEq.metrics","text":"metrics(r)\n\n\nReturns all applicable metrics of the solution.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#ModelingToolkit.parameters","page":"Solutions","title":"ModelingToolkit.parameters","text":"parameters(r)\n\n\nReturns the estimated parameters in form of an Vector.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#DataDrivenDiffEq.parameter_map","page":"Solutions","title":"DataDrivenDiffEq.parameter_map","text":"parameter_map(r)\n\n\nGenerate a mapping of the parameter values and symbolic representation useable to solve and ODESystem.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#DataDrivenDiffEq.aic","page":"Solutions","title":"DataDrivenDiffEq.aic","text":"aic(r)\n\n\nReturns the AIC of the result.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#DataDrivenDiffEq.l2error","page":"Solutions","title":"DataDrivenDiffEq.l2error","text":"l2error(r)\n\n\nReturns the L₂ norm error of the result.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#DataDrivenDiffEq.determination","page":"Solutions","title":"DataDrivenDiffEq.determination","text":"Returns the coefficient of determinantion of the result, if the result has been derived via a linear regression, e.g. sparse regression or koopman.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#DataDrivenDiffEq.algorithm","page":"Solutions","title":"DataDrivenDiffEq.algorithm","text":"algorithm(r)\n\n\nReturns the algorithm used to derive the solution.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#DataDrivenDiffEq.output","page":"Solutions","title":"DataDrivenDiffEq.output","text":"output(r)\n\n\nReturns the original output of the algorithm.\n\n\n\n\n\n","category":"function"},{"location":"examples/10_noisy_nonlinear/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"EditURL = \"https://github.com/SciML/DataDrivenDiffEq.jl/blob/master/docs/examples/10_noisy_nonlinear.jl\"","category":"page"},{"location":"examples/10_noisy_nonlinear/#noisy_sindy","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"","category":"section"},{"location":"examples/10_noisy_nonlinear/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"Many data real world data sources are corrupted with measurment noise, which can have a big impact on the recovery of the underlying equations of motion. This example show how we can use collocation and batching to perform SINDy in the presence of noise.","category":"page"},{"location":"examples/10_noisy_nonlinear/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing ModelingToolkit\nusing OrdinaryDiffEq\nusing Plots\ngr()\n\nfunction pendulum(u, p, t)\n    x = u[2]\n    y = -9.81sin(u[1]) - 0.3u[2]^3 -3.0*cos(u[1]) - 10.0*exp(-((t-5.0)/5.0)^2)\n    return [x;y]\nend\n\nu0 = [0.99π; -1.0]\ntspan = (0.0, 15.0)\nprob = ODEProblem(pendulum, u0, tspan)\nsol = solve(prob, Tsit5(), saveat = 0.01)","category":"page"},{"location":"examples/10_noisy_nonlinear/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"We add random noise to our measurements.","category":"page"},{"location":"examples/10_noisy_nonlinear/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"X = sol[:,:] + 0.2 .* randn(size(sol));\nts = sol.t;\n\nplot(ts, X', color = :red)\nplot!(sol, color = :black)","category":"page"},{"location":"examples/10_noisy_nonlinear/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"To estimate the system, we first create a DataDrivenProblem via feeding in the measurement data. Using a Collocation method, it automatically provides the derivative and smoothes the trajectory. Control signals can be passed in as a function (u,p,t)->control or an array of measurements.","category":"page"},{"location":"examples/10_noisy_nonlinear/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"prob = ContinuousDataDrivenProblem(X, ts, GaussianKernel() ,\n    U = (u,p,t)->[exp(-((t-5.0)/5.0)^2)], p = ones(2))\n\nplot(prob, size = (600,600))","category":"page"},{"location":"examples/10_noisy_nonlinear/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"Now we infer the system structure. First we define a Basis which collects all possible candidate terms. Since we want to use SINDy, we call solve with an Optimizer, in this case STLSQ which iterates different sparsity thresholds and returns a pareto optimal solution of the underlying sparse_regression!. Note that we include the control signal in the basis as an additional variable c.","category":"page"},{"location":"examples/10_noisy_nonlinear/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"@variables u[1:2] c[1:1]\n@parameters w[1:2]\nu = collect(u)\nc = collect(c)\nw = collect(w)\n\nh = Num[sin.(w[1].*u[1]);cos.(w[2].*u[1]); polynomial_basis(u, 5); c]\n\nbasis = Basis(h, u, parameters = w, controls = c)","category":"page"},{"location":"examples/10_noisy_nonlinear/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"To solve the problem, we also define a DataSampler which defines randomly shuffled minibatches of our data and selects the best fit.","category":"page"},{"location":"examples/10_noisy_nonlinear/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"sampler = DataSampler(Batcher(n = 5, shuffle = true, repeated = true))\nλs = exp10.(-10:0.1:-1)\nopt = STLSQ(λs)\nres = solve(prob, basis, opt, progress = false, sampler = sampler, denoise = false, normalize = false, maxiter = 5000)\nprintln(res) #hide","category":"page"},{"location":"examples/10_noisy_nonlinear/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"info: Info\nA more detailed description of the result can be printed via print(res, Val{true}), which also includes the discovered equations and parameter values.","category":"page"},{"location":"examples/10_noisy_nonlinear/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"Where the resulting DataDrivenSolution stores information about the inferred model and the parameters:","category":"page"},{"location":"examples/10_noisy_nonlinear/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"system = result(res)\nparams = parameters(res)\nprintln(system) #hide\nprintln(params) #hide","category":"page"},{"location":"examples/10_noisy_nonlinear/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"And a visual check of the result can be perfomed via plotting the result","category":"page"},{"location":"examples/10_noisy_nonlinear/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"plot(\n    plot(prob), plot(res), layout = (1,2)\n)","category":"page"},{"location":"examples/10_noisy_nonlinear/#autoregulation_copy_paste","page":"Sparse Identification with noisy data","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"examples/10_noisy_nonlinear/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing ModelingToolkit\nusing OrdinaryDiffEq\n\nfunction pendulum(u, p, t)\n    x = u[2]\n    y = -9.81sin(u[1]) - 0.3u[2]^3 -3.0*cos(u[1]) - 10.0*exp(-((t-5.0)/5.0)^2)\n    return [x;y]\nend\n\nu0 = [0.99π; -1.0]\ntspan = (0.0, 15.0)\nprob = ODEProblem(pendulum, u0, tspan)\nsol = solve(prob, Tsit5(), saveat = 0.01)\n\nX = sol[:,:] + 0.2 .* randn(size(sol));\nts = sol.t;\n\nprob = ContinuousDataDrivenProblem(X, ts, GaussianKernel() ,\n    U = (u,p,t)->[exp(-((t-5.0)/5.0)^2)], p = ones(2))\n\n@variables u[1:2] c[1:1]\n@parameters w[1:2]\nu = collect(u)\nc = collect(c)\nw = collect(w)\n\nh = Num[sin.(w[1].*u[1]);cos.(w[2].*u[1]); polynomial_basis(u, 5); c]\n\nbasis = Basis(h, u, parameters = w, controls = c)\n\nsampler = DataSampler(Batcher(n = 5, shuffle = true, repeated = true))\nλs = exp10.(-10:0.1:-1)\nopt = STLSQ(λs)\nres = solve(prob, basis, opt, progress = false, sampler = sampler, denoise = false, normalize = false, maxiter = 5000)\nprintln(res) #hide\n\nsystem = result(res)\nparams = parameters(res)\nprintln(system) #hide\nprintln(params) #hide\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/10_noisy_nonlinear/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"","category":"page"},{"location":"examples/10_noisy_nonlinear/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/8_symbolic_regression/","page":"Symbolic Regression of Nonlinear Time Continuous Systems","title":"Symbolic Regression of Nonlinear Time Continuous Systems","text":"EditURL = \"https://github.com/SciML/DataDrivenDiffEq.jl/blob/master/docs/examples/8_symbolic_regression.jl\"","category":"page"},{"location":"examples/8_symbolic_regression/#symbolic_regression_simple","page":"Symbolic Regression of Nonlinear Time Continuous Systems","title":"Symbolic Regression of Nonlinear Time Continuous Systems","text":"","category":"section"},{"location":"examples/8_symbolic_regression/","page":"Symbolic Regression of Nonlinear Time Continuous Systems","title":"Symbolic Regression of Nonlinear Time Continuous Systems","text":"note: Note\n","category":"page"},{"location":"examples/8_symbolic_regression/","page":"Symbolic Regression of Nonlinear Time Continuous Systems","title":"Symbolic Regression of Nonlinear Time Continuous Systems","text":"Symbolic regression is using regularized evolution, simulated annealing, and gradient-free optimization to find suitable equations.   Hence, the performance might differ and depends strongly on the hyperparameters of the optimization.   This example might not recover the groundtruth, but is showing off the use within DataDrivenDiffEq.jl.","category":"page"},{"location":"examples/8_symbolic_regression/","page":"Symbolic Regression of Nonlinear Time Continuous Systems","title":"Symbolic Regression of Nonlinear Time Continuous Systems","text":"DataDrivenDiffEq offers an interface to SymbolicRegression.jl to infer more complex functions. To use it, simply load a sufficient version of SymbolicRegression (currently we support version 0.6.14 to 0.6.19).","category":"page"},{"location":"examples/8_symbolic_regression/","page":"Symbolic Regression of Nonlinear Time Continuous Systems","title":"Symbolic Regression of Nonlinear Time Continuous Systems","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing SymbolicRegression\nusing Plots\n\nA = [-0.9 0.2; 0.0 -0.5]\nB = [0.0; 1.0]\nu0 = [10.0; -10.0]\ntspan = (0.0, 20.0)\n\nf(u,p,t) = A*u .+ B .* sin(0.5*t)\n\nsys = ODEProblem(f, u0, tspan)\nsol = solve(sys, Tsit5(), saveat = 0.01);\nnothing #hide","category":"page"},{"location":"examples/8_symbolic_regression/","page":"Symbolic Regression of Nonlinear Time Continuous Systems","title":"Symbolic Regression of Nonlinear Time Continuous Systems","text":"We will use the data provided by our problem, but add the control signal U = sin(0.5*t) to it. Instead of using a function, like in another example","category":"page"},{"location":"examples/8_symbolic_regression/","page":"Symbolic Regression of Nonlinear Time Continuous Systems","title":"Symbolic Regression of Nonlinear Time Continuous Systems","text":"X = Array(sol)\nt = sol.t\nU = permutedims(sin.(0.5*t))\nprob = ContinuousDataDrivenProblem(X, t, U = U)","category":"page"},{"location":"examples/8_symbolic_regression/","page":"Symbolic Regression of Nonlinear Time Continuous Systems","title":"Symbolic Regression of Nonlinear Time Continuous Systems","text":"And plot the problems data.","category":"page"},{"location":"examples/8_symbolic_regression/","page":"Symbolic Regression of Nonlinear Time Continuous Systems","title":"Symbolic Regression of Nonlinear Time Continuous Systems","text":"plot(prob)","category":"page"},{"location":"examples/8_symbolic_regression/","page":"Symbolic Regression of Nonlinear Time Continuous Systems","title":"Symbolic Regression of Nonlinear Time Continuous Systems","text":"To solve our problem, we will use EQSearch, which provides a wrapper for the symbolic regression interface. By default, it takes in a Vector of Functions and additional keyworded arguments. We will stick to simple operations like subtraction and multiplication, use a L1DistLoss , limit the maximum size and punish complex equations while fitting our equations on minibatches.","category":"page"},{"location":"examples/8_symbolic_regression/","page":"Symbolic Regression of Nonlinear Time Continuous Systems","title":"Symbolic Regression of Nonlinear Time Continuous Systems","text":"alg = EQSearch([-, *], loss = L1DistLoss(), verbosity = 0, maxsize = 9, batching = true, batchSize = 50, parsimony = 0.01f0)","category":"page"},{"location":"examples/8_symbolic_regression/","page":"Symbolic Regression of Nonlinear Time Continuous Systems","title":"Symbolic Regression of Nonlinear Time Continuous Systems","text":"Again, we solve the problem to obtain a DataDrivenSolution. Note that any additional keyworded arguments are passed onto symbolic regressions EquationSearch with the exception of niterations which is max_iter","category":"page"},{"location":"examples/8_symbolic_regression/","page":"Symbolic Regression of Nonlinear Time Continuous Systems","title":"Symbolic Regression of Nonlinear Time Continuous Systems","text":"res = solve(prob, alg, max_iter = 300, numprocs = 0, multithreading = false)\nprintln(res)","category":"page"},{"location":"examples/8_symbolic_regression/","page":"Symbolic Regression of Nonlinear Time Continuous Systems","title":"Symbolic Regression of Nonlinear Time Continuous Systems","text":"We see that the system has been recovered correctly, indicated by the small error. A closer look at the equations r","category":"page"},{"location":"examples/8_symbolic_regression/","page":"Symbolic Regression of Nonlinear Time Continuous Systems","title":"Symbolic Regression of Nonlinear Time Continuous Systems","text":"system = result(res)\n\nprintln(system)","category":"page"},{"location":"examples/8_symbolic_regression/","page":"Symbolic Regression of Nonlinear Time Continuous Systems","title":"Symbolic Regression of Nonlinear Time Continuous Systems","text":"Shows that while not obvious, the representation And also plot the prediction of the recovered dynamics","category":"page"},{"location":"examples/8_symbolic_regression/","page":"Symbolic Regression of Nonlinear Time Continuous Systems","title":"Symbolic Regression of Nonlinear Time Continuous Systems","text":"plot(res)","category":"page"},{"location":"examples/8_symbolic_regression/","page":"Symbolic Regression of Nonlinear Time Continuous Systems","title":"Symbolic Regression of Nonlinear Time Continuous Systems","text":"To convert the result into an ODESystem, we substitute the control signal","category":"page"},{"location":"examples/8_symbolic_regression/","page":"Symbolic Regression of Nonlinear Time Continuous Systems","title":"Symbolic Regression of Nonlinear Time Continuous Systems","text":"u = controls(system)\nt = get_iv(system)\n\nsubs_control = (u[1] => sin(0.5*t))\n\neqs = map(equations(system)) do eq\n    eq.lhs ~ substitute(eq.rhs, subs_control)\nend\n\n@named sys = ODESystem(\n    eqs,\n    get_iv(system),\n    states(system),\n    []\n    );\nnothing #hide","category":"page"},{"location":"examples/8_symbolic_regression/","page":"Symbolic Regression of Nonlinear Time Continuous Systems","title":"Symbolic Regression of Nonlinear Time Continuous Systems","text":"And simulated using OrdinaryDiffEq.jl using the (known) initial conditions and the parameter mapping of the estimation. Since the parameters are hard numerical values we do not need to include those.","category":"page"},{"location":"examples/8_symbolic_regression/","page":"Symbolic Regression of Nonlinear Time Continuous Systems","title":"Symbolic Regression of Nonlinear Time Continuous Systems","text":"x = states(system)\nx0 = [x[1] => u0[1], x[2] => u0[2]]\n\node_prob = ODEProblem(sys, x0, tspan)\nestimate = solve(ode_prob, Tsit5(), saveat = prob.t);\nnothing #hide","category":"page"},{"location":"examples/8_symbolic_regression/","page":"Symbolic Regression of Nonlinear Time Continuous Systems","title":"Symbolic Regression of Nonlinear Time Continuous Systems","text":"And look at the result","category":"page"},{"location":"examples/8_symbolic_regression/","page":"Symbolic Regression of Nonlinear Time Continuous Systems","title":"Symbolic Regression of Nonlinear Time Continuous Systems","text":"plot(sol, color = :black)\nplot!(estimate, color = :red, linestyle = :dash)","category":"page"},{"location":"examples/8_symbolic_regression/#symbolic_regression_simple_copy_paste","page":"Symbolic Regression of Nonlinear Time Continuous Systems","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"examples/8_symbolic_regression/","page":"Symbolic Regression of Nonlinear Time Continuous Systems","title":"Symbolic Regression of Nonlinear Time Continuous Systems","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing SymbolicRegression\n\nA = [-0.9 0.2; 0.0 -0.5]\nB = [0.0; 1.0]\nu0 = [10.0; -10.0]\ntspan = (0.0, 20.0)\n\nf(u,p,t) = A*u .+ B .* sin(0.5*t)\n\nsys = ODEProblem(f, u0, tspan)\nsol = solve(sys, Tsit5(), saveat = 0.01);\n\nX = Array(sol)\nt = sol.t\nU = permutedims(sin.(0.5*t))\nprob = ContinuousDataDrivenProblem(X, t, U = U)\n\nalg = EQSearch([-, *], loss = L1DistLoss(), verbosity = 0, maxsize = 9, batching = true, batchSize = 50, parsimony = 0.01f0)\n\nres = solve(prob, alg, max_iter = 300, numprocs = 0, multithreading = false)\n\nsystem = result(res)\nprintln(system)\n\nu = controls(system)\nt = get_iv(system)\n\nsubs_control = (u[1] => sin(0.5*t))\n\neqs = map(equations(system)) do eq\n    eq.lhs ~ substitute(eq.rhs, subs_control)\nend\n\n@named sys = ODESystem(\n    eqs,\n    get_iv(system),\n    states(system),\n    []\n    );\n\nx = states(system)\nx0 = [x[1] => u0[1], x[2] => u0[2]]\n\node_prob = ODEProblem(sys, x0, tspan)\nestimate = solve(ode_prob, Tsit5(), saveat = prob.t);\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/8_symbolic_regression/","page":"Symbolic Regression of Nonlinear Time Continuous Systems","title":"Symbolic Regression of Nonlinear Time Continuous Systems","text":"","category":"page"},{"location":"examples/8_symbolic_regression/","page":"Symbolic Regression of Nonlinear Time Continuous Systems","title":"Symbolic Regression of Nonlinear Time Continuous Systems","text":"This page was generated using Literate.jl.","category":"page"},{"location":"basis/#Basis","page":"Basis","title":"Basis","text":"","category":"section"},{"location":"basis/","page":"Basis","title":"Basis","text":"Basis","category":"page"},{"location":"basis/#DataDrivenDiffEq.Basis","page":"Basis","title":"DataDrivenDiffEq.Basis","text":"mutable struct Basis <: DataDrivenDiffEq.AbstractBasis\n\nA basis over the states with parameters, independent variable, and possible exogenous controls. It extends an AbstractSystem as defined in ModelingToolkit.jl. f can either be a Julia function which is able to use ModelingToolkit variables or a vector of eqs. It can be called with the typical SciML signature, meaning out of place with f(u,p,t) or in place with f(du, u, p, t). If control inputs are present, it is assumed that no control corresponds to zero for all inputs. The corresponding function calls are f(u,p,t,inputs) and f(du,u,p,t,inputs) and need to be specified fully. \n\nThe optional implicits declare implicit variables in the Basis, meaning variables representing the (measured) target of the system. Right now only supported with the use of ImplicitOptimizers.\n\nIf linear_independent is set to true, a linear independent basis is created from all atom functions in f.\n\nIf simplify_eqs is set to true, simplify is called on f.\n\nAdditional keyworded arguments include name, which can be used to name the basis, and observed for defining observables.\n\nFields\n\neqs\nThe equations of the basis\nstates\nDependent (state) variables\nctrls\nControl variables\nps\nParameters\nobserved\nObserved\niv\nIndependent variable\nimplicit\nImplicit variables of the basis\nf\nInternal function representation of the basis\nname\nName of the basis\nsystems\nInternal systems\n\nExample\n\nusing ModelingToolkit\nusing DataDrivenDiffEq\n\n@parameters w[1:2] t\n@variables u[1:2](t)\n\nΨ = Basis([u; sin.(w.*u)], u, parameters = p, iv = t)\n\nNote\n\nThe keyword argument eval_expression controls the function creation behavior. eval_expression=true means that eval is used, so normal world-age behavior applies (i.e. the functions cannot be called from the function that generates them). If eval_expression=false, then construction via GeneralizedGenerated.jl is utilized to allow for same world-age evaluation. However, this can cause Julia to segfault on sufficiently large basis functions. By default eval_expression=false.\n\n\n\n\n\n","category":"type"},{"location":"basis/#Generators","page":"Basis","title":"Generators","text":"","category":"section"},{"location":"basis/","page":"Basis","title":"Basis","text":"monomial_basis\npolynomial_basis\nsin_basis\ncos_basis\nfourier_basis\nchebyshev_basis","category":"page"},{"location":"basis/#DataDrivenDiffEq.monomial_basis","page":"Basis","title":"DataDrivenDiffEq.monomial_basis","text":"monomial_basis(x)\nmonomial_basis(x, degree)\n\n\nConstructs an array containing monomial basis in the variables x up to degree c of the form [x₁, x₁^2, ... , x₁^c, x₂, x₂^2, ...].\n\n\n\n\n\n","category":"function"},{"location":"basis/#DataDrivenDiffEq.polynomial_basis","page":"Basis","title":"DataDrivenDiffEq.polynomial_basis","text":"polynomial_basis(x)\npolynomial_basis(x, degree)\n\n\nConstructs an array containing a polynomial basis in the variables x up to degree c of the form [x₁, x₂, x₃, ..., x₁^1 * x₂^(c-1)]. Mixed terms are included.\n\n\n\n\n\n","category":"function"},{"location":"basis/#DataDrivenDiffEq.sin_basis","page":"Basis","title":"DataDrivenDiffEq.sin_basis","text":"sin_basis(x, coefficients)\n\n\nConstructs an array containing a Sine basis in the variables x with coefficients c. If c is an Int returns all coefficients from 1 to c.\n\n\n\n\n\n","category":"function"},{"location":"basis/#DataDrivenDiffEq.cos_basis","page":"Basis","title":"DataDrivenDiffEq.cos_basis","text":"cos_basis(x, coefficients)\n\n\nConstructs an array containing a Cosine basis in the variables x with coefficients c. If c is an Int returns all coefficients from 1 to c.\n\n\n\n\n\n","category":"function"},{"location":"basis/#DataDrivenDiffEq.fourier_basis","page":"Basis","title":"DataDrivenDiffEq.fourier_basis","text":"fourier_basis(x, coefficients)\n\n\nConstructs an array containing a Fourier basis in the variables x with (integer) coefficients c. If c is an Int returns all coefficients from 1 to c.\n\n\n\n\n\n","category":"function"},{"location":"basis/#DataDrivenDiffEq.chebyshev_basis","page":"Basis","title":"DataDrivenDiffEq.chebyshev_basis","text":"chebyshev_basis(x, coefficients)\n\n\nConstructs an array containing a Chebyshev basis in the variables x with coefficients c. If c is an Int returns all coefficients from 1 to c.\n\n\n\n\n\n","category":"function"},{"location":"basis/#koopman","page":"Basis","title":"Koopman","text":"","category":"section"},{"location":"basis/","page":"Basis","title":"Basis","text":"Since the results provided by DMD-like have special information, they have a separate subtype.","category":"page"},{"location":"basis/","page":"Basis","title":"Basis","text":"Koopman","category":"page"},{"location":"basis/#DataDrivenDiffEq.Koopman","page":"Basis","title":"DataDrivenDiffEq.Koopman","text":"mutable struct Koopman{O, M, G, T} <: DataDrivenDiffEq.AbstractKoopman\n\nA special basis over the states with parameters , independent variable  and possible exogenous controls. It extends an AbstractBasis, which also stores information about the lifted dynamics, specified by a sufficient matrix factorization, an output mapping and internal variables to update the equations. It can be called with the typical SciML signature, meaning out of place with f(u,p,t) or in place with f(du, u, p, t). If control inputs are present, it is assumed that no control corresponds to zero for all inputs. The corresponding function calls are f(u,p,t,inputs) and f(du,u,p,t,inputs) and need to be specified fully.\n\nIf linear_independent is set to true, a linear independent basis is created from all atom functions in f.\n\nIf simplify_eqs is set to true, simplify is called on f.\n\nAdditional keyworded arguments include name, which can be used to name the basis, and observed for defining observeables.\n\nFields\n\neqs\nThe equations of the basis\nstates\nDependent (state) variables\nctrls\nControl variables\nps\nParameters\nobserved\nObserved\niv\nIndependent variable\nf\nInternal function representation of the basis\nlift\nAssociated lifting of the operator\nname\nName of the basis\nsystems\nInternal systems\nis_discrete\nDiscrete or time continuous\nK\nThe operator/generator of the dynamics\nC\nMapping back onto the observed states\nQ\nInternal matrix Q used for updating\nP\nInternal matrix P used for updating\n\nNote\n\nThe keyword argument eval_expression controls the function creation behavior. eval_expression=true means that eval is used, so normal world-age behavior applies (i.e. the functions cannot be called from the function that generates them). If eval_expression=false, then construction via GeneralizedGenerated.jl is utilized to allow for same world-age evaluation. However, this can cause Julia to segfault on sufficiently large basis functions. By default eval_expression=false.\n\n\n\n\n\n","category":"type"},{"location":"basis/#Functions","page":"Basis","title":"Functions","text":"","category":"section"},{"location":"basis/","page":"Basis","title":"Basis","text":"is_discrete\nis_continuous\nDataDrivenDiffEq.eigen\nDataDrivenDiffEq.eigvals\nDataDrivenDiffEq.eigvecs\nmodes\nfrequencies\noperator\ngenerator\nupdatable\nis_stable\nupdate!","category":"page"},{"location":"basis/#DataDrivenDiffEq.is_discrete","page":"Basis","title":"DataDrivenDiffEq.is_discrete","text":"is_discrete(k)\n\n\nReturns true if the AbstractKoopmanOperator k is discrete in time.\n\n\n\n\n\nis_discrete(_)\n\n\nCheck if the problem is time discrete.\n\n\n\n\n\n","category":"function"},{"location":"basis/#DataDrivenDiffEq.is_continuous","page":"Basis","title":"DataDrivenDiffEq.is_continuous","text":"is_continuous(k)\n\n\nReturns true if the AbstractKoopmanOperator k is continuous in time.\n\n\n\n\n\nCheck if the problem is time continuous.\n\n\n\n\n\n","category":"function"},{"location":"basis/#LinearAlgebra.eigen","page":"Basis","title":"LinearAlgebra.eigen","text":"eigen(k)\n\n\nReturn the eigendecomposition of the AbstractKoopmanOperator.\n\n\n\n\n\n","category":"function"},{"location":"basis/#LinearAlgebra.eigvals","page":"Basis","title":"LinearAlgebra.eigvals","text":"eigvals(k)\n\n\nReturn the eigenvalues of the AbstractKoopmanOperator.\n\n\n\n\n\n","category":"function"},{"location":"basis/#LinearAlgebra.eigvecs","page":"Basis","title":"LinearAlgebra.eigvecs","text":"eigvecs(k)\n\n\nReturn the eigenvectors of the AbstractKoopmanOperator.\n\n\n\n\n\n","category":"function"},{"location":"basis/#DataDrivenDiffEq.modes","page":"Basis","title":"DataDrivenDiffEq.modes","text":"modes(k)\n\n\nReturn the eigenvectors of a continuous AbstractKoopmanOperator.\n\n\n\n\n\n","category":"function"},{"location":"basis/#DataDrivenDiffEq.frequencies","page":"Basis","title":"DataDrivenDiffEq.frequencies","text":"frequencies(k)\n\n\nReturn the eigenvalues of a continuous AbstractKoopmanOperator.\n\n\n\n\n\n","category":"function"},{"location":"basis/#DataDrivenDiffEq.operator","page":"Basis","title":"DataDrivenDiffEq.operator","text":"operator(k)\n\n\nReturn the approximation of the discrete Koopman operator stored in k.\n\n\n\n\n\n","category":"function"},{"location":"basis/#DataDrivenDiffEq.generator","page":"Basis","title":"DataDrivenDiffEq.generator","text":"generator(k)\n\n\nReturn the approximation of the continuous Koopman generator stored in k.\n\n\n\n\n\n","category":"function"},{"location":"basis/#DataDrivenDiffEq.updatable","page":"Basis","title":"DataDrivenDiffEq.updatable","text":"updatable(k)\n\n\nReturns true if the AbstractKoopmanOperator is updatable.\n\n\n\n\n\n","category":"function"},{"location":"basis/#DataDrivenDiffEq.is_stable","page":"Basis","title":"DataDrivenDiffEq.is_stable","text":"is_stable(k)\n\n\nReturns true if either:\n\nthe Koopman operator has just eigenvalues with magnitude less than one or\nthe Koopman generator has just eigenvalues with a negative real part\n\n\n\n\n\n","category":"function"},{"location":"basis/#DataDrivenDiffEq.update!","page":"Basis","title":"DataDrivenDiffEq.update!","text":"update!(k, X, Y; p, t, U, threshold)\n\n\nUpdate the Koopman k given new data X and Y. The operator is updated in place if the L2 error of the prediction exceeds the threshold.\n\np and t are the parameters of the basis and the vector of timepoints, if necessary.\n\n\n\n\n\n","category":"function"},{"location":"examples/3_linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"EditURL = \"https://github.com/SciML/DataDrivenDiffEq.jl/blob/master/docs/examples/3_linear_continuous_system_controls.jl\"","category":"page"},{"location":"examples/3_linear_continuous_system_controls/#linear_continuous_controls","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"","category":"section"},{"location":"examples/3_linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"Now we will extend the previous example by adding some exegeneous control signals. As always, we will generate some data via OrdinaryDiffEq.jl","category":"page"},{"location":"examples/3_linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing Plots\n\nA = [-0.9 0.2; 0.0 -0.2]\nB = [0.0; 1.0]\nu0 = [10.0; -10.0]\ntspan = (0.0, 10.0)\n\nf(u,p,t) = A*u .+ B .* sin(0.5*t)\n\nsys = ODEProblem(f, u0, tspan)\nsol = solve(sys, Tsit5(), saveat = 0.05);\nnothing #hide","category":"page"},{"location":"examples/3_linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"We will use the data provided by our problem, but add the control signal U = sin(0.5*t) to it.","category":"page"},{"location":"examples/3_linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"X = Array(sol)\nt = sol.t\ncontrol(u,p,t) = [sin(0.5*t)]\nprob = ContinuousDataDrivenProblem(X, t, U = control)","category":"page"},{"location":"examples/3_linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"And plot the problems data.","category":"page"},{"location":"examples/3_linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"plot(prob)","category":"page"},{"location":"examples/3_linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"Again, we will use gDMD to estimate the systems dynamics. Since we have a control signal defined in the problem, the algorithm will detect it automatically and use gDMDc:","category":"page"},{"location":"examples/3_linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"res = solve(prob, DMDSVD(), digits = 1)\nprintln(res)","category":"page"},{"location":"examples/3_linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"We see that the system has been recovered correctly, indicated by the small error and high AIC score of the result. We can confirm this by looking at the resulting Basis","category":"page"},{"location":"examples/3_linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"system = result(res)\nprintln(system)","category":"page"},{"location":"examples/3_linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"And also plot the prediction of the recovered dynamics","category":"page"},{"location":"examples/3_linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"plot(res)","category":"page"},{"location":"examples/3_linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"Again, we can have a look at the generator of the system, which is independent from the inputs.","category":"page"},{"location":"examples/3_linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"generator(system)","category":"page"},{"location":"examples/3_linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"Sticking to the same procedure as earlier, we now use a linear sparse regression to solve the problem","category":"page"},{"location":"examples/3_linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"@parameters t\n@variables x[1:2](t) u[1:1](t)\n\nbasis = Basis([x; u], x, controls = u, independent_variable = t, name = :LinearBasis)\nprint(basis) #hide","category":"page"},{"location":"examples/3_linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"Note that we added a new variable u[1](t) as a control to both the equations and the basis constructor. Afterwards, we simply solve the already defined problem with our Basis and a SparseOptimizer","category":"page"},{"location":"examples/3_linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"sparse_res = solve(prob, basis, STLSQ(1e-1))\nprintln(sparse_res)","category":"page"},{"location":"examples/3_linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"Which holds the same equations","category":"page"},{"location":"examples/3_linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"sparse_system = result(sparse_res)\nprintln(sparse_system)","category":"page"},{"location":"examples/3_linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"Again, we can have a look at the result","category":"page"},{"location":"examples/3_linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"plot(\n    plot(prob), plot(sparse_res), layout = (1,2)\n)","category":"page"},{"location":"examples/3_linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"Both results can be converted into an ODESystem. To include the control signal, we simply substitute the control variables in the corresponding equations.","category":"page"},{"location":"examples/3_linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"subs_control = (u[1] => sin(0.5*t))\n\neqs = map(equations(sparse_system)) do eq\n    eq.lhs ~ substitute(eq.rhs, subs_control)\nend\n\n@named sys = ODESystem(\n    eqs,\n    get_iv(sparse_system),\n    states(sparse_system),\n    parameters(sparse_system)\n    );\nnothing #hide","category":"page"},{"location":"examples/3_linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"And simulated using OrdinaryDiffEq.jl using the (known) initial conditions and the parameter mapping of the estimation.","category":"page"},{"location":"examples/3_linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"x0 = [x[1] => u0[1], x[2] => u0[2]]\nps = parameter_map(sparse_res)\n\node_prob = ODEProblem(sys, x0, tspan, ps)\nestimate = solve(ode_prob, Tsit5(), saveat = prob.t);\nnothing #hide","category":"page"},{"location":"examples/3_linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"And look at the result","category":"page"},{"location":"examples/3_linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"plot(sol, color = :black)\nplot!(estimate, color = :red, linestyle = :dash)","category":"page"},{"location":"examples/3_linear_continuous_system_controls/#linear_continuous_copy_paste","page":"Linear Time Continuous System with Controls","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"examples/3_linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing LinearAlgebra\nusing OrdinaryDiffEq\n\nA = [-0.9 0.2; 0.0 -0.2]\nB = [0.0; 1.0]\nu0 = [10.0; -10.0]\ntspan = (0.0, 10.0)\n\nf(u,p,t) = A*u .+ B .* sin(0.5*t)\n\nsys = ODEProblem(f, u0, tspan)\nsol = solve(sys, Tsit5(), saveat = 0.05);\n\nX = Array(sol)\nt = sol.t\ncontrol(u,p,t) = [sin(0.5*t)]\nprob = ContinuousDataDrivenProblem(X, t, U = control)\n\nres = solve(prob, DMDSVD(), digits = 1)\n\nsystem = result(res)\n\ngenerator(system)\n\n@parameters t\n@variables x[1:2](t) u[1:1](t)\n\nbasis = Basis([x; u], x, controls = u, independent_variable = t, name = :LinearBasis)\n\nsparse_res = solve(prob, basis, STLSQ(1e-1))\n\nsparse_system = result(sparse_res)\n\nsubs_control = (u[1] => sin(0.5*t))\n\neqs = map(equations(sparse_system)) do eq\n    eq.lhs ~ substitute(eq.rhs, subs_control)\nend\n\n@named sys = ODESystem(\n    eqs,\n    get_iv(sparse_system),\n    states(sparse_system),\n    parameters(sparse_system)\n    );\n\nx0 = [x[1] => u0[1], x[2] => u0[2]]\nps = parameter_map(sparse_res)\n\node_prob = ODEProblem(sys, x0, tspan, ps)\nestimate = solve(ode_prob, Tsit5(), saveat = prob.t);\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/3_linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"","category":"page"},{"location":"examples/3_linear_continuous_system_controls/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/7_cartpole/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"EditURL = \"https://github.com/SciML/DataDrivenDiffEq.jl/blob/master/docs/examples/7_cartpole.jl\"","category":"page"},{"location":"examples/7_cartpole/#cartpole","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"","category":"section"},{"location":"examples/7_cartpole/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"The following is another example on how to use the ImplicitOptimizer that is taken from the original paper. As always, we start by creating a corresponding dataset:","category":"page"},{"location":"examples/7_cartpole/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing OrdinaryDiffEq\nusing LinearAlgebra\nusing Plots\ngr()\n\n\nfunction cart_pole(u, p, t)\n    du = similar(u)\n    F = -0.2 + 0.5*sin(6*t) # the input\n    du[1] = u[3]\n    du[2] = u[4]\n    du[3] = -(19.62*sin(u[1])+sin(u[1])*cos(u[1])*u[3]^2+F*cos(u[1]))/(2-cos(u[1])^2)\n    du[4] = -(sin(u[1])*u[3]^2 + 9.81*sin(u[1])*cos(u[1])+F)/(2-cos(u[1])^2)\n    return du\nend\n\nu0 = [0.3; 0; 1.0; 0]\ntspan = (0.0, 5.0)\ndt = 0.05\ncart_pole_prob = ODEProblem(cart_pole, u0, tspan)\nsolution = solve(cart_pole_prob, Tsit5(), saveat = dt)\n\nX = solution[:,:]\nDX = similar(X)\nfor (i, xi) in enumerate(eachcol(X))\n    DX[:, i] = cart_pole(xi, [], solution.t[i])\nend\nt = solution.t\n\nddprob = ContinuousDataDrivenProblem(\n    X , t, DX = DX[3:4, :], U = (u,p,t) -> [-0.2 + 0.5*sin(6*t)]\n)\n\nplot(ddprob)","category":"page"},{"location":"examples/7_cartpole/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"Note that we just included the third and forth time derivative, assuming that we already know that the velocity x[3:4] is equal to the time derivative of the position x[1:2]. Next, we define a sufficient Basis. Again, we need to include implicits in the definition of our candidate functions and inform the Basis of it.","category":"page"},{"location":"examples/7_cartpole/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"@parameters t\n@variables u[1:4] du[1:2] x[1:1]\nu, du, x = map(collect, [u, du, x])\n\npolys = polynomial_basis(u, 2)\npush!(polys, sin.(u[1]))\npush!(polys, cos.(u[1]))\npush!(polys, sin.(u[1])^2)\npush!(polys, cos.(u[1])^2)\npush!(polys, sin.(u[1]).*u[3:4]...)\npush!(polys, sin.(u[1]).*u[3:4].^2...)\npush!(polys, sin.(u[1]).*cos.(u[1])...)\npush!(polys, sin.(u[1]).*cos.(u[1]).*u[3:4]...)\npush!(polys, sin.(u[1]).*cos.(u[1]).*u[3:4].^2...)\n\nimplicits = [du;  du[1] .* u; du[2] .* u; du .* cos(u[1]);   du .* cos(u[1])^2; polys]\npush!(implicits, x...)\npush!(implicits, x[1]*cos(u[1]))\npush!(implicits, x[1]*sin(u[1]))\n\nbasis= Basis(implicits, u, implicits = du, controls = x,  iv = t);\nprintln(basis) # hide","category":"page"},{"location":"examples/7_cartpole/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"We solve the problem by varying over a sufficient set of thresholds for the associated optimizer. Additionally we activate the scale_coefficients option for the ImplicitOptimizer, which helps to find sparse equations by normalizing the resulting coefficient matrix after each suboptimization. To evaluate the pareto optimal solution, we use the functions f and g which can be passed as keyword arguments into the solve function. f is a function with different signatures for different optimizers, but returns the L_0 norm of the coefficients and the L_2 error of the current model. g takes this vector and projects it down onto a scalar, using the L_2 norm per default. However, here we want to use the AIC  of the output of f. A noteworthy exception is of course, that we want only results with two or more active coefficents. Hence, we modify g accordingly.","category":"page"},{"location":"examples/7_cartpole/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"λ = [1e-4;5e-4;1e-3;2e-3;3e-3;4e-3;5e-3;6e-3;7e-3;8e-3;9e-3;1e-2;2e-2;3e-2;4e-2;5e-2]\n\nopt = ImplicitOptimizer(λ)\n\ng(x) = x[1] <= 1 ? Inf : 2*x[1]-2*log(x[2])\n\nres = solve(ddprob, basis, opt, du, maxiter = 1000, g = g, show_progress = true)\nsystem = result(res)\nprintln(system) #hide","category":"page"},{"location":"examples/7_cartpole/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"We have recovered the correct equations of motion! Another visual check using the problem and the result yields","category":"page"},{"location":"examples/7_cartpole/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"plot(\n    plot(ddprob), plot(res), layout = (1,2)\n)","category":"page"},{"location":"examples/7_cartpole/#cartpole_copy_paste","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"examples/7_cartpole/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing OrdinaryDiffEq\nusing LinearAlgebra\n\n\nfunction cart_pole(u, p, t)\n    du = similar(u)\n    F = -0.2 + 0.5*sin(6*t) # the input\n    du[1] = u[3]\n    du[2] = u[4]\n    du[3] = -(19.62*sin(u[1])+sin(u[1])*cos(u[1])*u[3]^2+F*cos(u[1]))/(2-cos(u[1])^2)\n    du[4] = -(sin(u[1])*u[3]^2 + 9.81*sin(u[1])*cos(u[1])+F)/(2-cos(u[1])^2)\n    return du\nend\n\nu0 = [0.3; 0; 1.0; 0]\ntspan = (0.0, 5.0)\ndt = 0.05\ncart_pole_prob = ODEProblem(cart_pole, u0, tspan)\nsolution = solve(cart_pole_prob, Tsit5(), saveat = dt)\n\nX = solution[:,:]\nDX = similar(X)\nfor (i, xi) in enumerate(eachcol(X))\n    DX[:, i] = cart_pole(xi, [], solution.t[i])\nend\nt = solution.t\n\nddprob = ContinuousDataDrivenProblem(\n    X , t, DX = DX[3:4, :], U = (u,p,t) -> [-0.2 + 0.5*sin(6*t)]\n)\n\n@parameters t\n@variables u[1:4] du[1:2] x[1:1]\nu, du, x = map(collect, [u, du, x])\n\npolys = polynomial_basis(u, 2)\npush!(polys, sin.(u[1]))\npush!(polys, cos.(u[1]))\npush!(polys, sin.(u[1])^2)\npush!(polys, cos.(u[1])^2)\npush!(polys, sin.(u[1]).*u[3:4]...)\npush!(polys, sin.(u[1]).*u[3:4].^2...)\npush!(polys, sin.(u[1]).*cos.(u[1])...)\npush!(polys, sin.(u[1]).*cos.(u[1]).*u[3:4]...)\npush!(polys, sin.(u[1]).*cos.(u[1]).*u[3:4].^2...)\n\nimplicits = [du;  du[1] .* u; du[2] .* u; du .* cos(u[1]);   du .* cos(u[1])^2; polys]\npush!(implicits, x...)\npush!(implicits, x[1]*cos(u[1]))\npush!(implicits, x[1]*sin(u[1]))\n\nbasis= Basis(implicits, u, implicits = du, controls = x,  iv = t);\nprintln(basis) # hide\n\nλ = [1e-4;5e-4;1e-3;2e-3;3e-3;4e-3;5e-3;6e-3;7e-3;8e-3;9e-3;1e-2;2e-2;3e-2;4e-2;5e-2]\n\nopt = ImplicitOptimizer(λ)\n\ng(x) = x[1] <= 1 ? Inf : 2*x[1]-2*log(x[2])\n\nres = solve(ddprob, basis, opt, du, maxiter = 1000, g = g, show_progress = true)\nsystem = result(res)\nprintln(system) #hide\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/7_cartpole/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"","category":"page"},{"location":"examples/7_cartpole/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"This page was generated using Literate.jl.","category":"page"},{"location":"utils/#collocation","page":"Utilities","title":"Collocation","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"InterpolationMethod\ncollocate_data","category":"page"},{"location":"utils/#DataDrivenDiffEq.InterpolationMethod","page":"Utilities","title":"DataDrivenDiffEq.InterpolationMethod","text":"A wrapper for the interpolation methods of DataInterpolations.jl.\n\nWraps the methods in such a way that they are callable as f(u,t) to create and return an interpolation of u over t. The first argument of the constructor always defines the interpolation method, all following arguments will be used in the interpolation.\n\nThe additional keyword crop = false indicates to discard the first and last element of the time series. \n\nExample\n\n# Create the wrapper struct\nitp_method = InterpolationMethod(QuadraticSpline)\n# Create a callable interpolation\nitp = itp_method(u,t)\n# Return u[2]\nitp(t[2])\n\n\n\n\n\n","category":"type"},{"location":"utils/#DataDrivenDiffEq.collocate_data","page":"Utilities","title":"DataDrivenDiffEq.collocate_data","text":"collocate_data(data, tpoints)\ncollocate_data(data, tpoints, kernel; crop, kwargs...)\n\n\nUnified interface for collocation techniques. The input can either be a CollocationKernel (see list below) or a wrapped InterpolationMethod from DataInterpolations.jl.\n\nComputes a non-parametrically smoothed estimate of u' and u given the data, where each column is a snapshot of the timeseries at tpoints[i].\n\nExamples\n\nu′,u,t = collocate_data(data,tpoints,kernel=SigmoidKernel())\nu′,u,t = collocate_data(data,tpoints,tpoints_sample,interp,args...)\nu′,u,t = collocate_data(data,tpoints,interp)\n\nCollocation Kernels\n\nSee this paper for more information.\n\nEpanechnikovKernel\nUniformKernel\nTriangularKernel\nQuarticKernel\nTriweightKernel\nTricubeKernel\nGaussianKernel\nCosineKernel\nLogisticKernel\nSigmoidKernel\nSilvermanKernel\n\nInterpolation Methods\n\nSee DataInterpolations.jl for more information.\n\nConstantInterpolation\nLinearInterpolation\nQuadraticInterpolation\nLagrangeInterpolation\nQuadraticSpline\nCubicSpline\nBSplineInterpolation\nBSplineApprox\nCurvefit\n\n\n\n\n\n","category":"function"},{"location":"solvers/optimization/#sparse_optimization","page":"Sparse Optimizers","title":"Sparse Optimizers","text":"","category":"section"},{"location":"solvers/optimization/","page":"Sparse Optimizers","title":"Sparse Optimizers","text":"STLSQ\nADMM\nSR3\nImplicitOptimizer","category":"page"},{"location":"solvers/optimization/#DataDrivenDiffEq.STLSQ","page":"Sparse Optimizers","title":"DataDrivenDiffEq.STLSQ","text":"mutable struct STLSQ{T} <: DataDrivenDiffEq.AbstractOptimizer{T}\n\nSTLQS is taken from the original paper on SINDY and implements a sequentially thresholded least squares iteration. λ is the threshold of the iteration. It is based upon this matlab implementation. It solves the following problem\n\nargmin_x frac12  Ax-b_2 + lambda x_2\n\nFields\n\nλ\nSparsity threshold\n\nExample\n\nopt = STLQS()\nopt = STLQS(1e-1)\nopt = STLQS(Float32[1e-2; 1e-1])\n\nNote\n\nThis was formally STRRidge and has been renamed.\n\n\n\n\n\n","category":"type"},{"location":"solvers/optimization/#DataDrivenDiffEq.ADMM","page":"Sparse Optimizers","title":"DataDrivenDiffEq.ADMM","text":"mutable struct ADMM{T, R} <: DataDrivenDiffEq.AbstractOptimizer{T}\n\nADMM is an implementation of Lasso using the alternating direction methods of multipliers and loosely based on this implementation. It solves the following problem\n\nargmin_x frac12  Ax-b_2 + lambda x_1\n\nFields\n\nλ\nSparsity threshold\nρ\nAugmented Lagrangian parameter\n\nExample\n\nopt = ADMM()\nopt = ADMM(1e-1, 2.0)\n\n\n\n\n\n","category":"type"},{"location":"solvers/optimization/#DataDrivenDiffEq.SR3","page":"Sparse Optimizers","title":"DataDrivenDiffEq.SR3","text":"mutable struct SR3{T, V, P<:DataDrivenDiffEq.AbstractProximalOperator} <: DataDrivenDiffEq.AbstractOptimizer{T}\n\nSR3 is an optimizer framework introduced by Zheng et. al., 2018 and used within Champion et. al., 2019. SR3 contains a sparsification parameter λ, a relaxation ν. It solves the following problem\n\nargmin_x w frac12  Ax-b_2 + lambda R(w) + fracnu2x-w_2\n\nWhere R is a proximal operator and the result is given by w.\n\nFields\n\nλ\nSparsity threshold\nν\nRelaxation parameter\nR\nProximal operator\n\nExample\n\nopt = SR3()\nopt = SR3(1e-2)\nopt = SR3(1e-3, 1.0)\nopt = SR3(1e-3, 1.0, SoftThreshold())\n\nNote\n\nOpposed to the original formulation, we use ν as a relaxation parameter, as given in Champion et. al., 2019. In the standard case of hard thresholding the sparsity is interpreted as λ = threshold^2 / 2, otherwise λ = threshold.\n\n\n\n\n\n","category":"type"},{"location":"solvers/optimization/#DataDrivenDiffEq.ImplicitOptimizer","page":"Sparse Optimizers","title":"DataDrivenDiffEq.ImplicitOptimizer","text":"mutable struct ImplicitOptimizer{T} <: DataDrivenDiffEq.AbstractSubspaceOptimizer{T}\n\nOptimizer for finding a sparse implicit relationship via alternating the left hand side of the problem and solving the explicit problem, as introduced here.\n\nargmin_x x_0 stAx= 0\n\nFields\n\no\nExplicit Optimizer\n\nExample\n\nImplicitOptimizer(STLSQ())\nImplicitOptimizer(0.1f0, ADMM)\n\n\n\n\n\n","category":"type"},{"location":"solvers/optimization/#Related-Functions","page":"Sparse Optimizers","title":"Related Functions","text":"","category":"section"},{"location":"solvers/optimization/","page":"Sparse Optimizers","title":"Sparse Optimizers","text":"sparse_regression!\nset_threshold!\nget_threshold","category":"page"},{"location":"solvers/optimization/#DataDrivenDiffEq.sparse_regression!","page":"Sparse Optimizers","title":"DataDrivenDiffEq.sparse_regression!","text":"sparse_regression!(X, A, Y, opt; maxiter, abstol, progress, f, g, progress_outer, progress_offset, kwargs...)\n\n\nImplements a sparse regression, given an AbstractOptimizer or AbstractSubspaceOptimizer. X denotes the coefficient matrix, A the design matrix and Y the matrix of observed or target values. X can be derived via init(opt, A, Y). maxiter indicates the maximum iterations for each call of the optimizer, abstol the absolute tolerance of the difference between iterations in the 2 norm. If the optimizer is called with a Vector of thresholds, each maxiter indicates the maximum iterations for each threshold.\n\nIf progress is set to true, a progressbar will be available. progress_outer and progress_offset are used to compute the initial offset of the progressbar.\n\nIf used with a Vector of thresholds, the functions f with signature f(X, A, Y) and g with signature g(x, threshold) = G(f(X, A, Y)) with the arguments given as stated above can be passed in. These are used for finding the pareto-optimal solution to the sparse regression. \n\n\n\n\n\n","category":"function"},{"location":"solvers/optimization/#DataDrivenDiffEq.set_threshold!","page":"Sparse Optimizers","title":"DataDrivenDiffEq.set_threshold!","text":"set_threshold!(opt, threshold)\n\n\nSet the threshold(s) of an optimizer to (a) specific value(s).\n\n\n\n\n\n","category":"function"},{"location":"solvers/optimization/#DataDrivenDiffEq.get_threshold","page":"Sparse Optimizers","title":"DataDrivenDiffEq.get_threshold","text":"get_threshold(opt)\n\n\nGet the threshold(s) of an optimizer.\n\n\n\n\n\n","category":"function"},{"location":"solvers/optimization/#Proximal-Operators","page":"Sparse Optimizers","title":"Proximal Operators","text":"","category":"section"},{"location":"solvers/optimization/","page":"Sparse Optimizers","title":"Sparse Optimizers","text":"SoftThreshold\nHardThreshold\nClippedAbsoluteDeviation","category":"page"},{"location":"solvers/optimization/#DataDrivenDiffEq.SoftThreshold","page":"Sparse Optimizers","title":"DataDrivenDiffEq.SoftThreshold","text":"struct SoftThreshold <: DataDrivenDiffEq.AbstractProximalOperator\n\nProximal operator which implements the soft thresholding operator.\n\nsign(x) * max(abs(x) - λ, 0)\n\nSee by Zheng et. al., 2018.\n\n\n\n\n\n","category":"type"},{"location":"solvers/optimization/#DataDrivenDiffEq.HardThreshold","page":"Sparse Optimizers","title":"DataDrivenDiffEq.HardThreshold","text":"struct HardThreshold <: DataDrivenDiffEq.AbstractProximalOperator\n\nProximal operator which implements the hard thresholding operator.\n\nabs(x) > sqrt(2*λ) ? x : 0\n\nSee by Zheng et. al., 2018.\n\n\n\n\n\n","category":"type"},{"location":"solvers/optimization/#DataDrivenDiffEq.ClippedAbsoluteDeviation","page":"Sparse Optimizers","title":"DataDrivenDiffEq.ClippedAbsoluteDeviation","text":"struct ClippedAbsoluteDeviation{T} <: DataDrivenDiffEq.AbstractProximalOperator\n\nProximal operator which implements the (smoothly) clipped absolute deviation operator.\n\nabs(x) > ρ ? x : sign(x) * max(abs(x) - λ, 0)\n\nWhere ρ = 5λ per default.\n\n#Fields\n\nρ\nUpper threshold\n\nExample\n\nopt = ClippedAbsoluteDeviation()\nopt = ClippedAbsoluteDeviation(1e-1)\n\nSee by Zheng et. al., 2018.\n\n\n\n\n\n","category":"type"},{"location":"examples/6_autoregulation/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"EditURL = \"https://github.com/SciML/DataDrivenDiffEq.jl/blob/master/docs/examples/6_autoregulation.jl\"","category":"page"},{"location":"examples/6_autoregulation/#autoregulation","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"","category":"section"},{"location":"examples/6_autoregulation/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"The following is another example on how to use the ImplicitOptimizer describing a biological autoregulation process using two coupled implicit equations.","category":"page"},{"location":"examples/6_autoregulation/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing OrdinaryDiffEq\nusing LinearAlgebra\nusing Plots\ngr()\n\n@parameters begin\n    t\n    α = 1.0\n    β = 1.3\n    γ = 2.0\n    δ = 0.5\nend\n\n@variables begin\n    x[1:2](t) = [20.0; 12.0]\nend\n\nx = collect(x)\nD = Differential(t)\n\neqs = [\n    D(x[1]) ~ α/(1+x[2])-β*x[1];\n    D(x[2]) ~ γ/(1+x[1])-δ*x[2];\n]\n\nsys = ODESystem(eqs, t, x, [α, β, γ, δ], name = :Autoregulation)\n\nx0 = [x[1] => 20.0; x[2] => 12.0]\n\ntspan = (0.0, 5.0)\n\nde_problem = ODEProblem(sys, x0, tspan)\nde_solution = solve(de_problem, Tsit5(), saveat = 0.005)\nplot(de_solution)","category":"page"},{"location":"examples/6_autoregulation/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"As always, we start by defining a DataDrivenProblem and a sufficient basis for sparse regression.","category":"page"},{"location":"examples/6_autoregulation/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"dd_prob = ContinuousDataDrivenProblem(de_solution)\n\neqs = [\n    polynomial_basis(x, 4); D.(x); x .* D(x[1]); x .* D(x[2])\n    ]\n\nbasis = Basis(eqs, x, independent_variable = t, implicits = D.(x))\n\nplot(dd_prob)","category":"page"},{"location":"examples/6_autoregulation/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"Next to varying over different sparsity penalties, we want also to batch our data using the DataSampler. We define a train-test split of 80-20 for our data and batch the resulting training data into 10 minibatches, allowing shuffled and repeated values. Our goal is to find the model with the minimal error.","category":"page"},{"location":"examples/6_autoregulation/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"sampler = DataSampler(\n    Split(ratio = 0.8), Batcher(n = 10, shuffle = true, repeated = true, batchsize_min = 30)\n)\n\nres = solve(dd_prob, basis, ImplicitOptimizer(STLSQ(1e-1:1e-1:9e-1)), by = :min, sampler = sampler, digits = 1)\nprint(res) #hide\nprint(result(res)) #hide","category":"page"},{"location":"examples/6_autoregulation/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"We have recovered the correct equations of motion! Another visual check using the problem and the result yields","category":"page"},{"location":"examples/6_autoregulation/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"system = result(res)\n@named ode = ODESystem(equations(system), t, x, parameters(system));\node_prob = ODEProblem(ode, x0, tspan, parameter_map(res));\n\nprediction = solve(ode_prob, Tsit5(), saveat = 0.2);\nplot(de_solution, label = [\"Groundtruth\" nothing])\nscatter!(prediction, label = [\"Prediction\" nothing])","category":"page"},{"location":"examples/6_autoregulation/#autoregulation_copy_paste","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"examples/6_autoregulation/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing OrdinaryDiffEq\nusing LinearAlgebra\n\n@parameters begin\n    t\n    α = 1.0\n    β = 1.3\n    γ = 2.0\n    δ = 0.5\nend\n\n@variables begin\n    x[1:2](t) = [20.0; 12.0]\nend\n\nx = collect(x)\nD = Differential(t)\n\neqs = [\n    D(x[1]) ~ α/(1+x[2])-β*x[1];\n    D(x[2]) ~ γ/(1+x[1])-δ*x[2];\n]\n\nsys = ODESystem(eqs, t, x, [α, β, γ, δ], name = :Autoregulation)\n\nx0 = [x[1] => 20.0; x[2] => 12.0]\n\ntspan = (0.0, 5.0)\n\nde_problem = ODEProblem(sys, x0, tspan)\nde_solution = solve(de_problem, Tsit5(), saveat = 0.005)\n\ndd_prob = ContinuousDataDrivenProblem(de_solution)\n\neqs = [\n    polynomial_basis(x, 4); D.(x); x .* D(x[1]); x .* D(x[2])\n    ]\n\nbasis = Basis(eqs, x, independent_variable = t, implicits = D.(x))\n\nsampler = DataSampler(\n    Split(ratio = 0.8), Batcher(n = 10, shuffle = true, repeated = true, batchsize_min = 30)\n)\n\nres = solve(dd_prob, basis, ImplicitOptimizer(STLSQ(1e-1:1e-1:9e-1)), by = :min, sampler = sampler, digits = 1)\nprint(res) #hide\nprint(result(res)) #hide\n\nsystem = result(res)\n@named ode = ODESystem(equations(system), t, x, parameters(system));\node_prob = ODEProblem(ode, x0, tspan, parameter_map(res));\n\nprediction = solve(ode_prob, Tsit5(), saveat = 0.2);\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/6_autoregulation/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"","category":"page"},{"location":"examples/6_autoregulation/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/1_linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"EditURL = \"https://github.com/SciML/DataDrivenDiffEq.jl/blob/master/docs/examples/1_linear_discrete_system.jl\"","category":"page"},{"location":"examples/1_linear_discrete_system/#linear_discrete","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"","category":"section"},{"location":"examples/1_linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"We will start by estimating the underlying dynamical system of a time discrete process based on some measurements via Dynamic Mode Decomposition on a simple linear system of the form u(k+1) = A u(k).","category":"page"},{"location":"examples/1_linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"At first, we simulate the correspoding system using OrdinaryDiffEq.jl and generate a DiscreteDataDrivenProblem from the simulated data.","category":"page"},{"location":"examples/1_linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing Plots\n\nA = [0.9 -0.2; 0.0 0.2]\nu0 = [10.0; -10.0]\ntspan = (0.0, 11.0)\n\nf(u,p,t) = A*u\n\nsys = DiscreteProblem(f, u0, tspan)\nsol = solve(sys, FunctionMap());\nnothing #hide","category":"page"},{"location":"examples/1_linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"Next we transform our simulated solution into a DataDrivenProblem. Given that the solution knows its a discrete solution, we can simply write","category":"page"},{"location":"examples/1_linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"prob = DataDrivenProblem(sol)","category":"page"},{"location":"examples/1_linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"And plot the solution and the problem","category":"page"},{"location":"examples/1_linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"plot(sol, label = string.([:x₁ :x₂]))\nscatter!(prob)","category":"page"},{"location":"examples/1_linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"To estimate the underlying operator in the states x_1 x_2, we solve the estimation problem using the DMDSVD algorithm for approximating the operator. First, we will have a look at the DataDrivenSolution","category":"page"},{"location":"examples/1_linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"res = solve(prob, DMDSVD(), digits = 1)\nprintln(res) # hide","category":"page"},{"location":"examples/1_linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"We see that the system has been recovered correctly, indicated by the small error and high AIC score of the result. We can confirm this by looking at the resulting Basis","category":"page"},{"location":"examples/1_linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"system = result(res)\nusing Symbolics\n\nprintln(system) # hide","category":"page"},{"location":"examples/1_linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"And also plot the prediction of the recovered dynamics","category":"page"},{"location":"examples/1_linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"plot(res)","category":"page"},{"location":"examples/1_linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"Or a have a look at the metrics of the result","category":"page"},{"location":"examples/1_linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"metrics(res)","category":"page"},{"location":"examples/1_linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"To have a look at the representation of the operator as a Matrix, we can simply call","category":"page"},{"location":"examples/1_linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"Matrix(system)","category":"page"},{"location":"examples/1_linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"to see that the operator is indeed our initial A. Since we have a linear representation, we can gain further insights into the stability of the dynamics via its eigenvalues","category":"page"},{"location":"examples/1_linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"eigvals(system)","category":"page"},{"location":"examples/1_linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"And plot the stability margin of the discrete System","category":"page"},{"location":"examples/1_linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"φ = 0:0.01π:2π\nplot(sin.(φ), cos.(φ), xlabel = \"Real\", ylabel = \"Im\", label = \"Stability margin\", color = :red, linestyle = :dash)\nscatter!(real(eigvals(system)), imag(eigvals(system)), label = \"Eigenvalues\", color = :black, marker = :cross)","category":"page"},{"location":"examples/1_linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"Similarly, we could use a sparse regression to derive our system from our data. We start by defining a Basis","category":"page"},{"location":"examples/1_linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"using ModelingToolkit\n\n@parameters t\n@variables x[1:2](t)\n\nbasis = Basis(x, x, independent_variable = t, name = :LinearBasis)\nprint(basis) #hide","category":"page"},{"location":"examples/1_linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"Afterwards, we simply solve the already defined problem with our Basis and a SparseOptimizer","category":"page"},{"location":"examples/1_linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"sparse_res = solve(prob, basis, STLSQ())\nprintln(sparse_res) #hide","category":"page"},{"location":"examples/1_linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"Which holds the same equations","category":"page"},{"location":"examples/1_linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"sparse_system = result(sparse_res)\nprintln(sparse_system) #hide","category":"page"},{"location":"examples/1_linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"Again, we can have a look at the result","category":"page"},{"location":"examples/1_linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"plot(\n    plot(prob), plot(sparse_res), layout = (1,2)\n)","category":"page"},{"location":"examples/1_linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"Both results can be converted into a DiscreteProblem","category":"page"},{"location":"examples/1_linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"@named sys = DiscreteSystem(equations(sparse_system), get_iv(sparse_system),states(sparse_system), parameters(sparse_system))\nprintln(sys) #hide","category":"page"},{"location":"examples/1_linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"And simulated using OrdinaryDiffEq.jl using the (known) initial conditions and the parameter mapping of the estimation.","category":"page"},{"location":"examples/1_linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"x0 = [x[1] => u0[1], x[2] => u0[2]]\nps = parameter_map(sparse_res)\n\ndiscrete_prob = DiscreteProblem(sys, x0, tspan, ps)\nestimate = solve(discrete_prob, FunctionMap());\nnothing #hide","category":"page"},{"location":"examples/1_linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"And look at the result","category":"page"},{"location":"examples/1_linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"plot(sol, color = :black)\nplot!(estimate, color = :red, linestyle = :dash)","category":"page"},{"location":"examples/1_linear_discrete_system/#linear_discrete_copy_paste","page":"Linear Time Discrete System","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"examples/1_linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing LinearAlgebra\nusing OrdinaryDiffEq\n\nA = [0.9 -0.2; 0.0 0.2]\nu0 = [10.0; -10.0]\ntspan = (0.0, 11.0)\n\nf(u,p,t) = A*u\n\nsys = DiscreteProblem(f, u0, tspan)\nsol = solve(sys, FunctionMap());\n\nprob = DataDrivenProblem(sol)\n\nres = solve(prob, DMDSVD(), digits = 1)\n\nsystem = result(res)\nusing Symbolics\n\nusing ModelingToolkit\n\n@parameters t\n@variables x[1:2](t)\n\nbasis = Basis(x, x, independent_variable = t, name = :LinearBasis)\n\nsparse_res = solve(prob, basis, STLSQ())\n\nsparse_system = result(sparse_res)\n\n@named sys = DiscreteSystem(equations(sparse_system), get_iv(sparse_system),states(sparse_system), parameters(sparse_system))\n\nx0 = [x[1] => u0[1], x[2] => u0[2]]\nps = parameter_map(sparse_res)\n\ndiscrete_prob = DiscreteProblem(sys, x0, tspan, ps)\nestimate = solve(discrete_prob, FunctionMap());\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/1_linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"","category":"page"},{"location":"examples/1_linear_discrete_system/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"This page was generated using Literate.jl.","category":"page"},{"location":"solvers/common/#solve","page":"Solve","title":"Solve","text":"","category":"section"},{"location":"solvers/common/","page":"Solve","title":"Solve","text":"The SINDy and Koopman algorithms have been combined under a single interface to match the interface of other SciML packages. Thus, you can simply define a Problem, and then seamlessly switch between solvers. ","category":"page"},{"location":"solvers/common/","page":"Solve","title":"Solve","text":"The table below provides an overview, which class of algorithms support which class of problems.","category":"page"},{"location":"solvers/common/","page":"Solve","title":"Solve","text":"Class Direct Discrete Continuous Basis\nKoopman No Explicit Optional   Explicit Optional\nSparse Regression Explit/Implicit Explit/Implicit Explit/Implicit Necessary\nSymbolic Regression Explicit Explicit Explicit No\nOccamNet Explicit Explicit Explicit No","category":"page"},{"location":"solvers/common/","page":"Solve","title":"Solve","text":"All of the above methods return a DataDrivenSolution if not enforced otherwise.","category":"page"},{"location":"solvers/common/#common_options","page":"Solve","title":"Common Options","text":"","category":"section"},{"location":"solvers/common/","page":"Solve","title":"Solve","text":"Many of the algorithms implemented directly in DataDrivenDiffEq share common options. These can be passed into the solve call via keyworded arguments and get collected into the CommonOptions struct, which is given below. ","category":"page"},{"location":"solvers/common/","page":"Solve","title":"Solve","text":"DataDrivenCommonOptions","category":"page"},{"location":"solvers/common/#DataDrivenDiffEq.DataDrivenCommonOptions","page":"Solve","title":"DataDrivenDiffEq.DataDrivenCommonOptions","text":"mutable struct DataDrivenCommonOptions{T, K}\n\nCommon options for all methods provided via DataDrivenDiffEq. \n\nFields\n\nmaxiter\nMaximum iterations\nabstol\nAbsolute tolerance\nreltol\nRelative tolerance\nprogress\nShow a progress\nverbose\nDisplay log - Not implemented right now\ndenoise\nDenoise the data using singular value decomposition\nnormalize\nNormalize the data\nsampler\nSample options, see DataSampler\nf\nMapping from the candidate solution of a problem to features used for pareto analysis\ng\nScalarization of the features for a candidate solution\ndigits\nSignificant digits for the parameters - used for rounding. Default = 10\nkwargs\nAdditional kwargs\n\n\n\n\n\n","category":"type"},{"location":"solvers/common/","page":"Solve","title":"Solve","text":"info: Info\nThe keyword argument eval_expression controls the function creation behavior. eval_expression=true means that eval is used, so normal world-age behavior applies (i.e. the functions cannot be called from the function that generates them). If eval_expression=false, then construction via GeneralizedGenerated.jl is utilized to allow for same world-age evaluation. However, this can cause Julia to segfault on sufficiently large basis functions. By default eval_expression=false.","category":"page"},{"location":"solvers/common/#Solving-the-Problem","page":"Solve","title":"Solving the Problem","text":"","category":"section"},{"location":"solvers/common/","page":"Solve","title":"Solve","text":"After defining a problem, we choose a method to solve it. Depending on the input arguments and the type of problem, the function will return a result derived the algorithm of choice. Different options can be provided, depending on the inference method, for options like rounding, normalization, or the progress bar. A Basis can be used for lifting the measurements.","category":"page"},{"location":"solvers/common/","page":"Solve","title":"Solve","text":"# Use a Koopman based inference\nres = solve(problem, DMDSVD(), kwargs...)\n# Use a sparse identification\nres = solve(problem, basis, STLQS(), kwargs...)","category":"page"},{"location":"solvers/common/","page":"Solve","title":"Solve","text":"The DataDrivenSolution res contains a result which is the inferred system and a Basis, metrics which is a NamedTuple containing different metrics of the inferred system. These can be accessed via:","category":"page"},{"location":"solvers/common/","page":"Solve","title":"Solve","text":"# The inferred system\nsystem = result(res)\n# The metrics\nm = metrics(res)","category":"page"},{"location":"solvers/common/","page":"Solve","title":"Solve","text":"Since the inferred system is a parametrized equation, the corresponding parameters can be accessed and returned via","category":"page"},{"location":"solvers/common/","page":"Solve","title":"Solve","text":"# Vector\nps = parameters(res)\n# Parameter map\nps = parameter_map(res)","category":"page"},{"location":"solvers/koopman/#Koopman-Inference","page":"Koopman Inference","title":"Koopman Inference","text":"","category":"section"},{"location":"solvers/koopman/#koopman_algorithms","page":"Koopman Inference","title":"Algorithms","text":"","category":"section"},{"location":"solvers/koopman/","page":"Koopman Inference","title":"Koopman Inference","text":"DMDPINV\nDMDSVD\nTOTALDMD\nFBDMD","category":"page"},{"location":"solvers/koopman/#DataDrivenDiffEq.DMDPINV","page":"Koopman Inference","title":"DataDrivenDiffEq.DMDPINV","text":"mutable struct DMDPINV <: DataDrivenDiffEq.AbstractKoopmanAlgorithm\n\nApproximates the Koopman operator K based on\n\nK = Y / X\n\nwhere Y and X are data matrices. Returns a  Eigen factorization of the operator.\n\nFields\n\nSignatures\n\n\n\n\n\n","category":"type"},{"location":"solvers/koopman/#DataDrivenDiffEq.DMDSVD","page":"Koopman Inference","title":"DataDrivenDiffEq.DMDSVD","text":"mutable struct DMDSVD{T} <: DataDrivenDiffEq.AbstractKoopmanAlgorithm\n\nApproximates the Koopman operator K based on the singular value decomposition of X such that:\n\nK = Y*V*Σ*U'\n\nwhere Y and X = U*Σ*V' are data matrices. The singular value decomposition is truncated via the truncation parameter, which can either be an Int indiciating an index based truncation or a Real indiciating a tolerance based truncation. Returns a Eigen factorization of the operator.\n\nFields\n\ntruncation\nIndiciates the truncation\n\nSignatures\n\n\n\n\n\n","category":"type"},{"location":"solvers/koopman/#DataDrivenDiffEq.TOTALDMD","page":"Koopman Inference","title":"DataDrivenDiffEq.TOTALDMD","text":"mutable struct TOTALDMD{R, A} <: DataDrivenDiffEq.AbstractKoopmanAlgorithm\n\nApproximates the Koopman operator K with the algorithm alg over the rank-reduced data matrices Xᵣ = X Qᵣ and Yᵣ = Y Qᵣ, where Qᵣ originates from the singular value decomposition of the joint data Z = [X; Y]. Based on this paper.\n\nIf rtol ∈ (0, 1) is given, the singular value decomposition is reduced to include only entries bigger than rtol*maximum(Σ). If rtol is an integer, the reduced SVD up to rtol is used for computation.\n\nFields\n\ntruncation\nalg\n\nSignatures\n\n\n\n\n\n","category":"type"},{"location":"solvers/koopman/#DataDrivenDiffEq.FBDMD","page":"Koopman Inference","title":"DataDrivenDiffEq.FBDMD","text":"mutable struct FBDMD{R} <: DataDrivenDiffEq.AbstractKoopmanAlgorithm\n\nApproximates the Koopman operator K via the forward-backward DMD. It is assumed that K = sqrt(K₁*inv(K₂)), where K₁ is the approximation via forward and K₂ via DMDSVD. Based on this paper.\n\nIf truncation ∈ (0, 1) is given, the singular value decomposition is reduced to include only entries bigger than truncation*maximum(Σ). If truncation is an integer, the reduced SVD up to truncation is used for computation.\n\nFields\n\nalg\n\nSignatures\n\n\n\n\n\n","category":"type"},{"location":"problems/#problem","page":"Problems","title":"Problems","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"DataDrivenProblem","category":"page"},{"location":"problems/#DataDrivenDiffEq.DataDrivenProblem","page":"Problems","title":"DataDrivenDiffEq.DataDrivenProblem","text":"struct DataDrivenProblem{dType, cType, probType} <: DataDrivenDiffEq.AbstractDataDrivenProblem{dType, cType, probType}\n\nThe DataDrivenProblem defines a general estimation problem given measurements, inputs and (in the near future) observations. Three construction methods are available:\n\nDirectDataDrivenProblem for direct mappings\nDiscreteDataDrivenProblem for time discrete systems\nContinousDataDrivenProblem for systems continuous in time\n\nwhere all are aliases for constructing a problem.\n\nFields\n\nX\nState measurements\nt\nTime measurements (optional)\nDX\nDifferental state measurements (optional); Used for time continuous problems\nY\nOutput measurements (optional); Used for direct problems\nU\nInput measurements (optional); Used for non-autonoumous problems\np\nParameters associated with the problem (optional)\nname\nName of the problem\n\nSignatures\n\nExample\n\nX, DX, t = data...\n\n# Define a discrete time problem\nprob = DiscreteDataDrivenProblem(X)\n\n# Define a continuous time problem without explicit time points\nprob = ContinuousDataDrivenProblem(X, DX)\n\n# Define a continuous time problem without explicit derivatives\nprob = ContinuousDataDrivenProblem(X, t)\n\n# Define a discrete time problem with an input function as a function\ninput_signal(u,p,t) = t^2\nprob = DiscreteDataDrivenProblem(X, t, input_signal)\n\n\n\n\n\n","category":"type"},{"location":"problems/#Defining-a-Problem","page":"Problems","title":"Defining a Problem","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"Problems of identification, estimation, or inference are defined by data. These data contain at least measurements of the states X, which would be sufficient to describe a DiscreteDataDrivenProblem with unit time steps similar to the first example on dynamic mode decomposition. Of course, we can extend this to include time points t, control signals U or a function describing those u(x,p,t). Additionally, any parameters p known a priori can be included in the problem. In practice, this looks like:","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"problem = DiscreteDataDrivenProblem(X)\nproblem = DiscreteDataDrivenProblem(X, t)\nproblem = DiscreteDataDrivenProblem(X, t, U)\nproblem = DiscreteDataDrivenProblem(X, t, U, p = p)\nproblem = DiscreteDataDrivenProblem(X, t, (x,p,t)->u(x,p,t))","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"Similarly, a ContinuousDataDrivenProblem would need at least measurements and time-derivatives (X and DX) or measurements, time information and a way to derive the time derivatives(X, t and a Collocation method). Again, this can be extended by including a control input as measurements or a function and possible parameters:","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"# Using available data\nproblem = ContinuousDataDrivenProblem(X, DX)\nproblem = ContinuousDataDrivenProblem(X, t, DX)\nproblem = ContinuousDataDrivenProblem(X, t, DX, U, p = p)\nproblem = ContinuousDataDrivenProblem(X, t, DX, (x,p,t)->u(x,p,t))\n\n# Using collocation\nproblem = ContinuousDataDrivenProblem(X, t, InterpolationMethod())\nproblem = ContinuousDataDrivenProblem(X, t, GaussianKernel())\nproblem = ContinuousDataDrivenProblem(X, t, U, InterpolationMethod())\nproblem = ContinuousDataDrivenProblem(X, t, U, GaussianKernel(), p = p)","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"You can also directly use a DESolution as an input to your DataDrivenProblem:","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"problem = DataDrivenProblem(sol; kwargs...)","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"which evaluates the function at the specific timepoints t using the parameters p of the original problem instead of using the interpolation. If you want to use the interpolated data, add the additional keyword use_interpolation = true.","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"An additional type of problem is the DirectDataDrivenProblem, which does not assume any kind of causal relationship. It is defined by X and an observed output Y in addition to the usual arguments:","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"problem = DirectDataDrivenProblem(X, Y)\nproblem = DirectDataDrivenProblem(X, t, Y)\nproblem = DirectDataDrivenProblem(X, t, Y, U)\nproblem = DirectDataDrivenProblem(X, t, Y, p = p)\nproblem = DirectDataDrivenProblem(X, t, Y, (x,p,t)->u(x,p,t), p = p)","category":"page"},{"location":"problems/#Concrete-Types","page":"Problems","title":"Concrete Types","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"DiscreteDataDrivenProblem\nContinuousDataDrivenProblem\nDirectDataDrivenProblem","category":"page"},{"location":"problems/#DataDrivenDiffEq.DiscreteDataDrivenProblem","page":"Problems","title":"DataDrivenDiffEq.DiscreteDataDrivenProblem","text":"A time discrete DataDrivenProblem useable for problems of the form f(x[i],p,t,u) ↦ x[i+1].\n\nDiscreteDataDrivenProblem(X; kwargs...)\n\n\n\n\n\n\n","category":"function"},{"location":"problems/#DataDrivenDiffEq.ContinuousDataDrivenProblem","page":"Problems","title":"DataDrivenDiffEq.ContinuousDataDrivenProblem","text":"A time continuous DataDrivenProblem useable for problems of the form f(x,p,t,u) ↦ dx/dt.\n\nContinuousDataDrivenProblem(X, DX; kwargs...)\n\n\nAutomatically constructs derivatives via an additional collocation method, which can be either a collocation or an interpolation from DataInterpolations.jl wrapped by an InterpolationMethod.\n\n\n\n\n\n","category":"function"},{"location":"problems/#DataDrivenDiffEq.DirectDataDrivenProblem","page":"Problems","title":"DataDrivenDiffEq.DirectDataDrivenProblem","text":"A direct DataDrivenProblem useable for problems of the form f(x,p,t,u) ↦ y.\n\nDirectDataDrivenProblem(X, Y; kwargs...)\n\n\n\n\n\n\n","category":"function"},{"location":"problems/#dataset","page":"Problems","title":"Datasets","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"DataDrivenDataset","category":"page"},{"location":"problems/#DataDrivenDiffEq.DataDrivenDataset","page":"Problems","title":"DataDrivenDiffEq.DataDrivenDataset","text":"struct DataDrivenDataset{N, U, C} <: DataDrivenDiffEq.AbstractDataDrivenProblem{N, U, C}\n\nA collection of DataDrivenProblems used to concatenate different trajectories or experiments.\n\nCan be called with either a NTuple of problems or a NamedTuple of NamedTuples.  Similar to the DataDrivenProblem, it has three constructors available:\n\nDirectDataset for direct problems\nDiscreteDataset for discrete problems\nContinuousDataset for continuous problems\n\nFields\n\nname\nName of the dataset\nprobs\nThe problems\nsizes\nThe length of each problem - for internal use\n\nSignatures\n\n\n\n\n\n","category":"type"},{"location":"problems/","page":"Problems","title":"Problems","text":"A DataDrivenDataset collects several DataDrivenProblems of the same type but treads them as union used for system identification. ","category":"page"},{"location":"problems/#Concrete-Types-2","page":"Problems","title":"Concrete Types","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"DiscreteDataset\nContinuousDataset\nDirectDataset","category":"page"},{"location":"problems/#DataDrivenDiffEq.DiscreteDataset","page":"Problems","title":"DataDrivenDiffEq.DiscreteDataset","text":"A time discrete DataDrivenDataset useable for problems of the form f(x,p,t,u) ↦ x(t+1).\n\nDiscreteDataset(s; name, kwargs...)\n\n\n\n\n\n\n","category":"function"},{"location":"problems/#DataDrivenDiffEq.ContinuousDataset","page":"Problems","title":"DataDrivenDiffEq.ContinuousDataset","text":"A time continuous DataDrivenDataset useable for problems of the form f(x,p,t,u) ↦ dx/dt.\n\nContinuousDataset(s; name, collocation, kwargs...)\n\n\nAutomatically constructs derivatives via an additional collocation method, which can be either a collocation or an interpolation from DataInterpolations.jl wrapped by an InterpolationMethod provided by the collocation keyworded argument.\n\n\n\n\n\n","category":"function"},{"location":"problems/#DataDrivenDiffEq.DirectDataset","page":"Problems","title":"DataDrivenDiffEq.DirectDataset","text":"A direct DataDrivenDataset useable for problems of the form f(x,p,t,u) ↦ y.\n\nDirectDataset(s; name, kwargs...)\n\n\n\n\n\n\n","category":"function"},{"location":"problems/#DataSampler","page":"Problems","title":"DataSampler","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"DataSampler\nSplit\nBatcher","category":"page"},{"location":"problems/#DataDrivenDiffEq.DataSampler","page":"Problems","title":"DataDrivenDiffEq.DataSampler","text":"struct DataSampler{T} <: DataDrivenDiffEq.AbstractSampler\n\nA simple sampler container.  Takes in AbstractSamplers to apply onto a DataDrivenProblem in the order they are given. If a Split sampler is provided, then it will be moved to the first index by definition. \n\n\n\n\n\n","category":"type"},{"location":"problems/#DataDrivenDiffEq.Split","page":"Problems","title":"DataDrivenDiffEq.Split","text":"struct Split <: DataDrivenDiffEq.AbstractSampler\n\nPerforms a train test split of the DataDrivenProblem where ratio  defines the (rough) percentage of training data. \n\nThe optional keyword shuffle indicates to sample from random shuffles of the data, allowing  for repetition.\n\nReturns ranges for training and testing data.\n\n\n\n\n\n","category":"type"},{"location":"problems/#DataDrivenDiffEq.Batcher","page":"Problems","title":"DataDrivenDiffEq.Batcher","text":"struct Batcher <: DataDrivenDiffEq.AbstractSampler\n\nPartitions the DataDrivenProblem into n equal partitions. If used after performing a train test Split, works just on the training data.\n\nThe optional keyword shuffle indicates to sample from random shuffles of the data, allowing  for repetition.\n\nThe optional keyword repeated indicates to allow for repeated sampling of data points.\n\nbatchsize_min is the minimum batchsize, which should be used within each partition of the dataset.\n\nReturns ranges for each partition of the provided data.\n\n\n\n\n\n","category":"type"},{"location":"examples/4_nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"EditURL = \"https://github.com/SciML/DataDrivenDiffEq.jl/blob/master/docs/examples/4_nonlinear_continuous_system.jl\"","category":"page"},{"location":"examples/4_nonlinear_continuous_system/#nonlinear_continuos","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"","category":"section"},{"location":"examples/4_nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"Similarly, we can use the Extended Dynamic Mode Decomposition via a nonlinear Basis of observables. Here, we will look at a rather famous example with a finite dimensional solution.","category":"page"},{"location":"examples/4_nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing ModelingToolkit\nusing OrdinaryDiffEq\nusing Plots\n\nfunction slow_manifold(du, u, p, t)\n    du[1] = p[1] * u[1]\n    du[2] = p[2] * (u[2] - u[1]^2)\nend\n\nu0 = [3.0; -2.0]\ntspan = (0.0, 5.0)\np = [-0.8; -0.7]\n\nproblem = ODEProblem(slow_manifold, u0, tspan, p)\nsolution = solve(problem, Tsit5(), saveat = 0.01)\nplot(solution)","category":"page"},{"location":"examples/4_nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"Since we are dealing with a continuous system in time, we define the associated DataDrivenProblem accordingly using the measured states X, their derivatives DX and the time t.","category":"page"},{"location":"examples/4_nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"prob = ContinuousDataDrivenProblem(solution)","category":"page"},{"location":"examples/4_nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"Additionally, we need to define the Basis for our lifting, before we solve the problem in the lifted space.","category":"page"},{"location":"examples/4_nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"@parameters t\n@variables u[1:2](t)\nΨ = Basis([u; u[1]^2], u, independent_variable = t)\nres = solve(prob, Ψ, DMDPINV(), digits = 1)\nsystem = result(res)\nprintln(res) # hide\nprintln(system) # hide\nprintln(parameters(res)) # hide","category":"page"},{"location":"examples/4_nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"The underlying dynamics have been recovered correctly by the algorithm! Similarly we could use sparse identification to solve the problem","category":"page"},{"location":"examples/4_nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"sparse_res = solve(prob, Ψ, STLSQ(), digits = 1)\nprintln(sparse_res)","category":"page"},{"location":"examples/4_nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"And the resulting system","category":"page"},{"location":"examples/4_nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"sparse_system = result(sparse_res)\nprintln(sparse_system)","category":"page"},{"location":"examples/4_nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"We can also directly look at the parameters of each result","category":"page"},{"location":"examples/4_nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"parameter_map(res)","category":"page"},{"location":"examples/4_nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"Note that we are using parameter_map instead of just parameters, which returns a vector suitable to use with ModelingToolkit.","category":"page"},{"location":"examples/4_nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"parameter_map(sparse_res)","category":"page"},{"location":"examples/4_nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"To simulate the system, we create an ODESystem from the result","category":"page"},{"location":"examples/4_nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"Both results can be converted into an ODESystem","category":"page"},{"location":"examples/4_nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"@named sys = ODESystem(\n    equations(sparse_system),\n    get_iv(sparse_system),\n    states(sparse_system),\n    parameters(sparse_system)\n    );\n\n\nx0 = [u[1] => u0[1], u[2] => u0[2]]\nps = parameter_map(sparse_res)","category":"page"},{"location":"examples/4_nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"And simulated using OrdinaryDiffEq.jl using the (known) initial conditions and the parameter mapping of the estimation.","category":"page"},{"location":"examples/4_nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"ode_prob = ODEProblem(sys, x0, tspan, ps)\nestimate = solve(ode_prob, Tsit5(), saveat = prob.t);\nnothing #hide","category":"page"},{"location":"examples/4_nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"And look at the result","category":"page"},{"location":"examples/4_nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"plot(solution, color = :black)\nplot!(estimate, color = :red, linestyle = :dash)","category":"page"},{"location":"examples/4_nonlinear_continuous_system/#linear_discrete_copy_paste","page":"Nonlinear Time Continuous System","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"examples/4_nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing ModelingToolkit\nusing OrdinaryDiffEq\n\nfunction slow_manifold(du, u, p, t)\n    du[1] = p[1] * u[1]\n    du[2] = p[2] * (u[2] - u[1]^2)\nend\n\nu0 = [3.0; -2.0]\ntspan = (0.0, 5.0)\np = [-0.8; -0.7]\n\nproblem = ODEProblem(slow_manifold, u0, tspan, p)\nsolution = solve(problem, Tsit5(), saveat = 0.01)\n\nprob = ContinuousDataDrivenProblem(solution)\n\n@parameters t\n@variables u[1:2](t)\nΨ = Basis([u; u[1]^2], u, independent_variable = t)\nres = solve(prob, Ψ, DMDPINV(), digits = 1)\nsystem = result(res)\n\nsparse_res = solve(prob, Ψ, STLSQ(), digits = 1)\n\nsparse_system = result(sparse_res)\n\nparameter_map(res)\n\nparameter_map(sparse_res)\n\n@named sys = ODESystem(\n    equations(sparse_system),\n    get_iv(sparse_system),\n    states(sparse_system),\n    parameters(sparse_system)\n    );\n\n\nx0 = [u[1] => u0[1], u[2] => u0[2]]\nps = parameter_map(sparse_res)\n\node_prob = ODEProblem(sys, x0, tspan, ps)\nestimate = solve(ode_prob, Tsit5(), saveat = prob.t);\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/4_nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"","category":"page"},{"location":"examples/4_nonlinear_continuous_system/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/9_heatequation/","page":"PDE Discovery : Heat equations","title":"PDE Discovery : Heat equations","text":"EditURL = \"https://github.com/SciML/DataDrivenDiffEq.jl/blob/master/docs/examples/9_heatequation.jl\"","category":"page"},{"location":"examples/9_heatequation/#heat_equation","page":"PDE Discovery : Heat equations","title":"PDE Discovery : Heat equations","text":"","category":"section"},{"location":"examples/9_heatequation/","page":"PDE Discovery : Heat equations","title":"PDE Discovery : Heat equations","text":"Similar to the discovery of ODE and DAE systems, sparse regression can be used to discover the underlying equations for partial differential equations as well as proposed by PDEFind. The following example shows how this can be achieved with DataDrivenDiffEq.jl, using the heat equation with Dirichlet boundary conditions with the analytical soultion u(xt) = sin(2pi x) exp^-(2pi t)^2t. We start by defining the system and generate some data.","category":"page"},{"location":"examples/9_heatequation/","page":"PDE Discovery : Heat equations","title":"PDE Discovery : Heat equations","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing ModelingToolkit\nusing OrdinaryDiffEq\nusing DiffEqOperators\nusing Plots\n\nu_analytic(x, t) = sin(2*π*x) * exp(-t*(2*π)^2)\nnknots = 100\nh = 1.0/(nknots+1)\nknots = range(h, step=h, length=nknots)\nord_deriv = 2\nord_approx = 2\n\nconst bc = Dirichlet0BC(Float64)\nconst Δ = CenteredDifference(ord_deriv, ord_approx, h, nknots)\n\nt0 = 0.0\nt1 = 1.0\nu0 = u_analytic.(knots, t0)\n\nstep(u,p,t) = Δ*bc*u\nprob = ODEProblem(step, u0, (t0, t1))\nalg = KenCarp4()\nde_solution = solve(prob, alg)\n\nplot(de_solution, legend = nothing)","category":"page"},{"location":"examples/9_heatequation/","page":"PDE Discovery : Heat equations","title":"PDE Discovery : Heat equations","text":"Using DiffEqOperators.jl, we can define the difference operators up to order n =4 and vectorize the result.","category":"page"},{"location":"examples/9_heatequation/","page":"PDE Discovery : Heat equations","title":"PDE Discovery : Heat equations","text":"∂U = reduce(vcat, map(1:4) do n\n    δ = CenteredDifference(n, ord_approx, h, nknots)\n    reshape(\n        δ*bc*Array(de_solution), 1, prod(size(de_solution))\n        )\n    end)","category":"page"},{"location":"examples/9_heatequation/","page":"PDE Discovery : Heat equations","title":"PDE Discovery : Heat equations","text":"Next we collect the discretized data samples, their time derivatives and define a DataDrivenProblem","category":"page"},{"location":"examples/9_heatequation/","page":"PDE Discovery : Heat equations","title":"PDE Discovery : Heat equations","text":"U = reshape(Array(de_solution), 1, prod(size(de_solution)))\n∂ₜU = reshape(Array(de_solution(de_solution.t, Val{1})), 1, prod(size(de_solution)))\n\nproblem = DataDrivenProblem(\n    U, DX = ∂ₜU, U = ∂U\n)","category":"page"},{"location":"examples/9_heatequation/","page":"PDE Discovery : Heat equations","title":"PDE Discovery : Heat equations","text":"We choose to model the spatial derivatives fracd^n udx^n as exegenous signals (controls), which are directly substituted into the Basis defined in the following","category":"page"},{"location":"examples/9_heatequation/","page":"PDE Discovery : Heat equations","title":"PDE Discovery : Heat equations","text":"@parameters t x\n@variables u(x, t)\n∂u = map(1:4) do n\n    d = Differential(x)^n\n    d(u)\nend\n\nbasis = Basis([monomial_basis([u], 5);∂u], [u], independent_variable = t, controls = ∂u);\nprintln(basis) #hide","category":"page"},{"location":"examples/9_heatequation/","page":"PDE Discovery : Heat equations","title":"PDE Discovery : Heat equations","text":"Afterwards, we define a sampler for the available data which performs a 80-20 train-test split and partions the training data into 10 batches and solve the sparse regression using STLSQ.","category":"page"},{"location":"examples/9_heatequation/","page":"PDE Discovery : Heat equations","title":"PDE Discovery : Heat equations","text":"sampler = DataSampler(Split(ratio = 0.8), Batcher(n = 10))\nsolution = solve(problem, basis, STLSQ(1e-2:1e-2:5e-1), sampler = sampler, by = :best)","category":"page"},{"location":"examples/9_heatequation/","page":"PDE Discovery : Heat equations","title":"PDE Discovery : Heat equations","text":"As we can see, the heat equation is recovered correclty","category":"page"},{"location":"examples/9_heatequation/","page":"PDE Discovery : Heat equations","title":"PDE Discovery : Heat equations","text":"result(solution)\nprintln(result(solution)) #hide","category":"page"},{"location":"examples/9_heatequation/#cartpole_copy_paste","page":"PDE Discovery : Heat equations","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"examples/9_heatequation/","page":"PDE Discovery : Heat equations","title":"PDE Discovery : Heat equations","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing ModelingToolkit\nusing OrdinaryDiffEq\nusing DiffEqOperators\n\nu_analytic(x, t) = sin(2*π*x) * exp(-t*(2*π)^2)\nnknots = 100\nh = 1.0/(nknots+1)\nknots = range(h, step=h, length=nknots)\nord_deriv = 2\nord_approx = 2\n\nconst bc = Dirichlet0BC(Float64)\nconst Δ = CenteredDifference(ord_deriv, ord_approx, h, nknots)\n\nt0 = 0.0\nt1 = 1.0\nu0 = u_analytic.(knots, t0)\n\nstep(u,p,t) = Δ*bc*u\nprob = ODEProblem(step, u0, (t0, t1))\nalg = KenCarp4()\nde_solution = solve(prob, alg)\n\n∂U = reduce(vcat, map(1:4) do n\n    δ = CenteredDifference(n, ord_approx, h, nknots)\n    reshape(\n        δ*bc*Array(de_solution), 1, prod(size(de_solution))\n        )\n    end)\n\nU = reshape(Array(de_solution), 1, prod(size(de_solution)))\n∂ₜU = reshape(Array(de_solution(de_solution.t, Val{1})), 1, prod(size(de_solution)))\n\nproblem = DataDrivenProblem(\n    U, DX = ∂ₜU, U = ∂U\n)\n\n@parameters t x\n@variables u(x, t)\n∂u = map(1:4) do n\n    d = Differential(x)^n\n    d(u)\nend\n\nbasis = Basis([monomial_basis([u], 5);∂u], [u], independent_variable = t, controls = ∂u);\nprintln(basis) #hide\n\nsampler = DataSampler(Split(ratio = 0.8), Batcher(n = 10))\nsolution = solve(problem, basis, STLSQ(1e-2:1e-2:5e-1), sampler = sampler, by = :best)\n\nresult(solution)\nprintln(result(solution)) #hide\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/9_heatequation/","page":"PDE Discovery : Heat equations","title":"PDE Discovery : Heat equations","text":"","category":"page"},{"location":"examples/9_heatequation/","page":"PDE Discovery : Heat equations","title":"PDE Discovery : Heat equations","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/2_linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"EditURL = \"https://github.com/SciML/DataDrivenDiffEq.jl/blob/master/docs/examples/2_linear_continuous_system.jl\"","category":"page"},{"location":"examples/2_linear_continuous_system/#linear_continuous","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"","category":"section"},{"location":"examples/2_linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"Similar to the linear time discrete example, we will now estimate a linear time continuous system partial_t u = A u. We simulate the correspoding system using OrdinaryDiffEq.jl and generate a ContinuousDataDrivenProblem from the simulated data.","category":"page"},{"location":"examples/2_linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing Plots\n\nA = [-0.9 0.2; 0.0 -0.2]\nu0 = [10.0; -10.0]\ntspan = (0.0, 10.0)\n\nf(u,p,t) = A*u\n\nsys = ODEProblem(f, u0, tspan)\nsol = solve(sys, Tsit5(), saveat = 0.05);\nnothing #hide","category":"page"},{"location":"examples/2_linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"We could use the DESolution to define our problem, but here we want to use the data for didactic purposes. For a ContinuousDataDrivenProblem, we need either the state trajectory and the timepoints or the state trajectory and its derivate.","category":"page"},{"location":"examples/2_linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"X = Array(sol)\nt = sol.t\nprob = ContinuousDataDrivenProblem(X, t)","category":"page"},{"location":"examples/2_linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"And plot the problems data.","category":"page"},{"location":"examples/2_linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"plot(prob)","category":"page"},{"location":"examples/2_linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"We can see that the derivative has been automatically added via a collocation method, which defaults to a LinearInterpolation. We can do a visual check and compare our derivatives with the interpolation of the ODESolution.","category":"page"},{"location":"examples/2_linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"DX = Array(sol(t, Val{1}))\nscatter(t, DX', label = [\"Solution\" nothing], color = :red, legend = :bottomright)\nplot!(t, prob.DX', label = [\"Linear Interpolation\" nothing], color = :black)","category":"page"},{"location":"examples/2_linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"Since we have a linear system, we can use gDMD, which approximates the generator of the dynamics","category":"page"},{"location":"examples/2_linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"res = solve(prob, DMDSVD())\nprintln(res)","category":"page"},{"location":"examples/2_linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"We see that the system has been recovered correctly, indicated by the small error and high AIC score of the result. We can confirm this by looking at the resulting Basis","category":"page"},{"location":"examples/2_linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"system = result(res)\nprintln(system)","category":"page"},{"location":"examples/2_linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"And also plot the prediction of the recovered dynamics","category":"page"},{"location":"examples/2_linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"plot(res)","category":"page"},{"location":"examples/2_linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"Or a have a look at the metrics of the result","category":"page"},{"location":"examples/2_linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"metrics(res)","category":"page"},{"location":"examples/2_linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"And check the parameters of the result","category":"page"},{"location":"examples/2_linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"parameters(res)","category":"page"},{"location":"examples/2_linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"or the generator of the system","category":"page"},{"location":"examples/2_linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"Matrix(generator(system))","category":"page"},{"location":"examples/2_linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"to see that the operator is slightly off, but within expectations. In a real example, this could have many reasons, e.g. noisy data, insufficient time samples or missing states.","category":"page"},{"location":"examples/2_linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"Sticking to the same procedure as earlier, we now use a linear sparse regression to solve the problem","category":"page"},{"location":"examples/2_linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"using ModelingToolkit\n\n@parameters t\n@variables x[1:2](t)\n\nbasis = Basis(x, x, independent_variable = t, name = :LinearBasis)\nprint(basis) #hide","category":"page"},{"location":"examples/2_linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"Afterwards, we simply solve the already defined problem with our Basis and a SparseOptimizer","category":"page"},{"location":"examples/2_linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"sparse_res = solve(prob, basis, STLSQ(1e-1))\nprintln(sparse_res)","category":"page"},{"location":"examples/2_linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"Which holds the same equations","category":"page"},{"location":"examples/2_linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"sparse_system = result(sparse_res)\nprintln(sparse_system)","category":"page"},{"location":"examples/2_linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"Again, we can have a look at the result","category":"page"},{"location":"examples/2_linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"plot(\n    plot(prob), plot(sparse_res), layout = (1,2)\n)","category":"page"},{"location":"examples/2_linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"Both results can be converted into an ODESystem","category":"page"},{"location":"examples/2_linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"@named sys = ODESystem(\n    equations(sparse_system),\n    get_iv(sparse_system),\n    states(sparse_system),\n    parameters(sparse_system)\n    );\nnothing #hide","category":"page"},{"location":"examples/2_linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"And simulated using OrdinaryDiffEq.jl using the (known) initial conditions and the parameter mapping of the estimation.","category":"page"},{"location":"examples/2_linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"x0 = [x[1] => u0[1], x[2] => u0[2]]\nps = parameter_map(sparse_res)\n\node_prob = ODEProblem(sys, x0, tspan, ps)\nestimate = solve(ode_prob, Tsit5(), saveat = prob.t);\nnothing #hide","category":"page"},{"location":"examples/2_linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"And look at the result","category":"page"},{"location":"examples/2_linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"plot(sol, color = :black)\nplot!(estimate, color = :red, linestyle = :dash)","category":"page"},{"location":"examples/2_linear_continuous_system/#linear_continuous_copy_paste","page":"Linear Time Continuous System","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"examples/2_linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing LinearAlgebra\nusing OrdinaryDiffEq\n\nA = [-0.9 0.2; 0.0 -0.2]\nu0 = [10.0; -10.0]\ntspan = (0.0, 10.0)\n\nf(u,p,t) = A*u\n\nsys = ODEProblem(f, u0, tspan)\nsol = solve(sys, Tsit5(), saveat = 0.05);\n\nX = Array(sol)\nt = sol.t\nprob = ContinuousDataDrivenProblem(X, t)\n\nusing ModelingToolkit\n\n@parameters t\n@variables x[1:2](t)\n\nbasis = Basis(x, x, independent_variable = t, name = :LinearBasis)\n\nsparse_res = solve(prob, basis, STLSQ(1e-1))\n\nsparse_system = result(sparse_res)\n\n@named sys = ODESystem(\n    equations(sparse_system),\n    get_iv(sparse_system),\n    states(sparse_system),\n    parameters(sparse_system)\n    );\n\nx0 = [x[1] => u0[1], x[2] => u0[2]]\nps = parameter_map(sparse_res)\n\node_prob = ODEProblem(sys, x0, tspan, ps)\nestimate = solve(ode_prob, Tsit5(), saveat = prob.t);\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/2_linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"","category":"page"},{"location":"examples/2_linear_continuous_system/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#DataDrivenDiffEq.jl","page":"Home","title":"DataDrivenDiffEq.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DataDrivenDiffEq.jl is a package for finding the governing equations of motion automatically from a dataset.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The methods in this package take in data and return the differential equation model which generated the data. A known model is not required as input. These methods can estimate equation-free and equation-based models for discrete and continuous differential equations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are two main types of estimation, depending on if you need the result to be human-understandable:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Structural identification - returns a human readable result in symbolic form.\nStructural estimation - returns a function that predicts the derivative and generates a correct time series, but is not necessarily human readable.","category":"page"},{"location":"#Package-Overview","page":"Home","title":"Package Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DataDrivenDiffEq.jl currently implements the following algorithms for structural estimation and identification. Please note that all the algorithms have been unified under a single mathematical framework, so the interface might be a little different than what you expect.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Dynamic Mode Decomposition (DMD)\nExtended Dynamic Mode Decomposition\nSparse Identification of Nonlinear Dynamics (SINDy)\nImplicit Sparse Identification of Nonlinear Dynamics","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To use DataDrivenDiffEq.jl, install via:","category":"page"},{"location":"","page":"Home","title":"Home","text":"]add DataDrivenDiffEq\nusing DataDrivenDiffEq","category":"page"},{"location":"examples/5_michaelis_menten/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"EditURL = \"https://github.com/SciML/DataDrivenDiffEq.jl/blob/master/docs/examples/5_michaelis_menten.jl\"","category":"page"},{"location":"examples/5_michaelis_menten/#michaelis_menten","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"","category":"section"},{"location":"examples/5_michaelis_menten/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"What if you want to estimate an implicitly defined system of the form f(u_t u p t) = 0? The solution : Implicit Sparse Identification. This method was originally described in this paper, and currently there exist robust algorithms to identify these systems. We will focus on Michaelis Menten Kinetics. As before, we will define the DataDrivenProblem and the Basis containing possible candidate functions for our sparse_regression!. Lets generate some data! We will use two experiments starting from different initial conditions.","category":"page"},{"location":"examples/5_michaelis_menten/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing ModelingToolkit\nusing OrdinaryDiffEq\nusing Plots\n\nfunction michaelis_menten(u, p, t)\n    [0.6 - 1.5u[1]/(0.3+u[1])]\nend\n\n\nu0 = [0.5]\n\nproblem_1 = ODEProblem(michaelis_menten, u0, (0.0, 4.0))\nsolution_1 = solve(problem_1, Tsit5(), saveat = 0.1)\nproblem_2 = ODEProblem(michaelis_menten, 2*u0, (4.0, 8.0))\nsolution_2 = solve(problem_2, Tsit5(), saveat = 0.1)","category":"page"},{"location":"examples/5_michaelis_menten/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"Since we have multiple trajectories at hand, we define a DataDrivenDataset, which collects multiple problems but handles them as a unit for the processing.","category":"page"},{"location":"examples/5_michaelis_menten/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"function michaelis_menten(X::AbstractMatrix, p, t::AbstractVector)\n    reduce(hcat, map((x,ti)->michaelis_menten(x, p, ti), eachcol(X), t))\nend\n\ndata = (\n    Experiment_1 = (X = Array(solution_1), t = solution_1.t, DX = michaelis_menten(Array(solution_1),[], solution_1.t) ),\n    Experiment_2 = (X = Array(solution_2), t = solution_2.t, DX = michaelis_menten(Array(solution_2),[], solution_2.t))\n)\n\n\nprob = DataDrivenDiffEq.ContinuousDataset(data)\npls = []\nfor p in prob.probs\n    push!(pls, plot(p, title = string(p.name)))\nend\nplot(pls...)","category":"page"},{"location":"examples/5_michaelis_menten/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"Next, we define our Basis. Since we want to identify an implicit system, we have to include some candidate terms which use these as an argument and inform our constructor about the meaning of these variables.","category":"page"},{"location":"examples/5_michaelis_menten/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"@parameters t\nD = Differential(t)\n@variables u[1:1](t)\nh = [monomial_basis(u[1:1], 4)...]\nbasis = Basis([h; h .* D(u[1])], u, implicits = D.(u), iv = t)\nprintln(basis) # hide","category":"page"},{"location":"examples/5_michaelis_menten/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"Next, we define the ImplicitOptimizer and solve the problem. It wraps a standard optimizer, by default STLSQ, and performs implicit sparse regression upon the selected basis. To improve our result, we batch the data by using a DataSampler. Here, we use a train-test split of 0.8 and divide the training data into 10 batches. Since we are using a batching process, we can also use a different","category":"page"},{"location":"examples/5_michaelis_menten/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"sampler = DataSampler(\n    Split(ratio = 0.8), Batcher(n = 10)\n)\n\nopt = ImplicitOptimizer(1e-1:1e-1:5e-1)\nres = solve(prob, basis, opt,  normalize = false, denoise = false, by = :min, sampler = sampler, maxiter = 1000);\nprintln(res) # hide","category":"page"},{"location":"examples/5_michaelis_menten/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"As we can see, the DataDrivenSolution has good metrics. Furthermore, inspection of the underlying system shows that the original equations have been recovered correctly:","category":"page"},{"location":"examples/5_michaelis_menten/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"system = result(res)\nprintln(system) # hide\n\nplot(\n    plot(prob), plot(res), layout = (1,2)\n)","category":"page"},{"location":"examples/5_michaelis_menten/#michaelis_menten_copy_paste","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"examples/5_michaelis_menten/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing ModelingToolkit\nusing OrdinaryDiffEq\n\nfunction michaelis_menten(u, p, t)\n    [0.6 - 1.5u[1]/(0.3+u[1])]\nend\n\n\nu0 = [0.5]\n\nproblem_1 = ODEProblem(michaelis_menten, u0, (0.0, 4.0))\nsolution_1 = solve(problem_1, Tsit5(), saveat = 0.1)\nproblem_2 = ODEProblem(michaelis_menten, 2*u0, (4.0, 8.0))\nsolution_2 = solve(problem_2, Tsit5(), saveat = 0.1)\n\nfunction michaelis_menten(X::AbstractMatrix, p, t::AbstractVector)\n    reduce(hcat, map((x,ti)->michaelis_menten(x, p, ti), eachcol(X), t))\nend\n\ndata = (\n    Experiment_1 = (X = Array(solution_1), t = solution_1.t, DX = michaelis_menten(Array(solution_1),[], solution_1.t) ),\n    Experiment_2 = (X = Array(solution_2), t = solution_2.t, DX = michaelis_menten(Array(solution_2),[], solution_2.t))\n)\n\n\nprob = DataDrivenDiffEq.ContinuousDataset(data)\n\n@parameters t\nD = Differential(t)\n@variables u[1:1](t)\nh = [monomial_basis(u[1:1], 4)...]\nbasis = Basis([h; h .* D(u[1])], u, implicits = D.(u), iv = t)\nprintln(basis) # hide\n\nsampler = DataSampler(\n    Split(ratio = 0.8), Batcher(n = 10)\n)\n\nopt = ImplicitOptimizer(1e-1:1e-1:5e-1)\nres = solve(prob, basis, opt,  normalize = false, denoise = false, by = :min, sampler = sampler, maxiter = 1000);\nprintln(res) # hide\n\nsystem = result(res)\nprintln(system) # hide\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/5_michaelis_menten/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"","category":"page"},{"location":"examples/5_michaelis_menten/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"This page was generated using Literate.jl.","category":"page"}]
}
