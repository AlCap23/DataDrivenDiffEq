<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Symbolic Regression · DataDrivenDiffEq.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://datadriven.sciml.ai/stable/examples/symbolic_regression/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DataDrivenDiffEq.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../getting_started/">Getting Started</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../linear_systems/">Linear Systems</a></li><li><a class="tocitem" href="../nonlinear_systems/">Nonlinear Systems</a></li><li><a class="tocitem" href="../implicit_systems/">Implicit Systems</a></li><li class="is-active"><a class="tocitem" href>Symbolic Regression</a><ul class="internal"><li><a class="tocitem" href="#symbolic_regression_tutorial"><span>Symbolic Regression</span></a></li><li><a class="tocitem" href="#occam_net_tutorial"><span>OccamNet</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../sindy_dmd/">Unifying SINDy and DMD</a></li><li><a class="tocitem" href="../../problems/">Problems</a></li><li><a class="tocitem" href="../../basis/">Basis</a></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../../solvers/koopman/">Koopman</a></li><li><a class="tocitem" href="../../solvers/optimization/">Sparse Optimizers</a></li><li><a class="tocitem" href="../../solvers/symbolic_regression/">Symbolic Regression</a></li></ul></li><li><a class="tocitem" href="../../solutions/">Solutions</a></li><li><a class="tocitem" href="../../utils/">Utilities</a></li><li><a class="tocitem" href="../../contributions/">Contributing</a></li><li><a class="tocitem" href="../../citations/">Citing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Symbolic Regression</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Symbolic Regression</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/DataDrivenDiffEq.jl/blob/master/docs/src/examples/symbolic_regression.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Symbolic-Regression"><a class="docs-heading-anchor" href="#Symbolic-Regression">Symbolic Regression</a><a id="Symbolic-Regression-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolic-Regression" title="Permalink"></a></h1><h2 id="symbolic_regression_tutorial"><a class="docs-heading-anchor" href="#symbolic_regression_tutorial">Symbolic Regression</a><a id="symbolic_regression_tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#symbolic_regression_tutorial" title="Permalink"></a></h2><p><a href="https://github.com/SciML/DataDrivenDiffEq.jl">DataDrivenDiffEq.jl</a> provides an interface to <a href="https://github.com/MilesCranmer/SymbolicRegression.jl">SymbolicRegression.jl</a> to <code>solve</code> a <a href="../../problems/#DataDrivenDiffEq.DataDrivenProblem"><code>DataDrivenProblem</code></a>:</p><pre><code class="language-julia hljs">using DataDrivenDiffEq, LinearAlgebra, Random
using SymbolicRegression


Random.seed!(1223)
# Generate a multivariate function for SymbolicRegression
X = rand(2,20)
f(x) = [sin(x[1]); exp(x[2])]
Y = hcat(map(f, eachcol(X))...)

# Define the options
opts = EQSearch([+, *, sin, exp], maxdepth = 1, progress = false, verbosity = 0)

# Define the problem
prob = DirectDataDrivenProblem(X, Y)

# Solve the problem
res = solve(prob, opts, numprocs = 0, multithreading = false)
sys = result(res)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Model ##Basis#596 with 2 equations
States : x[1] x[2]
Independent variable: t
Equations
φ₁ = sin(x[1])
φ₂ = exp(x[2])</code></pre><p><code>Solve</code> can be used with <a href="../../solvers/symbolic_regression/#DataDrivenDiffEq.EQSearch"><code>EQSearch</code></a>, which wraps <a href="https://astroautomata.com/SymbolicRegression.jl/stable/api/#Options"><code>Options</code></a> provided by <a href="https://github.com/MilesCranmer/SymbolicRegression.jl">SymbolicRegression.jl</a>. Additional keyword arguments are <code>max_iter = 10</code>, which defines the number of iterations, <code>weights</code> which weight the measurements of the dependent variable (e.g. <code>X</code>, <code>DX</code> or <code>Y</code> depending on the <a href="../../problems/#DataDrivenDiffEq.DataDrivenProblem"><code>DataDrivenProblem</code></a>), <code>numprocs</code> which indicates the number of processes to use, <code>procs</code> for use with manually setup processes, <code>multithreading = false</code> for multithreading and <code>runtests = true</code> which performs initial testing on the environment to check for possible errors. This setup mimics the behaviour of <a href="https://astroautomata.com/SymbolicRegression.jl/stable/api/#EquationSearch"><code>EquationSearch</code></a>.</p><h2 id="occam_net_tutorial"><a class="docs-heading-anchor" href="#occam_net_tutorial">OccamNet</a><a id="occam_net_tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#occam_net_tutorial" title="Permalink"></a></h2><p>As introduced in <a href="https://arxiv.org/abs/2007.10784">Interpretable Neuroevolutionary Models for Learning Non-Differentiable Functions and Programs </a>, <code>OccamNet</code> is a special form of symbolic regression which uses a probabilistic approach to equation discovery by using a feedforward multilayer neural network. In contrast to normal architectures, each layer&#39;s weights reflect the probability of which inputs to use. Additionally a set of activation functions is used, instead of a single function. Similar to simulated annealing, a temperature is included to control the exploration of possible functions.</p><p><code>DataDrivenDiffEq</code> offers two main interfaces to <code>OccamNet</code>: a <code>Flux</code> based API with <code>Flux.train!</code> and a <code>solve(...)</code> function.</p><p>Consider the following example, where we want to discover a vector valued function:</p><pre><code class="language-julia hljs">using DataDrivenDiffEq, LinearAlgebra, ModelingToolkit, Random
using Flux

Random.seed!(1223)

# Generate a multivariate dataset
X = rand(2,10)
f(x) = [sin(π*x[2]+x[1]); exp(x[2])]
Y = hcat(map(f, eachcol(X))...)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×10 Matrix{Float64}:
 0.730729  0.999265  0.969019  0.625678  …  0.669184  0.95687  0.92499
 1.04471   1.29513   1.69627   1.74007      1.5878    1.36212  1.20932</code></pre><p>Next, we define our network:</p><pre><code class="language-julia hljs">net = OccamNet(2, 2, 3, Function[sin, +, *, exp], skip = true, constants = Float64[π])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">OccamNet(4, Constants 1, Parameters 0)</code></pre><p>Where <code>2,2,3</code> refers to input and output dimension and the number of layers <em>without the output layer</em>. We also define that each layer uses the functions <code>sin, +, *, exp</code> as activations and uses a <code>π</code> as a constant, which gets concatenated to the input data. Additionally, <code>skip</code> indicates the usage of skip connections, which allow the output of each layer to be passed onto the output layer directly.</p><p>To train the network over <code>100</code> epochs using <code>ADAM</code>, we type</p><pre><code class="language-julia hljs">Flux.train!(net, X, Y, ADAM(1e-2), 100, routes = 100, nbest = 3)</code></pre><p>Under the hood, we select possible routes, <code>routes</code>, through the network based on the probability reflected by the <a href="../../solvers/symbolic_regression/#DataDrivenDiffEq.ProbabilityLayer"><code>ProbabilityLayer</code></a> forming the network. From these we use the <code>nbest</code> candidate routes to train the parameters of the network, which increases the probability of those routes.</p><p>Lets have a look at some possible equations after the initial training. We can use <code>rand</code> to sample a route through the network, compute the output probability with <code>probability</code> and transform it into analytical equations using <code>ModelingToolkit</code> variables as input. The call <code>net(x, route)</code> uses the route to compute just the elements on this path.</p><pre><code class="language-julia hljs">@variables x[1:2]

for i in 1:10
  route = rand(net)
  prob = probability(net, route)
  eq = simplify.(net(x, route))
  print(eq , &quot; with probability &quot;,  prob, &quot;\n&quot;)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Symbolics.Num[sin(exp(x[2])), exp(x[2]) + x[2]] with probability [0.02874208875253813, 0.001020356452889173]
Symbolics.Num[sin((3.141592653589793 + x[1])*x[1]), exp(x[2])] with probability [2.4268035492071496e-5, 0.10004718259206825]
Symbolics.Num[exp(x[2]), exp(x[2])] with probability [0.010309792918739237, 0.011230891123571646]
Symbolics.Num[x[1], 3.141592653589793 + x[1]] with probability [0.05388524671461696, 0.0011426040901520863]
Symbolics.Num[-0.9125775986692777, exp(x[2])] with probability [0.006522697942050591, 0.02707702334938692]
Symbolics.Num[19333.689074365135, exp(x[2])] with probability [0.0006005975724607248, 0.10004718259206825]
Symbolics.Num[sin(exp(x[2])), x[1]] with probability [0.047892106785117454, 0.04565968696366679]
Symbolics.Num[sin(exp(x[2])), exp(x[2])] with probability [0.047892106785117454, 0.10004718259206825]
Symbolics.Num[1.2246467991473532e-16, exp(x[2])] with probability [0.017199511543924042, 0.02707702334938692]
Symbolics.Num[exp(x[2]^2), x[2]^2] with probability [0.0015392645555503143, 0.00936874746648553]</code></pre><p>We see the networks proposals are not very certain. Hence, we will train for some more epochs and look at the output again.</p><pre><code class="language-julia hljs">Flux.train!(net, X, Y, ADAM(1e-2), 900, routes = 100, nbest = 3)

for i in 1:10
  route = rand(net)
  prob = probability(net, route)
  eq = simplify.(net(x, route))
  print(eq , &quot; with probability &quot;,  prob, &quot;\n&quot;)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Symbolics.Num[sin(3.141592653589793x[2] + x[1]), exp(x[2])] with probability [0.8965549834356896, 0.956500412755264]
Symbolics.Num[sin(3.141592653589793x[2] + x[1]), exp(x[2])] with probability [0.8965549834356896, 0.956500412755264]
Symbolics.Num[sin(3.141592653589793x[2] + x[1]), exp(x[2])] with probability [0.8965549834356896, 0.956500412755264]
Symbolics.Num[sin(3.141592653589793x[2] + x[1]), exp(x[2])] with probability [0.8965549834356896, 0.956500412755264]
Symbolics.Num[sin(3.141592653589793x[2] + x[1]), exp(x[2])] with probability [0.8965549834356896, 0.956500412755264]
Symbolics.Num[sin(3.141592653589793x[2] + x[1]), exp(x[2])] with probability [0.8965549834356896, 0.956500412755264]
Symbolics.Num[sin(3.141592653589793x[2] + x[1]), exp(x[2])] with probability [0.8965549834356896, 0.956500412755264]
Symbolics.Num[sin(exp(x[2])), exp(x[2])] with probability [0.002425719500856979, 0.956500412755264]
Symbolics.Num[sin(3.141592653589793x[2] + x[1]), exp(x[2])] with probability [0.8965549834356896, 0.956500412755264]
Symbolics.Num[sin(3.141592653589793x[2] + x[1]), exp(x[2])] with probability [0.8965549834356896, 0.956500412755264]</code></pre><p>The network is quite certain about the equation now, which is in fact our unknown mapping. To extract the solution with the highest probability, we set the temperature of the underlying distribution to a very low value. In the limit of <code>t ↦ 0</code> we approach a Dirac distribution, hence extracting the most likely terms.</p><pre><code class="language-julia hljs">set_temp!(net, 0.01)
route = rand(net)
prob = probability(net, route)
eq = simplify.(net(x, route))
print(eq , &quot; with probability &quot;,  prob, &quot;\n&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Symbolics.Num[sin(3.141592653589793x[2] + x[1]), exp(x[2])] with probability [1.0, 1.0]</code></pre><p>The same procedure is automated in the <code>solve</code> function. Using the same data, we wrap the algorithm&#39;s information in the <a href="../../solvers/symbolic_regression/#DataDrivenDiffEq.OccamSR"><code>OccamSR</code></a> struct and define a <a href="../../problems/#DataDrivenDiffEq.DataDrivenProblem"><code>DataDrivenProblem</code></a>:</p><pre><code class="language-julia hljs"># Define the problem
ddprob = DirectDataDrivenProblem(X, Y)
# Define the algorithm
sr_alg = OccamSR(functions = Function[sin, +, *, exp], skip = true, layers = 3, constants = [π])
# Solve the problem
res = solve(ddprob, sr_alg, ADAM(1e-2), max_iter = 1000, routes = 100, nbest = 3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Explicit Result
Solution with 2 equations and 0 parameters.
Returncode: success
L2 Norm Error: 0.0
AICC: Inf</code></pre><p>Within <code>solve</code>, a network is generated using the information provided by the <a href="../../problems/#DataDrivenDiffEq.DataDrivenProblem"><code>DataDrivenProblem</code></a> (states, control, independent variables, and the specified options). Then the network is trained, and finally the equation with the highest probability is extracted by setting the temperature as above. After computing additional metrics, a <a href="../../solutions/#DataDrivenDiffEq.DataDrivenSolution"><code>DataDrivenSolution</code></a> is returned where the equations are transformed  into a <a href="../../basis/#DataDrivenDiffEq.Basis"><code>Basis</code></a> usable with <code>ModelingToolkit</code>.</p><p>The metrics can be accessed via:</p><pre><code class="language-julia hljs">metrics(res)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(Probability = 0.8425497124024455, Error = 0.0, AICC = Inf, Probabilities = [0.898724142309076, 0.9374953589626484], Errors = [0.0, 0.0], AICCs = [Inf, Inf])</code></pre><p>and the resulting <a href="../../basis/#DataDrivenDiffEq.Basis"><code>Basis</code></a> by:</p><pre><code class="language-julia hljs">result(res)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Model ##Basis#599 with 2 equations
States : x[1] x[2]
Independent variable: t
Equations
Differential(t)(x[1]) = sin(3.141592653589793x[2] + x[1])
Differential(t)(x[2]) = exp(x[2])</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Right now, the resulting basis is not using parameters, but raw numerical values.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../implicit_systems/">« Implicit Systems</a><a class="docs-footer-nextpage" href="../../sindy_dmd/">Unifying SINDy and DMD »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Tuesday 16 November 2021 13:27">Tuesday 16 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
